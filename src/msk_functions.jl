# Contents of this file is generated. Do not edit by hand!
# MOSEK 10.0.4

export
  analyzenames,
  analyzeproblem,
  analyzesolution,
  appendacc,
  appendaccs,
  appendaccseq,
  appendaccsseq,
  appendafes,
  appendbarvars,
  appendcone,
  appendconeseq,
  appendconesseq,
  appendcons,
  appenddjcs,
  appenddualexpconedomain,
  appenddualgeomeanconedomain,
  appenddualpowerconedomain,
  appendinfnormconedomain,
  appendonenormconedomain,
  appendprimalexpconedomain,
  appendprimalgeomeanconedomain,
  appendprimalpowerconedomain,
  appendpsdconedomain,
  appendquadraticconedomain,
  appendrdomain,
  appendrminusdomain,
  appendrplusdomain,
  appendrquadraticconedomain,
  appendrzerodomain,
  appendsparsesymmat,
  appendsparsesymmatlist,
  appendvars,
  basiscond,
  bktostr,
  callbackcodetostr,
  checkinall,
  checkinlicense,
  checkmem,
  checkoutlicense,
  chgconbound,
  chgvarbound,
  commitchanges,
  conetypetostr,
  deletesolution,
  dualsensitivity,
  echointro,
  emptyafebarfrow,
  emptyafebarfrowlist,
  emptyafefcol,
  emptyafefcollist,
  emptyafefrow,
  emptyafefrowlist,
  evaluateacc,
  evaluateaccs,
  generateaccnames,
  generateconenames,
  generateconnames,
  generatevarnames,
  getaccafeidxlist,
  getaccb,
  getaccdomain,
  getaccdoty,
  getaccn,
  getaccname,
  getaccnamelen,
  getaccntot,
  getaccs,
  getacol,
  getacolnumnz,
  getacolslice,
  getacolslicenumnz,
  getacolslicetrip,
  getafebarfnumrowentries,
  getafebarfrow,
  getafebarfrowinfo,
  getafefnumnz,
  getafefrow,
  getafefrownumnz,
  getafeftrip,
  getafeg,
  getafegslice,
  getaij,
  getapiecenumnz,
  getarow,
  getarownumnz,
  getarowslice,
  getarowslicenumnz,
  getarowslicetrip,
  getatruncatetol,
  getbarablocktriplet,
  getbaraidx,
  getbaraidxij,
  getbaraidxinfo,
  getbarasparsity,
  getbarcblocktriplet,
  getbarcidx,
  getbarcidxinfo,
  getbarcidxj,
  getbarcsparsity,
  getbarsj,
  getbarsslice,
  getbarvarname,
  getbarvarnameindex,
  getbarvarnamelen,
  getbarxj,
  getbarxslice,
  getc,
  getcfix,
  getcj,
  getclist,
  getcodedesc,
  getconbound,
  getconboundslice,
  getcone,
  getconeinfo,
  getconename,
  getconenameindex,
  getconenamelen,
  getconname,
  getconnameindex,
  getconnamelen,
  getcslice,
  getdimbarvarj,
  getdjcafeidxlist,
  getdjcb,
  getdjcdomainidxlist,
  getdjcname,
  getdjcnamelen,
  getdjcnumafe,
  getdjcnumafetot,
  getdjcnumdomain,
  getdjcnumdomaintot,
  getdjcnumterm,
  getdjcnumtermtot,
  getdjcs,
  getdjctermsizelist,
  getdomainn,
  getdomainname,
  getdomainnamelen,
  getdomaintype,
  getdouinf,
  getdouparam,
  getdualobj,
  getdualsolutionnorms,
  getdviolacc,
  getdviolbarvar,
  getdviolcon,
  getdviolcones,
  getdviolvar,
  getinfeasiblesubproblem,
  getinfname,
  getintinf,
  getintparam,
  getlenbarvarj,
  getlintinf,
  getmaxnumanz,
  getmaxnumbarvar,
  getmaxnumcon,
  getmaxnumcone,
  getmaxnumqnz,
  getmaxnumvar,
  getmemusage,
  getnadouinf,
  getnadouparam,
  getnaintinf,
  getnaintparam,
  getnastrparam,
  getnumacc,
  getnumafe,
  getnumanz,
  getnumanz64,
  getnumbarablocktriplets,
  getnumbaranz,
  getnumbarcblocktriplets,
  getnumbarcnz,
  getnumbarvar,
  getnumcon,
  getnumcone,
  getnumconemem,
  getnumdjc,
  getnumdomain,
  getnumintvar,
  getnumparam,
  getnumqconknz,
  getnumqobjnz,
  getnumsymmat,
  getnumvar,
  getobjname,
  getobjnamelen,
  getobjsense,
  getparamname,
  getpowerdomainalpha,
  getpowerdomaininfo,
  getprimalobj,
  getprimalsolutionnorms,
  getprobtype,
  getprosta,
  getpviolacc,
  getpviolbarvar,
  getpviolcon,
  getpviolcones,
  getpvioldjc,
  getpviolvar,
  getqconk,
  getqobj,
  getqobjij,
  getreducedcosts,
  getskc,
  getskcslice,
  getskn,
  getskx,
  getskxslice,
  getslc,
  getslcslice,
  getslx,
  getslxslice,
  getsnx,
  getsnxslice,
  getsolsta,
  getsolution,
  getsolutioninfo,
  getsolutioninfonew,
  getsolutionnew,
  getsolutionslice,
  getsparsesymmat,
  getstrparam,
  getstrparamlen,
  getsuc,
  getsucslice,
  getsux,
  getsuxslice,
  getsymmatinfo,
  gettaskname,
  gettasknamelen,
  getvarbound,
  getvarboundslice,
  getvarname,
  getvarnameindex,
  getvarnamelen,
  getvartype,
  getvartypelist,
  getversion,
  getxc,
  getxcslice,
  getxx,
  getxxslice,
  gety,
  getyslice,
  initbasissolve,
  inputdata,
  isdouparname,
  isintparname,
  isstrparname,
  licensecleanup,
  linkfiletostream,
  onesolutionsummary,
  optimize,
  optimizermt,
  optimizersummary,
  primalrepair,
  primalsensitivity,
  printparam,
  putacc,
  putaccb,
  putaccbj,
  putaccdoty,
  putacclist,
  putaccname,
  putacol,
  putacollist,
  putacolslice,
  putafebarfblocktriplet,
  putafebarfentry,
  putafebarfentrylist,
  putafebarfrow,
  putafefentry,
  putafefentrylist,
  putafefrow,
  putafefrowlist,
  putafeg,
  putafeglist,
  putafegslice,
  putaij,
  putaijlist,
  putarow,
  putarowlist,
  putarowslice,
  putatruncatetol,
  putbarablocktriplet,
  putbaraij,
  putbaraijlist,
  putbararowlist,
  putbarcblocktriplet,
  putbarcj,
  putbarsj,
  putbarvarname,
  putbarxj,
  putcfix,
  putcj,
  putclist,
  putconbound,
  putconboundlist,
  putconboundlistconst,
  putconboundslice,
  putconboundsliceconst,
  putcone,
  putconename,
  putconname,
  putconsolutioni,
  putcslice,
  putdjc,
  putdjcname,
  putdjcslice,
  putdomainname,
  putdouparam,
  putintparam,
  putlicensecode,
  putlicensedebug,
  putlicensepath,
  putlicensewait,
  putmaxnumacc,
  putmaxnumafe,
  putmaxnumanz,
  putmaxnumbarvar,
  putmaxnumcon,
  putmaxnumcone,
  putmaxnumdjc,
  putmaxnumdomain,
  putmaxnumqnz,
  putmaxnumvar,
  putnadouparam,
  putnaintparam,
  putnastrparam,
  putobjname,
  putobjsense,
  putoptserverhost,
  putparam,
  putqcon,
  putqconk,
  putqobj,
  putqobjij,
  putskc,
  putskcslice,
  putskx,
  putskxslice,
  putslc,
  putslcslice,
  putslx,
  putslxslice,
  putsnx,
  putsnxslice,
  putsolution,
  putsolutionnew,
  putsolutionyi,
  putstrparam,
  putsuc,
  putsucslice,
  putsux,
  putsuxslice,
  puttaskname,
  putvarbound,
  putvarboundlist,
  putvarboundlistconst,
  putvarboundslice,
  putvarboundsliceconst,
  putvarname,
  putvarsolutionj,
  putvartype,
  putvartypelist,
  putxc,
  putxcslice,
  putxx,
  putxxslice,
  puty,
  putyslice,
  readdata,
  readdataformat,
  readjsonstring,
  readlpstring,
  readopfstring,
  readparamfile,
  readptfstring,
  readsolution,
  readsummary,
  readtask,
  removebarvars,
  removecones,
  removecons,
  removevars,
  resizetask,
  sensitivityreport,
  setdefaults,
  setupthreads,
  solutiondef,
  solutionsummary,
  solvewithbasis,
  strtoconetype,
  strtosk,
  updatesolutioninfo,
  writedata,
  writejsonsol,
  writeparamfile,
  writesolution,
  writetask

function tril(m::SparseArrays.SparseMatrixCSC{Float64})
  m  = 0.5*(m+m')
  nnz  = length(m.nzval)
  jj = zeros(Int64,nnz); for i in 1:m.n jj[m.colptr[i]:m.colptr[i+1]-1] .= i end
  subi = zeros(Int64,nnz)
  subj = zeros(Int64,nnz)
  val  = zeros(Float64,nnz)
  k = 0
  for i in 1:nnz
    if m.rowval[i] >= jj[i]
      k += 1
      subi[k] = m.rowval[i]
      subj[k] = jj[i]
      val[k]  = m.nzval[i]
    end
  end
  return subi[1:k],subj[1:k],val[1:k]
end
macro MSK_analyzenames(task,whichstream,nametype)
  f = Base.Meta.quot(:MSK_analyzenames)
  args = [esc(task),esc(whichstream),esc(nametype)]
  types = :((Ptr{Nothing},Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_analyzeproblem(task,whichstream)
  f = Base.Meta.quot(:MSK_analyzeproblem)
  args = [esc(task),esc(whichstream)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_analyzesolution(task,whichstream,whichsol)
  f = Base.Meta.quot(:MSK_analyzesolution)
  args = [esc(task),esc(whichstream),esc(whichsol)]
  types = :((Ptr{Nothing},Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendacc(task,domidx,numafeidx,afeidxlist,b)
  f = Base.Meta.quot(:MSK_appendacc)
  args = [esc(task),esc(domidx),esc(numafeidx),esc(afeidxlist),esc(b)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendaccs(task,numaccs,domidxs,numafeidx,afeidxlist,b)
  f = Base.Meta.quot(:MSK_appendaccs)
  args = [esc(task),esc(numaccs),esc(domidxs),esc(numafeidx),esc(afeidxlist),esc(b)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendaccseq(task,domidx,numafeidx,afeidxfirst,b)
  f = Base.Meta.quot(:MSK_appendaccseq)
  args = [esc(task),esc(domidx),esc(numafeidx),esc(afeidxfirst),esc(b)]
  types = :((Ptr{Nothing},Int64,Int64,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendaccsseq(task,numaccs,domidxs,numafeidx,afeidxfirst,b)
  f = Base.Meta.quot(:MSK_appendaccsseq)
  args = [esc(task),esc(numaccs),esc(domidxs),esc(numafeidx),esc(afeidxfirst),esc(b)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Int64,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendafes(task,num)
  f = Base.Meta.quot(:MSK_appendafes)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendbarvars(task,num,dim)
  f = Base.Meta.quot(:MSK_appendbarvars)
  args = [esc(task),esc(num),esc(dim)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendcone(task,ct,conepar,nummem,submem)
  f = Base.Meta.quot(:MSK_appendcone)
  args = [esc(task),esc(ct),esc(conepar),esc(nummem),esc(submem)]
  types = :((Ptr{Nothing},Int32,Float64,Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendconeseq(task,ct,conepar,nummem,j)
  f = Base.Meta.quot(:MSK_appendconeseq)
  args = [esc(task),esc(ct),esc(conepar),esc(nummem),esc(j)]
  types = :((Ptr{Nothing},Int32,Float64,Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendconesseq(task,num,ct,conepar,nummem,j)
  f = Base.Meta.quot(:MSK_appendconesseq)
  args = [esc(task),esc(num),esc(ct),esc(conepar),esc(nummem),esc(j)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Int32},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendcons(task,num)
  f = Base.Meta.quot(:MSK_appendcons)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appenddjcs(task,num)
  f = Base.Meta.quot(:MSK_appenddjcs)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appenddualexpconedomain(task,domidx)
  f = Base.Meta.quot(:MSK_appenddualexpconedomain)
  args = [esc(task),esc(domidx)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appenddualgeomeanconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appenddualgeomeanconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appenddualpowerconedomain(task,n,nleft,alpha,domidx)
  f = Base.Meta.quot(:MSK_appenddualpowerconedomain)
  args = [esc(task),esc(n),esc(nleft),esc(alpha),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Float64},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendinfnormconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendinfnormconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendonenormconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendonenormconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendprimalexpconedomain(task,domidx)
  f = Base.Meta.quot(:MSK_appendprimalexpconedomain)
  args = [esc(task),esc(domidx)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendprimalgeomeanconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendprimalgeomeanconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendprimalpowerconedomain(task,n,nleft,alpha,domidx)
  f = Base.Meta.quot(:MSK_appendprimalpowerconedomain)
  args = [esc(task),esc(n),esc(nleft),esc(alpha),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Float64},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendpsdconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendpsdconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendquadraticconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendquadraticconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendrdomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendrdomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendrminusdomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendrminusdomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendrplusdomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendrplusdomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendrquadraticconedomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendrquadraticconedomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendrzerodomain(task,n,domidx)
  f = Base.Meta.quot(:MSK_appendrzerodomain)
  args = [esc(task),esc(n),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendsparsesymmat(task,dim,nz,subi,subj,valij,idx)
  f = Base.Meta.quot(:MSK_appendsparsesymmat)
  args = [esc(task),esc(dim),esc(nz),esc(subi),esc(subj),esc(valij),esc(idx)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendsparsesymmatlist(task,num,dims,nz,subi,subj,valij,idx)
  f = Base.Meta.quot(:MSK_appendsparsesymmatlist)
  args = [esc(task),esc(num),esc(dims),esc(nz),esc(subi),esc(subj),esc(valij),esc(idx)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_appendvars(task,num)
  f = Base.Meta.quot(:MSK_appendvars)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_basiscond(task,nrmbasis,nrminvbasis)
  f = Base.Meta.quot(:MSK_basiscond)
  args = [esc(task),esc(nrmbasis),esc(nrminvbasis)]
  types = :((Ptr{Nothing},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_bktostr(task,bk,str)
  f = Base.Meta.quot(:MSK_bktostr)
  args = [esc(task),esc(bk),esc(str)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_callbackcodetostr(code,callbackcodestr)
  f = Base.Meta.quot(:MSK_callbackcodetostr)
  args = [esc(code),esc(callbackcodestr)]
  types = :((Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_checkinall(env)
  f = Base.Meta.quot(:MSK_checkinall)
  args = [esc(env)]
  types = :((Ptr{Nothing},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_checkinlicense(env,feature)
  f = Base.Meta.quot(:MSK_checkinlicense)
  args = [esc(env),esc(feature)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_checkmemtask(task,file,line)
  f = Base.Meta.quot(:MSK_checkmemtask)
  args = [esc(task),esc(file),esc(line)]
  types = :((Ptr{Nothing},Ptr{UInt8},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_checkoutlicense(env,feature)
  f = Base.Meta.quot(:MSK_checkoutlicense)
  args = [esc(env),esc(feature)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_chgconbound(task,i,lower,finite,value)
  f = Base.Meta.quot(:MSK_chgconbound)
  args = [esc(task),esc(i),esc(lower),esc(finite),esc(value)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_chgvarbound(task,j,lower,finite,value)
  f = Base.Meta.quot(:MSK_chgvarbound)
  args = [esc(task),esc(j),esc(lower),esc(finite),esc(value)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_commitchanges(task)
  f = Base.Meta.quot(:MSK_commitchanges)
  args = [esc(task)]
  types = :((Ptr{Nothing},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_conetypetostr(task,ct,str)
  f = Base.Meta.quot(:MSK_conetypetostr)
  args = [esc(task),esc(ct),esc(str)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_deletesolution(task,whichsol)
  f = Base.Meta.quot(:MSK_deletesolution)
  args = [esc(task),esc(whichsol)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_dualsensitivity(task,numj,subj,leftpricej,rightpricej,leftrangej,rightrangej)
  f = Base.Meta.quot(:MSK_dualsensitivity)
  args = [esc(task),esc(numj),esc(subj),esc(leftpricej),esc(rightpricej),esc(leftrangej),esc(rightrangej)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_echointro(env,longver)
  f = Base.Meta.quot(:MSK_echointro)
  args = [esc(env),esc(longver)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_emptyafebarfrow(task,afeidx)
  f = Base.Meta.quot(:MSK_emptyafebarfrow)
  args = [esc(task),esc(afeidx)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_emptyafebarfrowlist(task,numafeidx,afeidxlist)
  f = Base.Meta.quot(:MSK_emptyafebarfrowlist)
  args = [esc(task),esc(numafeidx),esc(afeidxlist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_emptyafefcol(task,j)
  f = Base.Meta.quot(:MSK_emptyafefcol)
  args = [esc(task),esc(j)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_emptyafefcollist(task,numvaridx,varidxlist)
  f = Base.Meta.quot(:MSK_emptyafefcollist)
  args = [esc(task),esc(numvaridx),esc(varidxlist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_emptyafefrow(task,afeidx)
  f = Base.Meta.quot(:MSK_emptyafefrow)
  args = [esc(task),esc(afeidx)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_emptyafefrowlist(task,numafeidx,afeidxlist)
  f = Base.Meta.quot(:MSK_emptyafefrowlist)
  args = [esc(task),esc(numafeidx),esc(afeidxlist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_evaluateacc(task,whichsol,accidx,activity)
  f = Base.Meta.quot(:MSK_evaluateacc)
  args = [esc(task),esc(whichsol),esc(accidx),esc(activity)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_evaluateaccs(task,whichsol,activity)
  f = Base.Meta.quot(:MSK_evaluateaccs)
  args = [esc(task),esc(whichsol),esc(activity)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_generateaccnames(task,num,sub,fmt,ndims,dims)
  f = Base.Meta.quot(:MSK_generateaccnames)
  args = [esc(task),esc(num),esc(sub),esc(fmt),esc(ndims),esc(dims)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{UInt8},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_generateconenames(task,num,subk,fmt,ndims,dims,sp)
  f = Base.Meta.quot(:MSK_generateconenames)
  args = [esc(task),esc(num),esc(subk),esc(fmt),esc(ndims),esc(dims),esc(sp)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{UInt8},Int32,Ptr{Int32},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_generateconnames(task,num,subi,fmt,ndims,dims,sp)
  f = Base.Meta.quot(:MSK_generateconnames)
  args = [esc(task),esc(num),esc(subi),esc(fmt),esc(ndims),esc(dims),esc(sp)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{UInt8},Int32,Ptr{Int32},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_generatevarnames(task,num,subj,fmt,ndims,dims,sp)
  f = Base.Meta.quot(:MSK_generatevarnames)
  args = [esc(task),esc(num),esc(subj),esc(fmt),esc(ndims),esc(dims),esc(sp)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{UInt8},Int32,Ptr{Int32},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccafeidxlist(task,accidx,afeidxlist)
  f = Base.Meta.quot(:MSK_getaccafeidxlist)
  args = [esc(task),esc(accidx),esc(afeidxlist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccb(task,accidx,b)
  f = Base.Meta.quot(:MSK_getaccb)
  args = [esc(task),esc(accidx),esc(b)]
  types = :((Ptr{Nothing},Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccdomain(task,accidx,domidx)
  f = Base.Meta.quot(:MSK_getaccdomain)
  args = [esc(task),esc(accidx),esc(domidx)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccdoty(task,whichsol,accidx,doty)
  f = Base.Meta.quot(:MSK_getaccdoty)
  args = [esc(task),esc(whichsol),esc(accidx),esc(doty)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccn(task,accidx,n)
  f = Base.Meta.quot(:MSK_getaccn)
  args = [esc(task),esc(accidx),esc(n)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccname(task,accidx,sizename,name)
  f = Base.Meta.quot(:MSK_getaccname)
  args = [esc(task),esc(accidx),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int64,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccnamelen(task,accidx,len)
  f = Base.Meta.quot(:MSK_getaccnamelen)
  args = [esc(task),esc(accidx),esc(len)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccntot(task,n)
  f = Base.Meta.quot(:MSK_getaccntot)
  args = [esc(task),esc(n)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaccs(task,domidxlist,afeidxlist,b)
  f = Base.Meta.quot(:MSK_getaccs)
  args = [esc(task),esc(domidxlist),esc(afeidxlist),esc(b)]
  types = :((Ptr{Nothing},Ptr{Int64},Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getacol(task,j,nzj,subj,valj)
  f = Base.Meta.quot(:MSK_getacol)
  args = [esc(task),esc(j),esc(nzj),esc(subj),esc(valj)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getacolnumnz(task,i,nzj)
  f = Base.Meta.quot(:MSK_getacolnumnz)
  args = [esc(task),esc(i),esc(nzj)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getacolslice64(task,first,last,maxnumnz,surp,ptrb,ptre,sub,val)
  f = Base.Meta.quot(:MSK_getacolslice64)
  args = [esc(task),esc(first),esc(last),esc(maxnumnz),esc(surp),esc(ptrb),esc(ptre),esc(sub),esc(val)]
  types = :((Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getacolslicenumnz64(task,first,last,numnz)
  f = Base.Meta.quot(:MSK_getacolslicenumnz64)
  args = [esc(task),esc(first),esc(last),esc(numnz)]
  types = :((Ptr{Nothing},Int32,Int32,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getacolslicetrip(task,first,last,maxnumnz,surp,subi,subj,val)
  f = Base.Meta.quot(:MSK_getacolslicetrip)
  args = [esc(task),esc(first),esc(last),esc(maxnumnz),esc(surp),esc(subi),esc(subj),esc(val)]
  types = :((Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafebarfnumrowentries(task,afeidx,numentries)
  f = Base.Meta.quot(:MSK_getafebarfnumrowentries)
  args = [esc(task),esc(afeidx),esc(numentries)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafebarfrow(task,afeidx,barvaridx,termptr,numterms,termidx,termweight)
  f = Base.Meta.quot(:MSK_getafebarfrow)
  args = [esc(task),esc(afeidx),esc(barvaridx),esc(termptr),esc(numterms),esc(termidx),esc(termweight)]
  types = :((Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafebarfrowinfo(task,afeidx,numentries,numterms)
  f = Base.Meta.quot(:MSK_getafebarfrowinfo)
  args = [esc(task),esc(afeidx),esc(numentries),esc(numterms)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafefnumnz(task,numfnz)
  f = Base.Meta.quot(:MSK_getafefnumnz)
  args = [esc(task),esc(numfnz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafefrow(task,afeidx,nzi,subi,vali)
  f = Base.Meta.quot(:MSK_getafefrow)
  args = [esc(task),esc(afeidx),esc(nzi),esc(subi),esc(vali)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafefrownumnz(task,afeidx,nzi)
  f = Base.Meta.quot(:MSK_getafefrownumnz)
  args = [esc(task),esc(afeidx),esc(nzi)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafeftrip(task,subi,subj,vali)
  f = Base.Meta.quot(:MSK_getafeftrip)
  args = [esc(task),esc(subi),esc(subj),esc(vali)]
  types = :((Ptr{Nothing},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafeg(task,afeidx,g)
  f = Base.Meta.quot(:MSK_getafeg)
  args = [esc(task),esc(afeidx),esc(g)]
  types = :((Ptr{Nothing},Int64,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getafegslice(task,first,last,g)
  f = Base.Meta.quot(:MSK_getafegslice)
  args = [esc(task),esc(first),esc(last),esc(g)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getaij(task,i,j,aij)
  f = Base.Meta.quot(:MSK_getaij)
  args = [esc(task),esc(i),esc(j),esc(aij)]
  types = :((Ptr{Nothing},Int32,Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getapiecenumnz(task,firsti,lasti,firstj,lastj,numnz)
  f = Base.Meta.quot(:MSK_getapiecenumnz)
  args = [esc(task),esc(firsti),esc(lasti),esc(firstj),esc(lastj),esc(numnz)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getarow(task,i,nzi,subi,vali)
  f = Base.Meta.quot(:MSK_getarow)
  args = [esc(task),esc(i),esc(nzi),esc(subi),esc(vali)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getarownumnz(task,i,nzi)
  f = Base.Meta.quot(:MSK_getarownumnz)
  args = [esc(task),esc(i),esc(nzi)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getarowslice64(task,first,last,maxnumnz,surp,ptrb,ptre,sub,val)
  f = Base.Meta.quot(:MSK_getarowslice64)
  args = [esc(task),esc(first),esc(last),esc(maxnumnz),esc(surp),esc(ptrb),esc(ptre),esc(sub),esc(val)]
  types = :((Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getarowslicenumnz64(task,first,last,numnz)
  f = Base.Meta.quot(:MSK_getarowslicenumnz64)
  args = [esc(task),esc(first),esc(last),esc(numnz)]
  types = :((Ptr{Nothing},Int32,Int32,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getarowslicetrip(task,first,last,maxnumnz,surp,subi,subj,val)
  f = Base.Meta.quot(:MSK_getarowslicetrip)
  args = [esc(task),esc(first),esc(last),esc(maxnumnz),esc(surp),esc(subi),esc(subj),esc(val)]
  types = :((Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getatruncatetol(task,tolzero)
  f = Base.Meta.quot(:MSK_getatruncatetol)
  args = [esc(task),esc(tolzero)]
  types = :((Ptr{Nothing},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarablocktriplet(task,maxnum,num,subi,subj,subk,subl,valijkl)
  f = Base.Meta.quot(:MSK_getbarablocktriplet)
  args = [esc(task),esc(maxnum),esc(num),esc(subi),esc(subj),esc(subk),esc(subl),esc(valijkl)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbaraidx(task,idx,maxnum,i,j,num,sub,weights)
  f = Base.Meta.quot(:MSK_getbaraidx)
  args = [esc(task),esc(idx),esc(maxnum),esc(i),esc(j),esc(num),esc(sub),esc(weights)]
  types = :((Ptr{Nothing},Int64,Int64,Ref{Int32},Ref{Int32},Ref{Int64},Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbaraidxij(task,idx,i,j)
  f = Base.Meta.quot(:MSK_getbaraidxij)
  args = [esc(task),esc(idx),esc(i),esc(j)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbaraidxinfo(task,idx,num)
  f = Base.Meta.quot(:MSK_getbaraidxinfo)
  args = [esc(task),esc(idx),esc(num)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarasparsity(task,maxnumnz,numnz,idxij)
  f = Base.Meta.quot(:MSK_getbarasparsity)
  args = [esc(task),esc(maxnumnz),esc(numnz),esc(idxij)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarcblocktriplet(task,maxnum,num,subj,subk,subl,valjkl)
  f = Base.Meta.quot(:MSK_getbarcblocktriplet)
  args = [esc(task),esc(maxnum),esc(num),esc(subj),esc(subk),esc(subl),esc(valjkl)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarcidx(task,idx,maxnum,j,num,sub,weights)
  f = Base.Meta.quot(:MSK_getbarcidx)
  args = [esc(task),esc(idx),esc(maxnum),esc(j),esc(num),esc(sub),esc(weights)]
  types = :((Ptr{Nothing},Int64,Int64,Ref{Int32},Ref{Int64},Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarcidxinfo(task,idx,num)
  f = Base.Meta.quot(:MSK_getbarcidxinfo)
  args = [esc(task),esc(idx),esc(num)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarcidxj(task,idx,j)
  f = Base.Meta.quot(:MSK_getbarcidxj)
  args = [esc(task),esc(idx),esc(j)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarcsparsity(task,maxnumnz,numnz,idxj)
  f = Base.Meta.quot(:MSK_getbarcsparsity)
  args = [esc(task),esc(maxnumnz),esc(numnz),esc(idxj)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarsj(task,whichsol,j,barsj)
  f = Base.Meta.quot(:MSK_getbarsj)
  args = [esc(task),esc(whichsol),esc(j),esc(barsj)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarsslice(task,whichsol,first,last,slicesize,barsslice)
  f = Base.Meta.quot(:MSK_getbarsslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(slicesize),esc(barsslice)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarvarname(task,i,sizename,name)
  f = Base.Meta.quot(:MSK_getbarvarname)
  args = [esc(task),esc(i),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarvarnameindex(task,somename,asgn,index)
  f = Base.Meta.quot(:MSK_getbarvarnameindex)
  args = [esc(task),esc(somename),esc(asgn),esc(index)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarvarnamelen(task,i,len)
  f = Base.Meta.quot(:MSK_getbarvarnamelen)
  args = [esc(task),esc(i),esc(len)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarxj(task,whichsol,j,barxj)
  f = Base.Meta.quot(:MSK_getbarxj)
  args = [esc(task),esc(whichsol),esc(j),esc(barxj)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getbarxslice(task,whichsol,first,last,slicesize,barxslice)
  f = Base.Meta.quot(:MSK_getbarxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(slicesize),esc(barxslice)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getc(task,c)
  f = Base.Meta.quot(:MSK_getc)
  args = [esc(task),esc(c)]
  types = :((Ptr{Nothing},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getcfix(task,cfix)
  f = Base.Meta.quot(:MSK_getcfix)
  args = [esc(task),esc(cfix)]
  types = :((Ptr{Nothing},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getcj(task,j,cj)
  f = Base.Meta.quot(:MSK_getcj)
  args = [esc(task),esc(j),esc(cj)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getclist(task,num,subj,c)
  f = Base.Meta.quot(:MSK_getclist)
  args = [esc(task),esc(num),esc(subj),esc(c)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getcodedesc(code,symname,str)
  f = Base.Meta.quot(:MSK_getcodedesc)
  args = [esc(code),esc(symname),esc(str)]
  types = :((Int32,Ptr{UInt8},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconbound(task,i,bk,bl,bu)
  f = Base.Meta.quot(:MSK_getconbound)
  args = [esc(task),esc(i),esc(bk),esc(bl),esc(bu)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconboundslice(task,first,last,bk,bl,bu)
  f = Base.Meta.quot(:MSK_getconboundslice)
  args = [esc(task),esc(first),esc(last),esc(bk),esc(bl),esc(bu)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getcone(task,k,ct,conepar,nummem,submem)
  f = Base.Meta.quot(:MSK_getcone)
  args = [esc(task),esc(k),esc(ct),esc(conepar),esc(nummem),esc(submem)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Int32},Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconeinfo(task,k,ct,conepar,nummem)
  f = Base.Meta.quot(:MSK_getconeinfo)
  args = [esc(task),esc(k),esc(ct),esc(conepar),esc(nummem)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconename(task,i,sizename,name)
  f = Base.Meta.quot(:MSK_getconename)
  args = [esc(task),esc(i),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconenameindex(task,somename,asgn,index)
  f = Base.Meta.quot(:MSK_getconenameindex)
  args = [esc(task),esc(somename),esc(asgn),esc(index)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconenamelen(task,i,len)
  f = Base.Meta.quot(:MSK_getconenamelen)
  args = [esc(task),esc(i),esc(len)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconname(task,i,sizename,name)
  f = Base.Meta.quot(:MSK_getconname)
  args = [esc(task),esc(i),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconnameindex(task,somename,asgn,index)
  f = Base.Meta.quot(:MSK_getconnameindex)
  args = [esc(task),esc(somename),esc(asgn),esc(index)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getconnamelen(task,i,len)
  f = Base.Meta.quot(:MSK_getconnamelen)
  args = [esc(task),esc(i),esc(len)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getcslice(task,first,last,c)
  f = Base.Meta.quot(:MSK_getcslice)
  args = [esc(task),esc(first),esc(last),esc(c)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdimbarvarj(task,j,dimbarvarj)
  f = Base.Meta.quot(:MSK_getdimbarvarj)
  args = [esc(task),esc(j),esc(dimbarvarj)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcafeidxlist(task,djcidx,afeidxlist)
  f = Base.Meta.quot(:MSK_getdjcafeidxlist)
  args = [esc(task),esc(djcidx),esc(afeidxlist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcb(task,djcidx,b)
  f = Base.Meta.quot(:MSK_getdjcb)
  args = [esc(task),esc(djcidx),esc(b)]
  types = :((Ptr{Nothing},Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcdomainidxlist(task,djcidx,domidxlist)
  f = Base.Meta.quot(:MSK_getdjcdomainidxlist)
  args = [esc(task),esc(djcidx),esc(domidxlist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcname(task,djcidx,sizename,name)
  f = Base.Meta.quot(:MSK_getdjcname)
  args = [esc(task),esc(djcidx),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int64,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnamelen(task,djcidx,len)
  f = Base.Meta.quot(:MSK_getdjcnamelen)
  args = [esc(task),esc(djcidx),esc(len)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnumafe(task,idjc,numafe)
  f = Base.Meta.quot(:MSK_getdjcnumafe)
  args = [esc(task),esc(idjc),esc(numafe)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnumafetot(task,numafetot)
  f = Base.Meta.quot(:MSK_getdjcnumafetot)
  args = [esc(task),esc(numafetot)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnumdomain(task,idjc,numdomain)
  f = Base.Meta.quot(:MSK_getdjcnumdomain)
  args = [esc(task),esc(idjc),esc(numdomain)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnumdomaintot(task,numdomaintot)
  f = Base.Meta.quot(:MSK_getdjcnumdomaintot)
  args = [esc(task),esc(numdomaintot)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnumterm(task,idjc,numterm)
  f = Base.Meta.quot(:MSK_getdjcnumterm)
  args = [esc(task),esc(idjc),esc(numterm)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcnumtermtot(task,numtermtot)
  f = Base.Meta.quot(:MSK_getdjcnumtermtot)
  args = [esc(task),esc(numtermtot)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjcs(task,domidxlist,afeidxlist,b,termsizelist,numterms)
  f = Base.Meta.quot(:MSK_getdjcs)
  args = [esc(task),esc(domidxlist),esc(afeidxlist),esc(b),esc(termsizelist),esc(numterms)]
  types = :((Ptr{Nothing},Ptr{Int64},Ptr{Int64},Ptr{Float64},Ptr{Int64},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdjctermsizelist(task,djcidx,termsizelist)
  f = Base.Meta.quot(:MSK_getdjctermsizelist)
  args = [esc(task),esc(djcidx),esc(termsizelist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdomainn(task,domidx,n)
  f = Base.Meta.quot(:MSK_getdomainn)
  args = [esc(task),esc(domidx),esc(n)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdomainname(task,domidx,sizename,name)
  f = Base.Meta.quot(:MSK_getdomainname)
  args = [esc(task),esc(domidx),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int64,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdomainnamelen(task,domidx,len)
  f = Base.Meta.quot(:MSK_getdomainnamelen)
  args = [esc(task),esc(domidx),esc(len)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdomaintype(task,domidx,domaintype)
  f = Base.Meta.quot(:MSK_getdomaintype)
  args = [esc(task),esc(domidx),esc(domaintype)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdouinf(task,whichdinf,dvalue)
  f = Base.Meta.quot(:MSK_getdouinf)
  args = [esc(task),esc(whichdinf),esc(dvalue)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdouparam(task,param,parvalue)
  f = Base.Meta.quot(:MSK_getdouparam)
  args = [esc(task),esc(param),esc(parvalue)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdualobj(task,whichsol,dualobj)
  f = Base.Meta.quot(:MSK_getdualobj)
  args = [esc(task),esc(whichsol),esc(dualobj)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdualsolutionnorms(task,whichsol,nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars)
  f = Base.Meta.quot(:MSK_getdualsolutionnorms)
  args = [esc(task),esc(whichsol),esc(nrmy),esc(nrmslc),esc(nrmsuc),esc(nrmslx),esc(nrmsux),esc(nrmsnx),esc(nrmbars)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdviolacc(task,whichsol,numaccidx,accidxlist,viol)
  f = Base.Meta.quot(:MSK_getdviolacc)
  args = [esc(task),esc(whichsol),esc(numaccidx),esc(accidxlist),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdviolbarvar(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getdviolbarvar)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdviolcon(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getdviolcon)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdviolcones(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getdviolcones)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getdviolvar(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getdviolvar)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getinfeasiblesubproblem(task,whichsol,inftask)
  f = Base.Meta.quot(:MSK_getinfeasiblesubproblem)
  args = [esc(task),esc(whichsol),esc(inftask)]
  types = :((Ptr{Nothing},Int32,Ref{Ptr{Nothing}},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getinfname(task,inftype,whichinf,infname)
  f = Base.Meta.quot(:MSK_getinfname)
  args = [esc(task),esc(inftype),esc(whichinf),esc(infname)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getintinf(task,whichiinf,ivalue)
  f = Base.Meta.quot(:MSK_getintinf)
  args = [esc(task),esc(whichiinf),esc(ivalue)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getintparam(task,param,parvalue)
  f = Base.Meta.quot(:MSK_getintparam)
  args = [esc(task),esc(param),esc(parvalue)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getlenbarvarj(task,j,lenbarvarj)
  f = Base.Meta.quot(:MSK_getlenbarvarj)
  args = [esc(task),esc(j),esc(lenbarvarj)]
  types = :((Ptr{Nothing},Int32,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getlintinf(task,whichliinf,ivalue)
  f = Base.Meta.quot(:MSK_getlintinf)
  args = [esc(task),esc(whichliinf),esc(ivalue)]
  types = :((Ptr{Nothing},Int32,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmaxnumanz64(task,maxnumanz)
  f = Base.Meta.quot(:MSK_getmaxnumanz64)
  args = [esc(task),esc(maxnumanz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmaxnumbarvar(task,maxnumbarvar)
  f = Base.Meta.quot(:MSK_getmaxnumbarvar)
  args = [esc(task),esc(maxnumbarvar)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmaxnumcon(task,maxnumcon)
  f = Base.Meta.quot(:MSK_getmaxnumcon)
  args = [esc(task),esc(maxnumcon)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmaxnumcone(task,maxnumcone)
  f = Base.Meta.quot(:MSK_getmaxnumcone)
  args = [esc(task),esc(maxnumcone)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmaxnumqnz64(task,maxnumqnz)
  f = Base.Meta.quot(:MSK_getmaxnumqnz64)
  args = [esc(task),esc(maxnumqnz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmaxnumvar(task,maxnumvar)
  f = Base.Meta.quot(:MSK_getmaxnumvar)
  args = [esc(task),esc(maxnumvar)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getmemusagetask(task,meminuse,maxmemuse)
  f = Base.Meta.quot(:MSK_getmemusagetask)
  args = [esc(task),esc(meminuse),esc(maxmemuse)]
  types = :((Ptr{Nothing},Ref{Int64},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnadouinf(task,infitemname,dvalue)
  f = Base.Meta.quot(:MSK_getnadouinf)
  args = [esc(task),esc(infitemname),esc(dvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnadouparam(task,paramname,parvalue)
  f = Base.Meta.quot(:MSK_getnadouparam)
  args = [esc(task),esc(paramname),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnaintinf(task,infitemname,ivalue)
  f = Base.Meta.quot(:MSK_getnaintinf)
  args = [esc(task),esc(infitemname),esc(ivalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnaintparam(task,paramname,parvalue)
  f = Base.Meta.quot(:MSK_getnaintparam)
  args = [esc(task),esc(paramname),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnastrparam(task,paramname,sizeparamname,len,parvalue)
  f = Base.Meta.quot(:MSK_getnastrparam)
  args = [esc(task),esc(paramname),esc(sizeparamname),esc(len),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Int32,Ref{Int32},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumacc(task,num)
  f = Base.Meta.quot(:MSK_getnumacc)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumafe(task,numafe)
  f = Base.Meta.quot(:MSK_getnumafe)
  args = [esc(task),esc(numafe)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumanz(task,numanz)
  f = Base.Meta.quot(:MSK_getnumanz)
  args = [esc(task),esc(numanz)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumanz64(task,numanz)
  f = Base.Meta.quot(:MSK_getnumanz64)
  args = [esc(task),esc(numanz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumbarablocktriplets(task,num)
  f = Base.Meta.quot(:MSK_getnumbarablocktriplets)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumbaranz(task,nz)
  f = Base.Meta.quot(:MSK_getnumbaranz)
  args = [esc(task),esc(nz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumbarcblocktriplets(task,num)
  f = Base.Meta.quot(:MSK_getnumbarcblocktriplets)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumbarcnz(task,nz)
  f = Base.Meta.quot(:MSK_getnumbarcnz)
  args = [esc(task),esc(nz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumbarvar(task,numbarvar)
  f = Base.Meta.quot(:MSK_getnumbarvar)
  args = [esc(task),esc(numbarvar)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumcon(task,numcon)
  f = Base.Meta.quot(:MSK_getnumcon)
  args = [esc(task),esc(numcon)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumcone(task,numcone)
  f = Base.Meta.quot(:MSK_getnumcone)
  args = [esc(task),esc(numcone)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumconemem(task,k,nummem)
  f = Base.Meta.quot(:MSK_getnumconemem)
  args = [esc(task),esc(k),esc(nummem)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumdjc(task,num)
  f = Base.Meta.quot(:MSK_getnumdjc)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumdomain(task,numdomain)
  f = Base.Meta.quot(:MSK_getnumdomain)
  args = [esc(task),esc(numdomain)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumintvar(task,numintvar)
  f = Base.Meta.quot(:MSK_getnumintvar)
  args = [esc(task),esc(numintvar)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumparam(task,partype,numparam)
  f = Base.Meta.quot(:MSK_getnumparam)
  args = [esc(task),esc(partype),esc(numparam)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumqconknz64(task,k,numqcnz)
  f = Base.Meta.quot(:MSK_getnumqconknz64)
  args = [esc(task),esc(k),esc(numqcnz)]
  types = :((Ptr{Nothing},Int32,Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumqobjnz64(task,numqonz)
  f = Base.Meta.quot(:MSK_getnumqobjnz64)
  args = [esc(task),esc(numqonz)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumsymmat(task,num)
  f = Base.Meta.quot(:MSK_getnumsymmat)
  args = [esc(task),esc(num)]
  types = :((Ptr{Nothing},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getnumvar(task,numvar)
  f = Base.Meta.quot(:MSK_getnumvar)
  args = [esc(task),esc(numvar)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getobjname(task,sizeobjname,objname)
  f = Base.Meta.quot(:MSK_getobjname)
  args = [esc(task),esc(sizeobjname),esc(objname)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getobjnamelen(task,len)
  f = Base.Meta.quot(:MSK_getobjnamelen)
  args = [esc(task),esc(len)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getobjsense(task,sense)
  f = Base.Meta.quot(:MSK_getobjsense)
  args = [esc(task),esc(sense)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getparamname(task,partype,param,parname)
  f = Base.Meta.quot(:MSK_getparamname)
  args = [esc(task),esc(partype),esc(param),esc(parname)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpowerdomainalpha(task,domidx,alpha)
  f = Base.Meta.quot(:MSK_getpowerdomainalpha)
  args = [esc(task),esc(domidx),esc(alpha)]
  types = :((Ptr{Nothing},Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpowerdomaininfo(task,domidx,n,nleft)
  f = Base.Meta.quot(:MSK_getpowerdomaininfo)
  args = [esc(task),esc(domidx),esc(n),esc(nleft)]
  types = :((Ptr{Nothing},Int64,Ref{Int64},Ref{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getprimalobj(task,whichsol,primalobj)
  f = Base.Meta.quot(:MSK_getprimalobj)
  args = [esc(task),esc(whichsol),esc(primalobj)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getprimalsolutionnorms(task,whichsol,nrmxc,nrmxx,nrmbarx)
  f = Base.Meta.quot(:MSK_getprimalsolutionnorms)
  args = [esc(task),esc(whichsol),esc(nrmxc),esc(nrmxx),esc(nrmbarx)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getprobtype(task,probtype)
  f = Base.Meta.quot(:MSK_getprobtype)
  args = [esc(task),esc(probtype)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getprosta(task,whichsol,prosta)
  f = Base.Meta.quot(:MSK_getprosta)
  args = [esc(task),esc(whichsol),esc(prosta)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpviolacc(task,whichsol,numaccidx,accidxlist,viol)
  f = Base.Meta.quot(:MSK_getpviolacc)
  args = [esc(task),esc(whichsol),esc(numaccidx),esc(accidxlist),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpviolbarvar(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getpviolbarvar)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpviolcon(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getpviolcon)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpviolcones(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getpviolcones)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpvioldjc(task,whichsol,numdjcidx,djcidxlist,viol)
  f = Base.Meta.quot(:MSK_getpvioldjc)
  args = [esc(task),esc(whichsol),esc(numdjcidx),esc(djcidxlist),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getpviolvar(task,whichsol,num,sub,viol)
  f = Base.Meta.quot(:MSK_getpviolvar)
  args = [esc(task),esc(whichsol),esc(num),esc(sub),esc(viol)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getqconk64(task,k,maxnumqcnz,qcsurp,numqcnz,qcsubi,qcsubj,qcval)
  f = Base.Meta.quot(:MSK_getqconk64)
  args = [esc(task),esc(k),esc(maxnumqcnz),esc(qcsurp),esc(numqcnz),esc(qcsubi),esc(qcsubj),esc(qcval)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Int64},Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getqobj64(task,maxnumqonz,qosurp,numqonz,qosubi,qosubj,qoval)
  f = Base.Meta.quot(:MSK_getqobj64)
  args = [esc(task),esc(maxnumqonz),esc(qosurp),esc(numqonz),esc(qosubi),esc(qosubj),esc(qoval)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ref{Int64},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getqobjij(task,i,j,qoij)
  f = Base.Meta.quot(:MSK_getqobjij)
  args = [esc(task),esc(i),esc(j),esc(qoij)]
  types = :((Ptr{Nothing},Int32,Int32,Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getreducedcosts(task,whichsol,first,last,redcosts)
  f = Base.Meta.quot(:MSK_getreducedcosts)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(redcosts)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getskc(task,whichsol,skc)
  f = Base.Meta.quot(:MSK_getskc)
  args = [esc(task),esc(whichsol),esc(skc)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getskcslice(task,whichsol,first,last,skc)
  f = Base.Meta.quot(:MSK_getskcslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(skc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getskn(task,whichsol,skn)
  f = Base.Meta.quot(:MSK_getskn)
  args = [esc(task),esc(whichsol),esc(skn)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getskx(task,whichsol,skx)
  f = Base.Meta.quot(:MSK_getskx)
  args = [esc(task),esc(whichsol),esc(skx)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getskxslice(task,whichsol,first,last,skx)
  f = Base.Meta.quot(:MSK_getskxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(skx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getslc(task,whichsol,slc)
  f = Base.Meta.quot(:MSK_getslc)
  args = [esc(task),esc(whichsol),esc(slc)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getslcslice(task,whichsol,first,last,slc)
  f = Base.Meta.quot(:MSK_getslcslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(slc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getslx(task,whichsol,slx)
  f = Base.Meta.quot(:MSK_getslx)
  args = [esc(task),esc(whichsol),esc(slx)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getslxslice(task,whichsol,first,last,slx)
  f = Base.Meta.quot(:MSK_getslxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(slx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsnx(task,whichsol,snx)
  f = Base.Meta.quot(:MSK_getsnx)
  args = [esc(task),esc(whichsol),esc(snx)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsnxslice(task,whichsol,first,last,snx)
  f = Base.Meta.quot(:MSK_getsnxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(snx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsolsta(task,whichsol,solsta)
  f = Base.Meta.quot(:MSK_getsolsta)
  args = [esc(task),esc(whichsol),esc(solsta)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsolution(task,whichsol,prosta,solsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)
  f = Base.Meta.quot(:MSK_getsolution)
  args = [esc(task),esc(whichsol),esc(prosta),esc(solsta),esc(skc),esc(skx),esc(skn),esc(xc),esc(xx),esc(y),esc(slc),esc(suc),esc(slx),esc(sux),esc(snx)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsolutioninfo(task,whichsol,pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone)
  f = Base.Meta.quot(:MSK_getsolutioninfo)
  args = [esc(task),esc(whichsol),esc(pobj),esc(pviolcon),esc(pviolvar),esc(pviolbarvar),esc(pviolcone),esc(pviolitg),esc(dobj),esc(dviolcon),esc(dviolvar),esc(dviolbarvar),esc(dviolcone)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsolutioninfonew(task,whichsol,pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolacc,pvioldjc,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone,dviolacc)
  f = Base.Meta.quot(:MSK_getsolutioninfonew)
  args = [esc(task),esc(whichsol),esc(pobj),esc(pviolcon),esc(pviolvar),esc(pviolbarvar),esc(pviolcone),esc(pviolacc),esc(pvioldjc),esc(pviolitg),esc(dobj),esc(dviolcon),esc(dviolvar),esc(dviolbarvar),esc(dviolcone),esc(dviolacc)]
  types = :((Ptr{Nothing},Int32,Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsolutionnew(task,whichsol,prosta,solsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)
  f = Base.Meta.quot(:MSK_getsolutionnew)
  args = [esc(task),esc(whichsol),esc(prosta),esc(solsta),esc(skc),esc(skx),esc(skn),esc(xc),esc(xx),esc(y),esc(slc),esc(suc),esc(slx),esc(sux),esc(snx),esc(doty)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ref{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsolutionslice(task,whichsol,solitem,first,last,values)
  f = Base.Meta.quot(:MSK_getsolutionslice)
  args = [esc(task),esc(whichsol),esc(solitem),esc(first),esc(last),esc(values)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsparsesymmat(task,idx,maxlen,subi,subj,valij)
  f = Base.Meta.quot(:MSK_getsparsesymmat)
  args = [esc(task),esc(idx),esc(maxlen),esc(subi),esc(subj),esc(valij)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getstrparam(task,param,maxlen,len,parvalue)
  f = Base.Meta.quot(:MSK_getstrparam)
  args = [esc(task),esc(param),esc(maxlen),esc(len),esc(parvalue)]
  types = :((Ptr{Nothing},Int32,Int32,Ref{Int32},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getstrparamlen(task,param,len)
  f = Base.Meta.quot(:MSK_getstrparamlen)
  args = [esc(task),esc(param),esc(len)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsuc(task,whichsol,suc)
  f = Base.Meta.quot(:MSK_getsuc)
  args = [esc(task),esc(whichsol),esc(suc)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsucslice(task,whichsol,first,last,suc)
  f = Base.Meta.quot(:MSK_getsucslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(suc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsux(task,whichsol,sux)
  f = Base.Meta.quot(:MSK_getsux)
  args = [esc(task),esc(whichsol),esc(sux)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsuxslice(task,whichsol,first,last,sux)
  f = Base.Meta.quot(:MSK_getsuxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(sux)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getsymmatinfo(task,idx,dim,nz,type)
  f = Base.Meta.quot(:MSK_getsymmatinfo)
  args = [esc(task),esc(idx),esc(dim),esc(nz),esc(type)]
  types = :((Ptr{Nothing},Int64,Ref{Int32},Ref{Int64},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_gettaskname(task,sizetaskname,taskname)
  f = Base.Meta.quot(:MSK_gettaskname)
  args = [esc(task),esc(sizetaskname),esc(taskname)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_gettasknamelen(task,len)
  f = Base.Meta.quot(:MSK_gettasknamelen)
  args = [esc(task),esc(len)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvarbound(task,i,bk,bl,bu)
  f = Base.Meta.quot(:MSK_getvarbound)
  args = [esc(task),esc(i),esc(bk),esc(bl),esc(bu)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ref{Float64},Ref{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvarboundslice(task,first,last,bk,bl,bu)
  f = Base.Meta.quot(:MSK_getvarboundslice)
  args = [esc(task),esc(first),esc(last),esc(bk),esc(bl),esc(bu)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvarname(task,j,sizename,name)
  f = Base.Meta.quot(:MSK_getvarname)
  args = [esc(task),esc(j),esc(sizename),esc(name)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvarnameindex(task,somename,asgn,index)
  f = Base.Meta.quot(:MSK_getvarnameindex)
  args = [esc(task),esc(somename),esc(asgn),esc(index)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvarnamelen(task,i,len)
  f = Base.Meta.quot(:MSK_getvarnamelen)
  args = [esc(task),esc(i),esc(len)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvartype(task,j,vartype)
  f = Base.Meta.quot(:MSK_getvartype)
  args = [esc(task),esc(j),esc(vartype)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getvartypelist(task,num,subj,vartype)
  f = Base.Meta.quot(:MSK_getvartypelist)
  args = [esc(task),esc(num),esc(subj),esc(vartype)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getversion(major,minor,revision)
  f = Base.Meta.quot(:MSK_getversion)
  args = [esc(major),esc(minor),esc(revision)]
  types = :((Ref{Int32},Ref{Int32},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getxc(task,whichsol,xc)
  f = Base.Meta.quot(:MSK_getxc)
  args = [esc(task),esc(whichsol),esc(xc)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getxcslice(task,whichsol,first,last,xc)
  f = Base.Meta.quot(:MSK_getxcslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(xc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getxx(task,whichsol,xx)
  f = Base.Meta.quot(:MSK_getxx)
  args = [esc(task),esc(whichsol),esc(xx)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getxxslice(task,whichsol,first,last,xx)
  f = Base.Meta.quot(:MSK_getxxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(xx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_gety(task,whichsol,y)
  f = Base.Meta.quot(:MSK_gety)
  args = [esc(task),esc(whichsol),esc(y)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_getyslice(task,whichsol,first,last,y)
  f = Base.Meta.quot(:MSK_getyslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(y)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_initbasissolve(task,basis)
  f = Base.Meta.quot(:MSK_initbasissolve)
  args = [esc(task),esc(basis)]
  types = :((Ptr{Nothing},Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_inputdata64(task,maxnumcon,maxnumvar,numcon,numvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
  f = Base.Meta.quot(:MSK_inputdata64)
  args = [esc(task),esc(maxnumcon),esc(maxnumvar),esc(numcon),esc(numvar),esc(c),esc(cfix),esc(aptrb),esc(aptre),esc(asub),esc(aval),esc(bkc),esc(blc),esc(buc),esc(bkx),esc(blx),esc(bux)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Int32,Ptr{Float64},Float64,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_isdouparname(task,parname,param)
  f = Base.Meta.quot(:MSK_isdouparname)
  args = [esc(task),esc(parname),esc(param)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_isintparname(task,parname,param)
  f = Base.Meta.quot(:MSK_isintparname)
  args = [esc(task),esc(parname),esc(param)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_isstrparname(task,parname,param)
  f = Base.Meta.quot(:MSK_isstrparname)
  args = [esc(task),esc(parname),esc(param)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_licensecleanup()
 :(@msk_ccall "licensecleanup" Int32 ())
end
macro MSK_linkfiletoenvstream(env,whichstream,filename,append)
  f = Base.Meta.quot(:MSK_linkfiletoenvstream)
  args = [esc(env),esc(whichstream),esc(filename),esc(append)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_linkfiletotaskstream(task,whichstream,filename,append)
  f = Base.Meta.quot(:MSK_linkfiletotaskstream)
  args = [esc(task),esc(whichstream),esc(filename),esc(append)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_onesolutionsummary(task,whichstream,whichsol)
  f = Base.Meta.quot(:MSK_onesolutionsummary)
  args = [esc(task),esc(whichstream),esc(whichsol)]
  types = :((Ptr{Nothing},Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_optimizermt(task,addr,accesstoken,trmcode)
  f = Base.Meta.quot(:MSK_optimizermt)
  args = [esc(task),esc(addr),esc(accesstoken),esc(trmcode)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_optimizersummary(task,whichstream)
  f = Base.Meta.quot(:MSK_optimizersummary)
  args = [esc(task),esc(whichstream)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_optimizetrm(task,trmcode)
  f = Base.Meta.quot(:MSK_optimizetrm)
  args = [esc(task),esc(trmcode)]
  types = :((Ptr{Nothing},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_primalrepair(task,wlc,wuc,wlx,wux)
  f = Base.Meta.quot(:MSK_primalrepair)
  args = [esc(task),esc(wlc),esc(wuc),esc(wlx),esc(wux)]
  types = :((Ptr{Nothing},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_primalsensitivity(task,numi,subi,marki,numj,subj,markj,leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej)
  f = Base.Meta.quot(:MSK_primalsensitivity)
  args = [esc(task),esc(numi),esc(subi),esc(marki),esc(numj),esc(subj),esc(markj),esc(leftpricei),esc(rightpricei),esc(leftrangei),esc(rightrangei),esc(leftpricej),esc(rightpricej),esc(leftrangej),esc(rightrangej)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_printparam(task)
  f = Base.Meta.quot(:MSK_printparam)
  args = [esc(task)]
  types = :((Ptr{Nothing},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putacc(task,accidx,domidx,numafeidx,afeidxlist,b)
  f = Base.Meta.quot(:MSK_putacc)
  args = [esc(task),esc(accidx),esc(domidx),esc(numafeidx),esc(afeidxlist),esc(b)]
  types = :((Ptr{Nothing},Int64,Int64,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putaccb(task,accidx,lengthb,b)
  f = Base.Meta.quot(:MSK_putaccb)
  args = [esc(task),esc(accidx),esc(lengthb),esc(b)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putaccbj(task,accidx,j,bj)
  f = Base.Meta.quot(:MSK_putaccbj)
  args = [esc(task),esc(accidx),esc(j),esc(bj)]
  types = :((Ptr{Nothing},Int64,Int64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putaccdoty(task,whichsol,accidx,doty)
  f = Base.Meta.quot(:MSK_putaccdoty)
  args = [esc(task),esc(whichsol),esc(accidx),esc(doty)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putacclist(task,numaccs,accidxs,domidxs,numafeidx,afeidxlist,b)
  f = Base.Meta.quot(:MSK_putacclist)
  args = [esc(task),esc(numaccs),esc(accidxs),esc(domidxs),esc(numafeidx),esc(afeidxlist),esc(b)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putaccname(task,accidx,name)
  f = Base.Meta.quot(:MSK_putaccname)
  args = [esc(task),esc(accidx),esc(name)]
  types = :((Ptr{Nothing},Int64,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putacol(task,j,nzj,subj,valj)
  f = Base.Meta.quot(:MSK_putacol)
  args = [esc(task),esc(j),esc(nzj),esc(subj),esc(valj)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putacollist64(task,num,sub,ptrb,ptre,asub,aval)
  f = Base.Meta.quot(:MSK_putacollist64)
  args = [esc(task),esc(num),esc(sub),esc(ptrb),esc(ptre),esc(asub),esc(aval)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putacolslice64(task,first,last,ptrb,ptre,asub,aval)
  f = Base.Meta.quot(:MSK_putacolslice64)
  args = [esc(task),esc(first),esc(last),esc(ptrb),esc(ptre),esc(asub),esc(aval)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafebarfblocktriplet(task,num,afeidx,barvaridx,subk,subl,valkl)
  f = Base.Meta.quot(:MSK_putafebarfblocktriplet)
  args = [esc(task),esc(num),esc(afeidx),esc(barvaridx),esc(subk),esc(subl),esc(valkl)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafebarfentry(task,afeidx,barvaridx,numterms,termidx,termweight)
  f = Base.Meta.quot(:MSK_putafebarfentry)
  args = [esc(task),esc(afeidx),esc(barvaridx),esc(numterms),esc(termidx),esc(termweight)]
  types = :((Ptr{Nothing},Int64,Int32,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafebarfentrylist(task,lenlist,afeidxlist,barvaridxlist,numtermslist,ptrtermslist,lenterms,termidx,termweight)
  f = Base.Meta.quot(:MSK_putafebarfentrylist)
  args = [esc(task),esc(lenlist),esc(afeidxlist),esc(barvaridxlist),esc(numtermslist),esc(ptrtermslist),esc(lenterms),esc(termidx),esc(termweight)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafebarfrow(task,afeidx,numentries,barvaridxlist,numtermlist,ptrtermlist,lenterms,termidx,termweight)
  f = Base.Meta.quot(:MSK_putafebarfrow)
  args = [esc(task),esc(afeidx),esc(numentries),esc(barvaridxlist),esc(numtermlist),esc(ptrtermlist),esc(lenterms),esc(termidx),esc(termweight)]
  types = :((Ptr{Nothing},Int64,Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafefentry(task,afeidx,j,value)
  f = Base.Meta.quot(:MSK_putafefentry)
  args = [esc(task),esc(afeidx),esc(j),esc(value)]
  types = :((Ptr{Nothing},Int64,Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafefentrylist(task,numentries,afeidx,j,value)
  f = Base.Meta.quot(:MSK_putafefentrylist)
  args = [esc(task),esc(numentries),esc(afeidx),esc(j),esc(value)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafefrow(task,afeidx,nzi,subi,vali)
  f = Base.Meta.quot(:MSK_putafefrow)
  args = [esc(task),esc(afeidx),esc(nzi),esc(subi),esc(vali)]
  types = :((Ptr{Nothing},Int64,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafefrowlist(task,numafeidx,afeidxlist,nzrow,ptrrow,lenidxval,idxrow,valrow)
  f = Base.Meta.quot(:MSK_putafefrowlist)
  args = [esc(task),esc(numafeidx),esc(afeidxlist),esc(nzrow),esc(ptrrow),esc(lenidxval),esc(idxrow),esc(valrow)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{Int32},Ptr{Int64},Int64,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafeg(task,afeidx,gi)
  f = Base.Meta.quot(:MSK_putafeg)
  args = [esc(task),esc(afeidx),esc(gi)]
  types = :((Ptr{Nothing},Int64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafeglist(task,numafeidx,afeidxlist,glist)
  f = Base.Meta.quot(:MSK_putafeglist)
  args = [esc(task),esc(numafeidx),esc(afeidxlist),esc(glist)]
  types = :((Ptr{Nothing},Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putafegslice(task,first,last,slice)
  f = Base.Meta.quot(:MSK_putafegslice)
  args = [esc(task),esc(first),esc(last),esc(slice)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putaij(task,i,j,aij)
  f = Base.Meta.quot(:MSK_putaij)
  args = [esc(task),esc(i),esc(j),esc(aij)]
  types = :((Ptr{Nothing},Int32,Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putaijlist64(task,num,subi,subj,valij)
  f = Base.Meta.quot(:MSK_putaijlist64)
  args = [esc(task),esc(num),esc(subi),esc(subj),esc(valij)]
  types = :((Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putarow(task,i,nzi,subi,vali)
  f = Base.Meta.quot(:MSK_putarow)
  args = [esc(task),esc(i),esc(nzi),esc(subi),esc(vali)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putarowlist64(task,num,sub,ptrb,ptre,asub,aval)
  f = Base.Meta.quot(:MSK_putarowlist64)
  args = [esc(task),esc(num),esc(sub),esc(ptrb),esc(ptre),esc(asub),esc(aval)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putarowslice64(task,first,last,ptrb,ptre,asub,aval)
  f = Base.Meta.quot(:MSK_putarowslice64)
  args = [esc(task),esc(first),esc(last),esc(ptrb),esc(ptre),esc(asub),esc(aval)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putatruncatetol(task,tolzero)
  f = Base.Meta.quot(:MSK_putatruncatetol)
  args = [esc(task),esc(tolzero)]
  types = :((Ptr{Nothing},Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbarablocktriplet(task,num,subi,subj,subk,subl,valijkl)
  f = Base.Meta.quot(:MSK_putbarablocktriplet)
  args = [esc(task),esc(num),esc(subi),esc(subj),esc(subk),esc(subl),esc(valijkl)]
  types = :((Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbaraij(task,i,j,num,sub,weights)
  f = Base.Meta.quot(:MSK_putbaraij)
  args = [esc(task),esc(i),esc(j),esc(num),esc(sub),esc(weights)]
  types = :((Ptr{Nothing},Int32,Int32,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbaraijlist(task,num,subi,subj,alphaptrb,alphaptre,matidx,weights)
  f = Base.Meta.quot(:MSK_putbaraijlist)
  args = [esc(task),esc(num),esc(subi),esc(subj),esc(alphaptrb),esc(alphaptre),esc(matidx),esc(weights)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbararowlist(task,num,subi,ptrb,ptre,subj,nummat,matidx,weights)
  f = Base.Meta.quot(:MSK_putbararowlist)
  args = [esc(task),esc(num),esc(subi),esc(ptrb),esc(ptre),esc(subj),esc(nummat),esc(matidx),esc(weights)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Int32},Ptr{Int64},Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbarcblocktriplet(task,num,subj,subk,subl,valjkl)
  f = Base.Meta.quot(:MSK_putbarcblocktriplet)
  args = [esc(task),esc(num),esc(subj),esc(subk),esc(subl),esc(valjkl)]
  types = :((Ptr{Nothing},Int64,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbarcj(task,j,num,sub,weights)
  f = Base.Meta.quot(:MSK_putbarcj)
  args = [esc(task),esc(j),esc(num),esc(sub),esc(weights)]
  types = :((Ptr{Nothing},Int32,Int64,Ptr{Int64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbarsj(task,whichsol,j,barsj)
  f = Base.Meta.quot(:MSK_putbarsj)
  args = [esc(task),esc(whichsol),esc(j),esc(barsj)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbarvarname(task,j,name)
  f = Base.Meta.quot(:MSK_putbarvarname)
  args = [esc(task),esc(j),esc(name)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putbarxj(task,whichsol,j,barxj)
  f = Base.Meta.quot(:MSK_putbarxj)
  args = [esc(task),esc(whichsol),esc(j),esc(barxj)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putcfix(task,cfix)
  f = Base.Meta.quot(:MSK_putcfix)
  args = [esc(task),esc(cfix)]
  types = :((Ptr{Nothing},Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putcj(task,j,cj)
  f = Base.Meta.quot(:MSK_putcj)
  args = [esc(task),esc(j),esc(cj)]
  types = :((Ptr{Nothing},Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putclist(task,num,subj,val)
  f = Base.Meta.quot(:MSK_putclist)
  args = [esc(task),esc(num),esc(subj),esc(val)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconbound(task,i,bkc,blc,buc)
  f = Base.Meta.quot(:MSK_putconbound)
  args = [esc(task),esc(i),esc(bkc),esc(blc),esc(buc)]
  types = :((Ptr{Nothing},Int32,Int32,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconboundlist(task,num,sub,bkc,blc,buc)
  f = Base.Meta.quot(:MSK_putconboundlist)
  args = [esc(task),esc(num),esc(sub),esc(bkc),esc(blc),esc(buc)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconboundlistconst(task,num,sub,bkc,blc,buc)
  f = Base.Meta.quot(:MSK_putconboundlistconst)
  args = [esc(task),esc(num),esc(sub),esc(bkc),esc(blc),esc(buc)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Int32,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconboundslice(task,first,last,bkc,blc,buc)
  f = Base.Meta.quot(:MSK_putconboundslice)
  args = [esc(task),esc(first),esc(last),esc(bkc),esc(blc),esc(buc)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconboundsliceconst(task,first,last,bkc,blc,buc)
  f = Base.Meta.quot(:MSK_putconboundsliceconst)
  args = [esc(task),esc(first),esc(last),esc(bkc),esc(blc),esc(buc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putcone(task,k,ct,conepar,nummem,submem)
  f = Base.Meta.quot(:MSK_putcone)
  args = [esc(task),esc(k),esc(ct),esc(conepar),esc(nummem),esc(submem)]
  types = :((Ptr{Nothing},Int32,Int32,Float64,Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconename(task,j,name)
  f = Base.Meta.quot(:MSK_putconename)
  args = [esc(task),esc(j),esc(name)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconname(task,i,name)
  f = Base.Meta.quot(:MSK_putconname)
  args = [esc(task),esc(i),esc(name)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putconsolutioni(task,i,whichsol,sk,x,sl,su)
  f = Base.Meta.quot(:MSK_putconsolutioni)
  args = [esc(task),esc(i),esc(whichsol),esc(sk),esc(x),esc(sl),esc(su)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putcslice(task,first,last,slice)
  f = Base.Meta.quot(:MSK_putcslice)
  args = [esc(task),esc(first),esc(last),esc(slice)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putdjc(task,djcidx,numdomidx,domidxlist,numafeidx,afeidxlist,b,numterms,termsizelist)
  f = Base.Meta.quot(:MSK_putdjc)
  args = [esc(task),esc(djcidx),esc(numdomidx),esc(domidxlist),esc(numafeidx),esc(afeidxlist),esc(b),esc(numterms),esc(termsizelist)]
  types = :((Ptr{Nothing},Int64,Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},Int64,Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putdjcname(task,djcidx,name)
  f = Base.Meta.quot(:MSK_putdjcname)
  args = [esc(task),esc(djcidx),esc(name)]
  types = :((Ptr{Nothing},Int64,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putdjcslice(task,idxfirst,idxlast,numdomidx,domidxlist,numafeidx,afeidxlist,b,numterms,termsizelist,termsindjc)
  f = Base.Meta.quot(:MSK_putdjcslice)
  args = [esc(task),esc(idxfirst),esc(idxlast),esc(numdomidx),esc(domidxlist),esc(numafeidx),esc(afeidxlist),esc(b),esc(numterms),esc(termsizelist),esc(termsindjc)]
  types = :((Ptr{Nothing},Int64,Int64,Int64,Ptr{Int64},Int64,Ptr{Int64},Ptr{Float64},Int64,Ptr{Int64},Ptr{Int64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putdomainname(task,domidx,name)
  f = Base.Meta.quot(:MSK_putdomainname)
  args = [esc(task),esc(domidx),esc(name)]
  types = :((Ptr{Nothing},Int64,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putdouparam(task,param,parvalue)
  f = Base.Meta.quot(:MSK_putdouparam)
  args = [esc(task),esc(param),esc(parvalue)]
  types = :((Ptr{Nothing},Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putintparam(task,param,parvalue)
  f = Base.Meta.quot(:MSK_putintparam)
  args = [esc(task),esc(param),esc(parvalue)]
  types = :((Ptr{Nothing},Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putlicensecode(env,code)
  f = Base.Meta.quot(:MSK_putlicensecode)
  args = [esc(env),esc(code)]
  types = :((Ptr{Nothing},Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putlicensedebug(env,licdebug)
  f = Base.Meta.quot(:MSK_putlicensedebug)
  args = [esc(env),esc(licdebug)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putlicensepath(env,licensepath)
  f = Base.Meta.quot(:MSK_putlicensepath)
  args = [esc(env),esc(licensepath)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putlicensewait(env,licwait)
  f = Base.Meta.quot(:MSK_putlicensewait)
  args = [esc(env),esc(licwait)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumacc(task,maxnumacc)
  f = Base.Meta.quot(:MSK_putmaxnumacc)
  args = [esc(task),esc(maxnumacc)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumafe(task,maxnumafe)
  f = Base.Meta.quot(:MSK_putmaxnumafe)
  args = [esc(task),esc(maxnumafe)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumanz(task,maxnumanz)
  f = Base.Meta.quot(:MSK_putmaxnumanz)
  args = [esc(task),esc(maxnumanz)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumbarvar(task,maxnumbarvar)
  f = Base.Meta.quot(:MSK_putmaxnumbarvar)
  args = [esc(task),esc(maxnumbarvar)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumcon(task,maxnumcon)
  f = Base.Meta.quot(:MSK_putmaxnumcon)
  args = [esc(task),esc(maxnumcon)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumcone(task,maxnumcone)
  f = Base.Meta.quot(:MSK_putmaxnumcone)
  args = [esc(task),esc(maxnumcone)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumdjc(task,maxnumdjc)
  f = Base.Meta.quot(:MSK_putmaxnumdjc)
  args = [esc(task),esc(maxnumdjc)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumdomain(task,maxnumdomain)
  f = Base.Meta.quot(:MSK_putmaxnumdomain)
  args = [esc(task),esc(maxnumdomain)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumqnz(task,maxnumqnz)
  f = Base.Meta.quot(:MSK_putmaxnumqnz)
  args = [esc(task),esc(maxnumqnz)]
  types = :((Ptr{Nothing},Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putmaxnumvar(task,maxnumvar)
  f = Base.Meta.quot(:MSK_putmaxnumvar)
  args = [esc(task),esc(maxnumvar)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putnadouparam(task,paramname,parvalue)
  f = Base.Meta.quot(:MSK_putnadouparam)
  args = [esc(task),esc(paramname),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putnaintparam(task,paramname,parvalue)
  f = Base.Meta.quot(:MSK_putnaintparam)
  args = [esc(task),esc(paramname),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putnastrparam(task,paramname,parvalue)
  f = Base.Meta.quot(:MSK_putnastrparam)
  args = [esc(task),esc(paramname),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putobjname(task,objname)
  f = Base.Meta.quot(:MSK_putobjname)
  args = [esc(task),esc(objname)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putobjsense(task,sense)
  f = Base.Meta.quot(:MSK_putobjsense)
  args = [esc(task),esc(sense)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putoptserverhost(task,host)
  f = Base.Meta.quot(:MSK_putoptserverhost)
  args = [esc(task),esc(host)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putparam(task,parname,parvalue)
  f = Base.Meta.quot(:MSK_putparam)
  args = [esc(task),esc(parname),esc(parvalue)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putqcon(task,numqcnz,qcsubk,qcsubi,qcsubj,qcval)
  f = Base.Meta.quot(:MSK_putqcon)
  args = [esc(task),esc(numqcnz),esc(qcsubk),esc(qcsubi),esc(qcsubj),esc(qcval)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putqconk(task,k,numqcnz,qcsubi,qcsubj,qcval)
  f = Base.Meta.quot(:MSK_putqconk)
  args = [esc(task),esc(k),esc(numqcnz),esc(qcsubi),esc(qcsubj),esc(qcval)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putqobj(task,numqonz,qosubi,qosubj,qoval)
  f = Base.Meta.quot(:MSK_putqobj)
  args = [esc(task),esc(numqonz),esc(qosubi),esc(qosubj),esc(qoval)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putqobjij(task,i,j,qoij)
  f = Base.Meta.quot(:MSK_putqobjij)
  args = [esc(task),esc(i),esc(j),esc(qoij)]
  types = :((Ptr{Nothing},Int32,Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putskc(task,whichsol,skc)
  f = Base.Meta.quot(:MSK_putskc)
  args = [esc(task),esc(whichsol),esc(skc)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putskcslice(task,whichsol,first,last,skc)
  f = Base.Meta.quot(:MSK_putskcslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(skc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putskx(task,whichsol,skx)
  f = Base.Meta.quot(:MSK_putskx)
  args = [esc(task),esc(whichsol),esc(skx)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putskxslice(task,whichsol,first,last,skx)
  f = Base.Meta.quot(:MSK_putskxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(skx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putslc(task,whichsol,slc)
  f = Base.Meta.quot(:MSK_putslc)
  args = [esc(task),esc(whichsol),esc(slc)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putslcslice(task,whichsol,first,last,slc)
  f = Base.Meta.quot(:MSK_putslcslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(slc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putslx(task,whichsol,slx)
  f = Base.Meta.quot(:MSK_putslx)
  args = [esc(task),esc(whichsol),esc(slx)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putslxslice(task,whichsol,first,last,slx)
  f = Base.Meta.quot(:MSK_putslxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(slx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsnx(task,whichsol,sux)
  f = Base.Meta.quot(:MSK_putsnx)
  args = [esc(task),esc(whichsol),esc(sux)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsnxslice(task,whichsol,first,last,snx)
  f = Base.Meta.quot(:MSK_putsnxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(snx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsolution(task,whichsol,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx)
  f = Base.Meta.quot(:MSK_putsolution)
  args = [esc(task),esc(whichsol),esc(skc),esc(skx),esc(skn),esc(xc),esc(xx),esc(y),esc(slc),esc(suc),esc(slx),esc(sux),esc(snx)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsolutionnew(task,whichsol,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty)
  f = Base.Meta.quot(:MSK_putsolutionnew)
  args = [esc(task),esc(whichsol),esc(skc),esc(skx),esc(skn),esc(xc),esc(xx),esc(y),esc(slc),esc(suc),esc(slx),esc(sux),esc(snx),esc(doty)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsolutionyi(task,i,whichsol,y)
  f = Base.Meta.quot(:MSK_putsolutionyi)
  args = [esc(task),esc(i),esc(whichsol),esc(y)]
  types = :((Ptr{Nothing},Int32,Int32,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putstrparam(task,param,parvalue)
  f = Base.Meta.quot(:MSK_putstrparam)
  args = [esc(task),esc(param),esc(parvalue)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsuc(task,whichsol,suc)
  f = Base.Meta.quot(:MSK_putsuc)
  args = [esc(task),esc(whichsol),esc(suc)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsucslice(task,whichsol,first,last,suc)
  f = Base.Meta.quot(:MSK_putsucslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(suc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsux(task,whichsol,sux)
  f = Base.Meta.quot(:MSK_putsux)
  args = [esc(task),esc(whichsol),esc(sux)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putsuxslice(task,whichsol,first,last,sux)
  f = Base.Meta.quot(:MSK_putsuxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(sux)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_puttaskname(task,taskname)
  f = Base.Meta.quot(:MSK_puttaskname)
  args = [esc(task),esc(taskname)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarbound(task,j,bkx,blx,bux)
  f = Base.Meta.quot(:MSK_putvarbound)
  args = [esc(task),esc(j),esc(bkx),esc(blx),esc(bux)]
  types = :((Ptr{Nothing},Int32,Int32,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarboundlist(task,num,sub,bkx,blx,bux)
  f = Base.Meta.quot(:MSK_putvarboundlist)
  args = [esc(task),esc(num),esc(sub),esc(bkx),esc(blx),esc(bux)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarboundlistconst(task,num,sub,bkx,blx,bux)
  f = Base.Meta.quot(:MSK_putvarboundlistconst)
  args = [esc(task),esc(num),esc(sub),esc(bkx),esc(blx),esc(bux)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Int32,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarboundslice(task,first,last,bkx,blx,bux)
  f = Base.Meta.quot(:MSK_putvarboundslice)
  args = [esc(task),esc(first),esc(last),esc(bkx),esc(blx),esc(bux)]
  types = :((Ptr{Nothing},Int32,Int32,Ptr{Int32},Ptr{Float64},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarboundsliceconst(task,first,last,bkx,blx,bux)
  f = Base.Meta.quot(:MSK_putvarboundsliceconst)
  args = [esc(task),esc(first),esc(last),esc(bkx),esc(blx),esc(bux)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarname(task,j,name)
  f = Base.Meta.quot(:MSK_putvarname)
  args = [esc(task),esc(j),esc(name)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvarsolutionj(task,j,whichsol,sk,x,sl,su,sn)
  f = Base.Meta.quot(:MSK_putvarsolutionj)
  args = [esc(task),esc(j),esc(whichsol),esc(sk),esc(x),esc(sl),esc(su),esc(sn)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Float64,Float64,Float64,Float64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvartype(task,j,vartype)
  f = Base.Meta.quot(:MSK_putvartype)
  args = [esc(task),esc(j),esc(vartype)]
  types = :((Ptr{Nothing},Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putvartypelist(task,num,subj,vartype)
  f = Base.Meta.quot(:MSK_putvartypelist)
  args = [esc(task),esc(num),esc(subj),esc(vartype)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putxc(task,whichsol,xc)
  f = Base.Meta.quot(:MSK_putxc)
  args = [esc(task),esc(whichsol),esc(xc)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putxcslice(task,whichsol,first,last,xc)
  f = Base.Meta.quot(:MSK_putxcslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(xc)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putxx(task,whichsol,xx)
  f = Base.Meta.quot(:MSK_putxx)
  args = [esc(task),esc(whichsol),esc(xx)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putxxslice(task,whichsol,first,last,xx)
  f = Base.Meta.quot(:MSK_putxxslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(xx)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_puty(task,whichsol,y)
  f = Base.Meta.quot(:MSK_puty)
  args = [esc(task),esc(whichsol),esc(y)]
  types = :((Ptr{Nothing},Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_putyslice(task,whichsol,first,last,y)
  f = Base.Meta.quot(:MSK_putyslice)
  args = [esc(task),esc(whichsol),esc(first),esc(last),esc(y)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readdataautoformat(task,filename)
  f = Base.Meta.quot(:MSK_readdataautoformat)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readdataformat(task,filename,format,compress)
  f = Base.Meta.quot(:MSK_readdataformat)
  args = [esc(task),esc(filename),esc(format),esc(compress)]
  types = :((Ptr{Nothing},Ptr{UInt8},Int32,Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readjsonstring(task,data)
  f = Base.Meta.quot(:MSK_readjsonstring)
  args = [esc(task),esc(data)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readlpstring(task,data)
  f = Base.Meta.quot(:MSK_readlpstring)
  args = [esc(task),esc(data)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readopfstring(task,data)
  f = Base.Meta.quot(:MSK_readopfstring)
  args = [esc(task),esc(data)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readparamfile(task,filename)
  f = Base.Meta.quot(:MSK_readparamfile)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readptfstring(task,data)
  f = Base.Meta.quot(:MSK_readptfstring)
  args = [esc(task),esc(data)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readsolution(task,whichsol,filename)
  f = Base.Meta.quot(:MSK_readsolution)
  args = [esc(task),esc(whichsol),esc(filename)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readsummary(task,whichstream)
  f = Base.Meta.quot(:MSK_readsummary)
  args = [esc(task),esc(whichstream)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_readtask(task,filename)
  f = Base.Meta.quot(:MSK_readtask)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_removebarvars(task,num,subset)
  f = Base.Meta.quot(:MSK_removebarvars)
  args = [esc(task),esc(num),esc(subset)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_removecones(task,num,subset)
  f = Base.Meta.quot(:MSK_removecones)
  args = [esc(task),esc(num),esc(subset)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_removecons(task,num,subset)
  f = Base.Meta.quot(:MSK_removecons)
  args = [esc(task),esc(num),esc(subset)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_removevars(task,num,subset)
  f = Base.Meta.quot(:MSK_removevars)
  args = [esc(task),esc(num),esc(subset)]
  types = :((Ptr{Nothing},Int32,Ptr{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_resizetask(task,maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz)
  f = Base.Meta.quot(:MSK_resizetask)
  args = [esc(task),esc(maxnumcon),esc(maxnumvar),esc(maxnumcone),esc(maxnumanz),esc(maxnumqnz)]
  types = :((Ptr{Nothing},Int32,Int32,Int32,Int64,Int64,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_sensitivityreport(task,whichstream)
  f = Base.Meta.quot(:MSK_sensitivityreport)
  args = [esc(task),esc(whichstream)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_setdefaults(task)
  f = Base.Meta.quot(:MSK_setdefaults)
  args = [esc(task)]
  types = :((Ptr{Nothing},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_setupthreads(env,numthreads)
  f = Base.Meta.quot(:MSK_setupthreads)
  args = [esc(env),esc(numthreads)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_solutiondef(task,whichsol,isdef)
  f = Base.Meta.quot(:MSK_solutiondef)
  args = [esc(task),esc(whichsol),esc(isdef)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_solutionsummary(task,whichstream)
  f = Base.Meta.quot(:MSK_solutionsummary)
  args = [esc(task),esc(whichstream)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_solvewithbasis(task,transp,numnz,sub,val)
  f = Base.Meta.quot(:MSK_solvewithbasis)
  args = [esc(task),esc(transp),esc(numnz),esc(sub),esc(val)]
  types = :((Ptr{Nothing},Int32,Ref{Int32},Ptr{Int32},Ptr{Float64},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_strtoconetype(task,str,conetype)
  f = Base.Meta.quot(:MSK_strtoconetype)
  args = [esc(task),esc(str),esc(conetype)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_strtosk(task,str,sk)
  f = Base.Meta.quot(:MSK_strtosk)
  args = [esc(task),esc(str),esc(sk)]
  types = :((Ptr{Nothing},Ptr{UInt8},Ref{Int32},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_updatesolutioninfo(task,whichsol)
  f = Base.Meta.quot(:MSK_updatesolutioninfo)
  args = [esc(task),esc(whichsol)]
  types = :((Ptr{Nothing},Int32,))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_writedata(task,filename)
  f = Base.Meta.quot(:MSK_writedata)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_writejsonsol(task,filename)
  f = Base.Meta.quot(:MSK_writejsonsol)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_writeparamfile(task,filename)
  f = Base.Meta.quot(:MSK_writeparamfile)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_writesolution(task,whichsol,filename)
  f = Base.Meta.quot(:MSK_writesolution)
  args = [esc(task),esc(whichsol),esc(filename)]
  types = :((Ptr{Nothing},Int32,Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
macro MSK_writetask(task,filename)
  f = Base.Meta.quot(:MSK_writetask)
  args = [esc(task),esc(filename)]
  types = :((Ptr{Nothing},Ptr{UInt8},))
  quote
    ccall(($f,libmosek), Int32, $types, $(args...))
  end
end
"""
    analyzenames(task_:: MSKtask,whichstream_:: Streamtype,nametype_:: Nametype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `nametype :: Nametype`. The type of names e.g. valid in MPS or LP files.

The function analyzes the names and issues an error if a name is invalid.
"""
function analyzenames end
function analyzenames(task_:: MSKtask,whichstream_:: Streamtype,nametype_:: Nametype)
  res = disable_sigint() do
    @MSK_analyzenames(task_.task,whichstream_.value,nametype_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    analyzeproblem(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

The function analyzes the data of a task and writes out a report.
"""
function analyzeproblem end
function analyzeproblem(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @MSK_analyzeproblem(task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    analyzesolution(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `whichsol :: Soltype`. Selects a solution.

Print information related to the quality of the solution and
other solution statistics.

By default this function prints information about the
largest infeasibilites in the solution, the primal (and
possibly dual) objective value and the solution status.

Following parameters can be used to configure the printed statistics:

* `MSK_IPAR_ANA_SOL_BASIS`` enables or disables printing of statistics specific to the basis solution (condition number, number of basic variables etc.). Default is on.
* `MSK_IPAR_ANA_SOL_PRINT_VIOLATED`` enables or disables listing names of all constraints (both primal and dual) which are violated by the solution. Default is off.
* `MSK_DPAR_ANA_SOL_INFEAS_TOL`` is the tolerance defining when a constraint is considered violated. If a constraint is violated more than this, it will be listed in the summary.
"""
function analyzesolution end
function analyzesolution(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)
  res = disable_sigint() do
    @MSK_analyzesolution(task_.task,whichstream_.value,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendacc{T1,T2,T3}(task:: MSKtask,domidx:: T1,afeidxlist:: Vector{T2},b:: Vector{T3})
    appendacc(task_:: MSKtask,domidx_:: Int64,afeidxlist_:: Vector{Int64},b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Domain index.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Appends an affine conic constraint to the task. The affine constraint has the form *a sequence of affine expressions belongs to a domain*.

The domain index is specified with `domidx` and should refer to a domain previously appended with one of the `append...domain` functions.

The length of the affine expression list `afeidxlist` must be equal to the dimension ``n`` of the domain. The elements of `afeidxlist` are indexes to the store of affine expressions, i.e. the affine expressions appearing in the affine conic constraint are:

```math
 F_{\\mathrm{afeidxlist}[k],:}x + g_{\\mathrm{afeidxlist}[k]} \\mathcal{C}_q \\mathrm{for}\\ k=0,\\ldots,n-1.
```
If an optional vector `b` of the same length as `afeidxlist` is specified then the expressions appearing in the affine constraint will instead be taken as:

```math
 F_{\\mathrm{afeidxlist}[k],:}x + g_{\\mathrm{afeidxlist}[k]} - b_k \\mathcal{C}_q \\mathrm{for}\\ k=0,\\ldots,n-1.
```

"""
function appendacc end
appendacc(task:: MSKtask,domidx:: T1,afeidxlist:: Vector{T2},b:: Vector{T3}) where {T1,T2,T3} = appendacc(task,convert(Int64,domidx),convert(Vector{Int64},afeidxlist),convert(Vector{Float64},b))
function appendacc(task_:: MSKtask,domidx_:: Int64,afeidxlist_:: Vector{Int64},b_:: Vector{Float64})
  numafeidx_ = minimum([ length(afeidxlist_) ])
  __tmp_var_0 = (numafeidx_)
  println("b_ = $b_, len(b) = $(length(b_)), numafeidx = $(numafeidx_)")
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_appendacc(task_.task,domidx_-1,numafeidx_,afeidxlist_ .- Int32(1),b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendaccs{T1,T2,T3}(task:: MSKtask,domidxs:: Vector{T1},afeidxlist:: Vector{T2},b:: Vector{T3})
    appendaccs(task_:: MSKtask,domidxs_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `domidxs :: Vector{Int64}`. Domain indices.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Appends `numaccs` affine conic constraint to the task. Each single affine conic constraint should be specified as in `Mosek.appendacc` and the input of this function should contain the concatenation of all these descriptions.

In particular, the length of `afeidxlist` must equal the sum of dimensions of domains indexed in `domainsidxs`.
"""
function appendaccs end
appendaccs(task:: MSKtask,domidxs:: Vector{T1},afeidxlist:: Vector{T2},b:: Vector{T3}) where {T1,T2,T3} = appendaccs(task,convert(Vector{Int64},domidxs),convert(Vector{Int64},afeidxlist),convert(Vector{Float64},b))
function appendaccs(task_:: MSKtask,domidxs_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64})
  numaccs_ = minimum([ length(domidxs_) ])
  numafeidx_ = minimum([ length(afeidxlist_) ])
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_appendaccs(task_.task,numaccs_,domidxs_ .- Int32(1),numafeidx_,afeidxlist_ .- Int32(1),b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendaccseq{T1,T2,T3}(task:: MSKtask,domidx:: T1,afeidxfirst:: T2,b:: Vector{T3})
    appendaccseq(task_:: MSKtask,domidx_:: Int64,afeidxfirst_:: Int64,b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Domain index.
* `afeidxfirst :: Int64`. Index of the first affine expression.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Appends an affine conic constraint to the task, as in `Mosek.appendacc`. The function assumes the affine expressions forming the constraint are sequential. The affine constraint has the form *a sequence of affine expressions belongs to a domain*.

The domain index is specified with `domidx` and should refer to a domain previously appended with one of the `append...domain` functions.

The number of affine expressions should be equal to the dimension ``n`` of the domain. The affine expressions forming the affine constraint are arranged sequentially in a contiguous block of the affine expression store starting from position `afeidxfirst`. That is, the affine expressions appearing in the affine conic constraint are:

```math
 F_{\\mathrm{afeidxfirst}+k,:}x + g_{\\mathrm{afeidxfirst}+k} \\mathcal{C}_q \\mathrm{for}\\ k=0,\\ldots,n-1.
```
If an optional vector `b` of length `numafeidx` is specified then the expressions appearing in the affine constraint will instead be taken as

```math
 F_{\\mathrm{afeidxfirst}+k,:}x + g_{\\mathrm{afeidxfirst}+k} - b_k \\mathcal{C}_q \\mathrm{for}\\ k=0,\\ldots,n-1.
```

"""
function appendaccseq end
appendaccseq(task:: MSKtask,domidx:: T1,afeidxfirst:: T2,b:: Vector{T3}) where {T1,T2,T3} = appendaccseq(task,convert(Int64,domidx),convert(Int64,afeidxfirst),convert(Vector{Float64},b))
function appendaccseq(task_:: MSKtask,domidx_:: Int64,afeidxfirst_:: Int64,b_:: Vector{Float64})
  numafeidx_ = begin __tmp_var_appendaccseq_0 = Ref{Int64}(); @MSK_getdomainn(task_.task,(domidx_),__tmp_var_appendaccseq_0); __tmp_var_appendaccseq_0.x end
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_appendaccseq(task_.task,domidx_,numafeidx_,afeidxfirst_-1,b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendaccsseq{T1,T2,T3,T4}(task:: MSKtask,domidxs:: Vector{T1},numafeidx:: T2,afeidxfirst:: T3,b:: Vector{T4})
    appendaccsseq(task_:: MSKtask,domidxs_:: Vector{Int64},numafeidx_:: Int64,afeidxfirst_:: Int64,b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `domidxs :: Vector{Int64}`. Domain indices.
* `numafeidx :: Int64`. Number of affine expressions in the affine expression list (must equal the sum of dimensions of the domains).
* `afeidxfirst :: Int64`. Index of the first affine expression.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Appends `numaccs` affine conic constraint to the task. It is the block variant of `Mosek.appendaccs`, that is it assumes that the affine expressions appearing in the affine conic constraints are sequential in the affine expression store, starting from position `afeidxfirst`.
"""
function appendaccsseq end
appendaccsseq(task:: MSKtask,domidxs:: Vector{T1},numafeidx:: T2,afeidxfirst:: T3,b:: Vector{T4}) where {T1,T2,T3,T4} = appendaccsseq(task,convert(Vector{Int64},domidxs),convert(Int64,numafeidx),convert(Int64,afeidxfirst),convert(Vector{Float64},b))
function appendaccsseq(task_:: MSKtask,domidxs_:: Vector{Int64},numafeidx_:: Int64,afeidxfirst_:: Int64,b_:: Vector{Float64})
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  numaccs_ = minimum([ length(domidxs_) ])
  res = disable_sigint() do
    @MSK_appendaccsseq(task_.task,numaccs_,domidxs_ .- Int32(1),numafeidx_,afeidxfirst_-1,b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendafes{T1}(task:: MSKtask,num:: T1)
    appendafes(task_:: MSKtask,num_:: Int64)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of empty affine expressions which should be appended.

Appends a number of empty affine expressions to the task.
"""
function appendafes end
appendafes(task:: MSKtask,num:: T1) where {T1} = appendafes(task,convert(Int64,num))
function appendafes(task_:: MSKtask,num_:: Int64)
  res = disable_sigint() do
    @MSK_appendafes(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendbarvars{T1}(task:: MSKtask,dim:: Vector{T1})
    appendbarvars(task_:: MSKtask,dim_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `dim :: Vector{Int32}`. Dimensions of symmetric matrix variables to be added.

Appends positive semidefinite matrix variables of dimensions given by `dim` to the problem.
"""
function appendbarvars end
appendbarvars(task:: MSKtask,dim:: Vector{T1}) where {T1} = appendbarvars(task,convert(Vector{Int32},dim))
function appendbarvars(task_:: MSKtask,dim_:: Vector{Int32})
  num_ = minimum([ length(dim_) ])
  res = disable_sigint() do
    @MSK_appendbarvars(task_.task,num_,dim_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendcone{T2,T3}(task:: MSKtask,ct:: Conetype,conepar:: T2,submem:: Vector{T3})
    appendcone(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
* `submem :: Vector{Int32}`. Variable subscripts of the members in the cone.

Deprecated in MOSEK 10

Appends a new conic constraint to the problem. Hence, add a constraint

```math
 \\hat{x} \\in \\mathcal{K}
```
to the problem, where ``\\mathcal{K}`` is a convex cone. ``\\hat{x}`` is a
subset of the variables which will be specified by the argument
`submem`. Cone type is specified by `ct`.

Define

```math
 \\hat{x} = x_{\\mathtt{submem}[0]},\\ldots,x_{\\mathtt{submem}[\\mathtt{nummem}-1]}.
```
Depending on the value of `ct` this function appends one of the constraints:

* Quadratic cone (`MSK_CT_QUAD`, requires ``\\mathtt{nummem}\\geq 1``):

```math
 \\hat{x}_0 \\geq \\sqrt{\\sum_{i=1}^{i<\\mathtt{nummem}} \\hat{x}_i^2}
```
* Rotated quadratic cone (`MSK_CT_RQUAD`, requires ``\\mathtt{nummem}\\geq 2``):

```math
 2 \\hat{x}_0 \\hat{x}_1 \\geq \\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i, \\mathcal{C}_q \\hat{x}_{0}, \\hat{x}_1 \\geq 0
```
* Primal exponential cone (`MSK_CT_PEXP`, requires ``\\mathtt{nummem}=3``):

```math
 \\hat{x}_0 \\geq \\hat{x}_1\\exp(\\hat{x}_2/\\hat{x}_1), \\mathcal{C}_q \\hat{x}_0,\\hat{x}_1 \\geq 0
```
* Primal power cone (`MSK_CT_PPOW`, requires ``\\mathtt{nummem}\\geq 2``):

```math
 \\hat{x}_0^\\alpha \\hat{x}_1^{1-\\alpha} \\geq \\sqrt{\\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i}, \\mathcal{C}_q \\hat{x}_{0}, \\hat{x}_1 \\geq 0
```
  where ``\\alpha`` is the cone parameter specified by `conepar`.

* Dual exponential cone (`MSK_CT_DEXP`, requires ``\\mathtt{nummem}=3``):

```math
 \\hat{x}_0 \\geq -\\hat{x}_2 e^{-1}\\exp(\\hat{x}_1/\\hat{x}_2), \\mathcal{C}_q \\hat{x}_2\\leq 0,\\hat{x}_0 \\geq 0
```
* Dual power cone (`MSK_CT_DPOW`, requires ``\\mathtt{nummem}\\geq 2``):

```math
 \\left(\\frac{\\hat{x}_0}{\\alpha}\\right)^\\alpha \\left(\\frac{\\hat{x}_1}{1-\\alpha}\\right)^{1-\\alpha} \\geq \\sqrt{\\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i}, \\mathcal{C}_q \\hat{x}_{0}, \\hat{x}_1 \\geq 0
```
  where ``\\alpha`` is the cone parameter specified by `conepar`.

* Zero cone (`MSK_CT_ZERO`):

```math
 \\hat{x}_i = 0 \\ \\textrm{for all}\\ i
```
Please note that the sets of variables appearing in different conic constraints must be disjoint.

For an explained code example see :numref:`doc.tutorial_cqo`, :numref:`doc.tutorial_ceo` or :numref:`doc.tutorial_pow`.
"""
function appendcone end
appendcone(task:: MSKtask,ct:: Conetype,conepar:: T2,submem:: Vector{T3}) where {T2,T3} = appendcone(task,ct,convert(Float64,conepar),convert(Vector{Int32},submem))
function appendcone(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})
  nummem_ = minimum([ length(submem_) ])
  res = disable_sigint() do
    @MSK_appendcone(task_.task,ct_.value,conepar_,nummem_,submem_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendconeseq{T2,T3,T4}(task:: MSKtask,ct:: Conetype,conepar:: T2,nummem:: T3,j:: T4)
    appendconeseq(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,nummem_:: Int32,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
* `nummem :: Int32`. Number of member variables in the cone.
* `j :: Int32`. Index of the first variable in the conic constraint.

Deprecated in MOSEK 10

Appends a new conic constraint to the problem, as in `Mosek.appendcone`. The
function assumes the members of cone are sequential
where the first member has index `j` and the last
`j+nummem-1`.
"""
function appendconeseq end
appendconeseq(task:: MSKtask,ct:: Conetype,conepar:: T2,nummem:: T3,j:: T4) where {T2,T3,T4} = appendconeseq(task,ct,convert(Float64,conepar),convert(Int32,nummem),convert(Int32,j))
function appendconeseq(task_:: MSKtask,ct_:: Conetype,conepar_:: Float64,nummem_:: Int32,j_:: Int32)
  res = disable_sigint() do
    @MSK_appendconeseq(task_.task,ct_.value,conepar_,nummem_,j_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendconesseq{T2,T3,T4}(task:: MSKtask,ct:: Vector{Conetype},conepar:: Vector{T2},nummem:: Vector{T3},j:: T4)
    appendconesseq(task_:: MSKtask,ct_:: Vector{Conetype},conepar_:: Vector{Float64},nummem_:: Vector{Int32},j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `ct :: Vector{Int32}`. Specifies the type of the cone.
* `conepar :: Vector{Float64}`. For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
* `nummem :: Vector{Int32}`. Numbers of member variables in the cones.
* `j :: Int32`. Index of the first variable in the first cone to be appended.

Deprecated in MOSEK 10

Appends a number of conic constraints to the problem, as in `Mosek.appendcone`.
The ``k`` th cone is assumed to be of dimension `nummem[k]`. Moreover, it is assumed
that the first variable of the first cone has index ``j`` and starting from there the
sequentially following variables belong to the first cone, then to the second cone and so on.
"""
function appendconesseq end
appendconesseq(task:: MSKtask,ct:: Vector{Conetype},conepar:: Vector{T2},nummem:: Vector{T3},j:: T4) where {T2,T3,T4} = appendconesseq(task,ct,convert(Vector{Float64},conepar),convert(Vector{Int32},nummem),convert(Int32,j))
function appendconesseq(task_:: MSKtask,ct_:: Vector{Conetype},conepar_:: Vector{Float64},nummem_:: Vector{Int32},j_:: Int32)
  ct_i32 = Int32[item.value for item in ct_]
  num_ = minimum([ length(ct_),length(conepar_),length(nummem_) ])
  res = disable_sigint() do
    @MSK_appendconesseq(task_.task,num_,ct_,conepar_,nummem_,j_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appendcons{T1}(task:: MSKtask,num:: T1)
    appendcons(task_:: MSKtask,num_:: Int32)

* `task :: MSKtask`. An optimization task.
* `num :: Int32`. Number of constraints which should be appended.

Appends a number of constraints to the
model. Appended constraints will be declared
free. Please note that MOSEK will automatically
expand the problem dimension to accommodate the
additional constraints.
"""
function appendcons end
appendcons(task:: MSKtask,num:: T1) where {T1} = appendcons(task,convert(Int32,num))
function appendcons(task_:: MSKtask,num_:: Int32)
  res = disable_sigint() do
    @MSK_appendcons(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    appenddjcs{T1}(task:: MSKtask,num:: T1)
    appenddjcs(task_:: MSKtask,num_:: Int64)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of empty disjunctive constraints which should be appended.

Appends a number of empty disjunctive constraints to the task.
"""
function appenddjcs end
appenddjcs(task:: MSKtask,num:: T1) where {T1} = appenddjcs(task,convert(Int64,num))
function appenddjcs(task_:: MSKtask,num_:: Int64)
  res = disable_sigint() do
    @MSK_appenddjcs(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    domidx = appenddualexpconedomain(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.

Appends the dual exponential cone ``\\left\\{ x\\in \\real^3 ~:~ x_0 \\geq -x_2 e^{-1} e^{x_1/x_2},\\ x_0> 0,\\ x_2< 0 \\right\\}`` to the list of domains.
"""
function appenddualexpconedomain end
function appenddualexpconedomain(task_:: MSKtask)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appenddualexpconedomain(task_.task,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appenddualgeomeanconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appenddualgeomeanconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the dual geometric mean cone ``\\left\\{ x\\in \\real^n ~:~ (n-1) \\left(\\prod_{i=0}^{n-2} x_i\\right)^{1/(n-1)} \\geq |x_{n-1}|,\\ x_0,\\ldots,x_{n-2}\\geq 0 \\right\\}`` to the list of domains.
"""
function appenddualgeomeanconedomain end
appenddualgeomeanconedomain(task:: MSKtask,n:: T1) where {T1} = appenddualgeomeanconedomain(task,convert(Int64,n))
function appenddualgeomeanconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appenddualgeomeanconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appenddualpowerconedomain{T1,T2}(task:: MSKtask,n:: T1,alpha:: Vector{T2})
    domidx = appenddualpowerconedomain(task_:: MSKtask,n_:: Int64,alpha_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimension of the domain.
* `alpha :: Vector{Float64}`. The sequence proportional to exponents. Must be positive.
* `domidx :: Int64`. Index of the domain.

Appends the dual power cone domain of dimension ``n``, with ``n_\\ell`` variables appearing on the left-hand side, where ``n_\\ell`` is the length of ``\\alpha``, and with a homogenous sequence of exponents ``\\alpha_0,\\ldots,\\alpha_{n_\\ell-1}``.

Formally, let ``s = \\sum_i \\alpha_i`` and ``\\beta_i = \\alpha_i / s``, so that ``\\sum_i \\beta_i=1``. Then the dual power cone is defined as follows:

```math
 \\left\\{ x\\in \\real^n ~:~ \\prod_{i=0}^{n_\\ell-1} \\left(\\frac{x_i}{\\beta_i}\\right)^{\\beta_i} \\geq \\sqrt{\\sum_{j=n_\\ell}^{n-1}x_j^2},\\ x_0\\ldots,x_{n_\\ell-1}\\geq 0 \\right\\}
```

"""
function appenddualpowerconedomain end
appenddualpowerconedomain(task:: MSKtask,n:: T1,alpha:: Vector{T2}) where {T1,T2} = appenddualpowerconedomain(task,convert(Int64,n),convert(Vector{Float64},alpha))
function appenddualpowerconedomain(task_:: MSKtask,n_:: Int64,alpha_:: Vector{Float64})
  domidx_ = Ref(Int64(1))
  nleft_ = minimum([ length(alpha_) ])
  res = disable_sigint() do
    @MSK_appenddualpowerconedomain(task_.task,n_,nleft_,alpha_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendinfnormconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendinfnormconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional ``\\infty``-norm cone ``\\left\\{ x\\in \\real^n ~:~ x_0 \\geq \\mathrm{sup}_{i=1,\\ldots,n-1}|x_i| \\right\\}`` to the list of domains.
"""
function appendinfnormconedomain end
appendinfnormconedomain(task:: MSKtask,n:: T1) where {T1} = appendinfnormconedomain(task,convert(Int64,n))
function appendinfnormconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendinfnormconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendonenormconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendonenormconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional ``1``-norm cone ``\\left\\{ x\\in \\real^n ~:~ x_0 \\geq \\sum_{i=1}^{n-1} |x_i| \\right\\}`` to the list of domains.
"""
function appendonenormconedomain end
appendonenormconedomain(task:: MSKtask,n:: T1) where {T1} = appendonenormconedomain(task,convert(Int64,n))
function appendonenormconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendonenormconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendprimalexpconedomain(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.

Appends the primal exponential cone ``\\left\\{ x\\in \\real^3 ~:~ x_0 \\geq x_1 e^{x_2/x_1},\\ x_0,x_1> 0 \\right\\}`` to the list of domains.
"""
function appendprimalexpconedomain end
function appendprimalexpconedomain(task_:: MSKtask)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendprimalexpconedomain(task_.task,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendprimalgeomeanconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendprimalgeomeanconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the primal geometric mean cone ``\\left\\{ x\\in \\real^n ~:~ \\left(\\prod_{i=0}^{n-2} x_i\\right)^{1/(n-1)} \\geq |x_{n-1}|,\\ x_0\\ldots,x_{n-2}\\geq 0 \\right\\}`` to the list of domains.
"""
function appendprimalgeomeanconedomain end
appendprimalgeomeanconedomain(task:: MSKtask,n:: T1) where {T1} = appendprimalgeomeanconedomain(task,convert(Int64,n))
function appendprimalgeomeanconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendprimalgeomeanconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendprimalpowerconedomain{T1,T2}(task:: MSKtask,n:: T1,alpha:: Vector{T2})
    domidx = appendprimalpowerconedomain(task_:: MSKtask,n_:: Int64,alpha_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimension of the domain.
* `alpha :: Vector{Float64}`. The sequence proportional to exponents. Must be positive.
* `domidx :: Int64`. Index of the domain.

Appends the primal power cone domain of dimension ``n``, with ``n_\\ell`` variables appearing on the left-hand side, where ``n_\\ell`` is the length of ``\\alpha``, and with a homogenous sequence of exponents ``\\alpha_0,\\ldots,\\alpha_{n_\\ell-1}``.

Formally, let ``s = \\sum_i \\alpha_i`` and ``\\beta_i = \\alpha_i / s``, so that ``\\sum_i \\beta_i=1``. Then the primal power cone is defined as follows:

```math
 \\left\\{ x\\in \\real^n ~:~ \\prod_{i=0}^{n_\\ell-1} x_i^{\\beta_i} \\geq \\sqrt{\\sum_{j=n_\\ell}^{n-1}x_j^2},\\ x_0\\ldots,x_{n_\\ell-1}\\geq 0 \\right\\}
```

"""
function appendprimalpowerconedomain end
appendprimalpowerconedomain(task:: MSKtask,n:: T1,alpha:: Vector{T2}) where {T1,T2} = appendprimalpowerconedomain(task,convert(Int64,n),convert(Vector{Float64},alpha))
function appendprimalpowerconedomain(task_:: MSKtask,n_:: Int64,alpha_:: Vector{Float64})
  domidx_ = Ref(Int64(1))
  nleft_ = minimum([ length(alpha_) ])
  res = disable_sigint() do
    @MSK_appendprimalpowerconedomain(task_.task,n_,nleft_,alpha_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendpsdconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendpsdconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the lower-triangular positive semidefinite cone domain: the set of ``x\\in \\real^n`` which are the vectorized lower-triangular part of some symmetric positive semidefinite matrix ``X\\in\\PSD^d`` where ``n=d(d+1)/2`` for some ``d\\geq 1``, stored in column-major format.
"""
function appendpsdconedomain end
appendpsdconedomain(task:: MSKtask,n:: T1) where {T1} = appendpsdconedomain(task,convert(Int64,n))
function appendpsdconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendpsdconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendquadraticconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendquadraticconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional quadratic cone ``\\left\\{x\\in\\real^n~:~x_0 \\geq \\sqrt{\\sum_{i=1}^{n-1} x_i^2}\\right\\}`` to the list of domains.
"""
function appendquadraticconedomain end
appendquadraticconedomain(task:: MSKtask,n:: T1) where {T1} = appendquadraticconedomain(task,convert(Int64,n))
function appendquadraticconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendquadraticconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendrdomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendrdomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional real space ``\\{ x \\in \\real^n \\}`` to the list of domains.
"""
function appendrdomain end
appendrdomain(task:: MSKtask,n:: T1) where {T1} = appendrdomain(task,convert(Int64,n))
function appendrdomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendrdomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendrminusdomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendrminusdomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional negative orthant ``\\{ x \\in \\real^n: \\, x \\leq 0 \\}`` to the list of domains.
"""
function appendrminusdomain end
appendrminusdomain(task:: MSKtask,n:: T1) where {T1} = appendrminusdomain(task,convert(Int64,n))
function appendrminusdomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendrminusdomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendrplusdomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendrplusdomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional positive orthant ``\\{ x \\in \\real^n: \\, x \\geq 0 \\}`` to the list of domains.
"""
function appendrplusdomain end
appendrplusdomain(task:: MSKtask,n:: T1) where {T1} = appendrplusdomain(task,convert(Int64,n))
function appendrplusdomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendrplusdomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendrquadraticconedomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendrquadraticconedomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the ``n``-dimensional rotated quadratic cone ``\\left\\{x\\in\\real^n~:~2 x_0 x_1 \\geq \\sqrt{\\sum_{i=2}^{n-1} x_i^2},\\ x_0,x_1\\geq 0\\right\\}`` to the list of domains.
"""
function appendrquadraticconedomain end
appendrquadraticconedomain(task:: MSKtask,n:: T1) where {T1} = appendrquadraticconedomain(task,convert(Int64,n))
function appendrquadraticconedomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendrquadraticconedomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    domidx = appendrzerodomain{T1}(task:: MSKtask,n:: T1)
    domidx = appendrzerodomain(task_:: MSKtask,n_:: Int64)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. Dimmension of the domain.
* `domidx :: Int64`. Index of the domain.

Appends the zero in ``n``-dimensional real space ``\\{ x \\in \\real^n: \\, x = 0 \\}`` to the list of domains.
"""
function appendrzerodomain end
appendrzerodomain(task:: MSKtask,n:: T1) where {T1} = appendrzerodomain(task,convert(Int64,n))
function appendrzerodomain(task_:: MSKtask,n_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_appendrzerodomain(task_.task,n_,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    idx = appendsparsesymmat{T1,T2,T3,T4}(task:: MSKtask,dim:: T1,subi:: Vector{T2},subj:: Vector{T3},valij:: Vector{T4})
    idx = appendsparsesymmat{T1}(task:: MSKtask,dim:: T1,data:: SparseMatrixCSC{Float64})
    idx = appendsparsesymmat(task_:: MSKtask,dim_:: Int32,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `dim :: Int32`. Dimension of the symmetric matrix that is appended.
* `subi :: Vector{Int32}`. Row subscript in the triplets.
* `subj :: Vector{Int32}`. Column subscripts in the triplets.
* `valij :: Vector{Float64}`. Values of each triplet.
* `idx :: Int64`. Unique index assigned to the inputted matrix.
* `data :: SparseMatrixCSC{Float64}`. The symmetric matrix 1/2 (data' + data) is used

MOSEK maintains a storage of symmetric data matrices that is used to build
``\\bar C`` and ``\\bar A``. The storage can be thought of as a vector of
symmetric matrices denoted ``E``. Hence, ``E_i`` is a symmetric matrix of certain
dimension.

This function appends a general sparse symmetric matrix on triplet form to the
vector ``E`` of symmetric matrices.  The vectors `subi`, `subj`, and
`valij` contains the row subscripts, column subscripts and values of each
element in the symmetric matrix to be appended.  Since the matrix that is
appended is symmetric, only the lower triangular part should be specified.
Moreover, duplicates are not allowed.

Observe the function reports the index (position) of the appended matrix in
``E``. This index should be used for later references to the appended matrix.
"""
function appendsparsesymmat end
appendsparsesymmat(task:: MSKtask,dim:: T1,subi:: Vector{T2},subj:: Vector{T3},valij:: Vector{T4}) where {T1,T2,T3,T4} = appendsparsesymmat(task,convert(Int32,dim),convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Float64},valij))
function appendsparsesymmat(task:: MSKtask,dim:: T1,data:: SparseMatrixCSC{Float64}) where {T1}
  subi,subj,valij = tril(data)
  appendsparsesymmat(task,dim,subi,subj,valij)
end
function appendsparsesymmat(task_:: MSKtask,dim_:: Int32,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})
  idx_ = Ref(Int64(1))
  nz_ = minimum([ length(subi_),length(subj_),length(valij_) ])
  res = disable_sigint() do
    @MSK_appendsparsesymmat(task_.task,dim_,nz_,subi_ .- Int32(1),subj_ .- Int32(1),valij_,idx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,idx_.x+1))
end

"""
    idx = appendsparsesymmatlist{T1,T2,T3,T4,T5}(task:: MSKtask,dims:: Vector{T1},nz:: Vector{T2},subi:: Vector{T3},subj:: Vector{T4},valij:: Vector{T5})
    idx = appendsparsesymmatlist(task_:: MSKtask,dims_:: Vector{Int32},nz_:: Vector{Int64},subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `dims :: Vector{Int32}`. Dimensions of the symmetric matrixes.
* `nz :: Vector{Int64}`. Number of nonzeros for each matrix.
* `subi :: Vector{Int32}`. Row subscript in the triplets.
* `subj :: Vector{Int32}`. Column subscripts in the triplets.
* `valij :: Vector{Float64}`. Values of each triplet.
* `idx :: Vector{Int64}`. Unique index assigned to the inputted matrix.

MOSEK maintains a storage of symmetric data matrices that is used to build
``\\bar C`` and ``\\bar A``. The storage can be thought of as a vector of
symmetric matrices denoted ``E``. Hence, ``E_i`` is a symmetric matrix of certain
dimension.

This function appends general sparse symmetric matrixes on triplet form to the
vector ``E`` of symmetric matrices.  The vectors `subi`, `subj`, and
`valij` contains the row subscripts, column subscripts and values of each
element in the symmetric matrix to be appended.  Since the matrix that is
appended is symmetric, only the lower triangular part should be specified.
Moreover, duplicates are not allowed.

Observe the function reports the index (position) of the appended matrix in
``E``. This index should be used for later references to the appended matrix.
"""
function appendsparsesymmatlist end
appendsparsesymmatlist(task:: MSKtask,dims:: Vector{T1},nz:: Vector{T2},subi:: Vector{T3},subj:: Vector{T4},valij:: Vector{T5}) where {T1,T2,T3,T4,T5} = appendsparsesymmatlist(task,convert(Vector{Int32},dims),convert(Vector{Int64},nz),convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Float64},valij))
function appendsparsesymmatlist(task_:: MSKtask,dims_:: Vector{Int32},nz_:: Vector{Int64},subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})
  num_ = minimum([ length(dims_),length(nz_) ])
  __tmp_var_0 = sum((nz_))
  if length(subi_) < __tmp_var_0
    println("Array argument subi is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = sum((nz_))
  if length(subj_) < __tmp_var_1
    println("Array argument subj is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = sum((nz_))
  if length(valij_) < __tmp_var_2
    println("Array argument valij is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = (num_)
  __tmp_var_4 = zeros(Int64,__tmp_var_3)
  idx_ = __tmp_var_4
  res = disable_sigint() do
    @MSK_appendsparsesymmatlist(task_.task,num_,dims_,nz_,subi_ .- Int32(1),subj_ .- Int32(1),valij_,__tmp_var_4)
  end
  __tmp_var_4 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_4)
end

"""
    appendvars{T1}(task:: MSKtask,num:: T1)
    appendvars(task_:: MSKtask,num_:: Int32)

* `task :: MSKtask`. An optimization task.
* `num :: Int32`. Number of variables which should be appended.

Appends a number of variables to the model. Appended
variables will be fixed at zero. Please note that
MOSEK will automatically expand the problem
dimension to accommodate the additional variables.
"""
function appendvars end
appendvars(task:: MSKtask,num:: T1) where {T1} = appendvars(task,convert(Int32,num))
function appendvars(task_:: MSKtask,num_:: Int32)
  res = disable_sigint() do
    @MSK_appendvars(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    (nrmbasis,nrminvbasis) = basiscond(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `nrmbasis :: Float64`. An estimate for the 1-norm of the basis.
* `nrminvbasis :: Float64`. An estimate for the 1-norm of the inverse of the basis.

If a basic solution is available and it defines a nonsingular basis, then
this function computes the 1-norm estimate of the basis matrix and a 1-norm estimate
for the inverse of the basis matrix. The 1-norm estimates are computed using the method
outlined in :cite:`STEWART:98:A`, pp. 388-391.

By definition the 1-norm condition number of a matrix ``B`` is defined as

```math
 \\kappa_1(B) := \\|B\\|_1 \\|B^{-1}\\|_1.
```
Moreover, the larger the condition number is the harder it is to solve
linear equation systems involving ``B``.  Given estimates for
``\\|B\\|_1`` and ``\\|B^{-1}\\|_1`` it is also possible to
estimate ``\\kappa_1(B)``.
"""
function basiscond end
function basiscond(task_:: MSKtask)
  nrmbasis_ = Ref(Float64(1))
  nrminvbasis_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_basiscond(task_.task,nrmbasis_,nrminvbasis_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,nrmbasis_.x),convert(Float64,nrminvbasis_.x))
end

"""
    str = bktostr(task_:: MSKtask,bk_:: Boundkey)

* `task :: MSKtask`. An optimization task.
* `bk :: Boundkey`. Bound key.
* `str :: AbstractString`. String corresponding to the bound key.

Obtains an identifier string corresponding to a bound key.
"""
function bktostr end
function bktostr(task_:: MSKtask,bk_:: Boundkey)
  str_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @MSK_bktostr(task_.task,bk_.value,str_)
  end
  str_str = String(str_[1:findfirst(isequal(0),str_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (str_str)
end

"""
    callbackcodestr = callbackcodetostr(code_:: Callbackcode)

* `code :: Callbackcode`. A callback code.
* `callbackcodestr :: AbstractString`. String corresponding to the callback code.

Obtains the string representation of a callback code.
"""
function callbackcodetostr end
function callbackcodetostr(code_:: Callbackcode)
  callbackcodestr_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @MSK_callbackcodetostr(code_.value,callbackcodestr_)
  end
  callbackcodestr_str = String(callbackcodestr_[1:findfirst(isequal(0),callbackcodestr_)-1])
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
  (callbackcodestr_str)
end

"""
    checkinall(env_:: MSKenv)

* `env :: MSKenv`. The MOSEK environment.

Check in all unused license features to the license token server.
"""
function checkinall end
function checkinall(env_:: MSKenv)
  res = disable_sigint() do
    @MSK_checkinall(env_.env)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    checkinlicense(env_:: MSKenv,feature_:: Feature)

* `env :: MSKenv`. The MOSEK environment.
* `feature :: Feature`. Feature to check in to the license system.

Check in a license feature to the license server. By default all licenses
consumed by functions using a single environment are kept checked out for the
lifetime of the MOSEK environment. This function checks in a given license
feature back to the license server immediately.

If the given license feature is not checked out at all, or it is in use by a call to
`Mosek.optimize`, calling this function has no effect.

Please note that returning a license to the license server incurs a small
overhead, so frequent calls to this function should be avoided.
"""
function checkinlicense end
function checkinlicense(env_:: MSKenv,feature_:: Feature)
  res = disable_sigint() do
    @MSK_checkinlicense(env_.env,feature_.value)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    checkmem{T2}(task:: MSKtask,file:: AbstractString,line:: T2)
    checkmem(task_:: MSKtask,file_:: AbstractString,line_:: Int32)

* `task :: MSKtask`. An optimization task.
* `file :: String`. File from which the function is called.
* `line :: Int32`. Line in the file from which the function is called.

Checks the memory allocated by the task.
"""
function checkmem end
checkmem(task:: MSKtask,file:: AbstractString,line:: T2) where {T2} = checkmem(task,file,convert(Int32,line))
function checkmem(task_:: MSKtask,file_:: AbstractString,line_:: Int32)
  res = disable_sigint() do
    @MSK_checkmemtask(task_.task,string(file_),line_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    checkoutlicense(env_:: MSKenv,feature_:: Feature)

* `env :: MSKenv`. The MOSEK environment.
* `feature :: Feature`. Feature to check out from the license system.

Checks out a license feature from the license server. Normally the required
license features will be automatically checked out the first time they are needed
by the function `Mosek.optimize`. This function can be used to check out one
or more features ahead of time.

The feature will remain checked out until the environment is deleted or the function
`Mosek.checkinlicense` is called.

If a given feature is already checked out when this function is called, the call has no effect.
"""
function checkoutlicense end
function checkoutlicense(env_:: MSKenv,feature_:: Feature)
  res = disable_sigint() do
    @MSK_checkoutlicense(env_.env,feature_.value)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    chgconbound{T1,T2,T3,T4}(task:: MSKtask,i:: T1,lower:: T2,finite:: T3,value:: T4)
    chgconbound(task_:: MSKtask,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint for which the bounds should be changed.
* `lower :: Int32`. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
* `finite :: Int32`. If non-zero, then the given value is assumed to be finite.
* `value :: Float64`. New value for the bound.

Changes a bound for one constraint.

If `lower` is non-zero, then the lower bound is changed as follows:

```math
\\mbox{new lower bound} =
  \\left\\{
    \\begin{array}{ll}
      - \\infty,       & \\mathtt{finite}=0, \\\\
      \\mathtt{value}  & \\mbox{otherwise}.
    \\end{array}
  \\right.
```
Otherwise if `lower` is zero, then

```math
\\mbox{new upper bound} =
  \\left\\{
    \\begin{array}{ll}
      \\infty,        & \\mathtt{finite}=0, \\\\
      \\mathtt{value} & \\mbox{otherwise}.
    \\end{array}
  \\right.
```
Please note that this function automatically updates the bound key for the
bound, in particular, if the lower and upper bounds are identical, the
bound key is changed to `fixed`.
"""
function chgconbound end
chgconbound(task:: MSKtask,i:: T1,lower:: T2,finite:: T3,value:: T4) where {T1,T2,T3,T4} = chgconbound(task,convert(Int32,i),convert(Int32,lower),convert(Int32,finite),convert(Float64,value))
function chgconbound(task_:: MSKtask,i_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)
  res = disable_sigint() do
    @MSK_chgconbound(task_.task,i_-1,lower_,finite_,value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    chgvarbound{T1,T2,T3,T4}(task:: MSKtask,j:: T1,lower:: T2,finite:: T3,value:: T4)
    chgvarbound(task_:: MSKtask,j_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable for which the bounds should be changed.
* `lower :: Int32`. If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
* `finite :: Int32`. If non-zero, then the given value is assumed to be finite.
* `value :: Float64`. New value for the bound.

Changes a bound for one variable.

If `lower` is non-zero, then the lower bound is changed as follows:

```math
\\mbox{new lower bound} =
  \\left\\{
    \\begin{array}{ll}
      - \\infty,     & \\mathtt{finite}=0, \\\\
      \\mathtt{value} & \\mbox{otherwise}.
    \\end{array}
  \\right.
```
Otherwise if `lower` is zero, then

```math
\\mbox{new upper bound} =
  \\left\\{
    \\begin{array}{ll}
      \\infty,     & \\mathtt{finite}=0, \\\\
      \\mathtt{value} & \\mbox{otherwise}.
    \\end{array}
  \\right.
```
Please note that this function automatically updates the bound key for the bound,
in particular, if the lower and upper bounds are identical, the bound key is
changed to `fixed`.
"""
function chgvarbound end
chgvarbound(task:: MSKtask,j:: T1,lower:: T2,finite:: T3,value:: T4) where {T1,T2,T3,T4} = chgvarbound(task,convert(Int32,j),convert(Int32,lower),convert(Int32,finite),convert(Float64,value))
function chgvarbound(task_:: MSKtask,j_:: Int32,lower_:: Int32,finite_:: Int32,value_:: Float64)
  res = disable_sigint() do
    @MSK_chgvarbound(task_.task,j_-1,lower_,finite_,value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    commitchanges(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

Commits all cached problem changes to the task. It is usually not necessary to call this function explicitly since changes will be committed automatically when required.
"""
function commitchanges end
function commitchanges(task_:: MSKtask)
  res = disable_sigint() do
    @MSK_commitchanges(task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    str = conetypetostr(task_:: MSKtask,ct_:: Conetype)

* `task :: MSKtask`. An optimization task.
* `ct :: Conetype`. Specifies the type of the cone.
* `str :: AbstractString`. String corresponding to the cone type.

Deprecated in MOSEK 10

Obtains the cone string identifier corresponding to a cone type.
"""
function conetypetostr end
function conetypetostr(task_:: MSKtask,ct_:: Conetype)
  str_ = zeros(UInt8,1024+1)
  res = disable_sigint() do
    @MSK_conetypetostr(task_.task,ct_.value,str_)
  end
  str_str = String(str_[1:findfirst(isequal(0),str_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (str_str)
end

"""
    deletesolution(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.

Undefine a solution and free the memory it uses.
"""
function deletesolution end
function deletesolution(task_:: MSKtask,whichsol_:: Soltype)
  res = disable_sigint() do
    @MSK_deletesolution(task_.task,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    (leftpricej,rightpricej,leftrangej,rightrangej) = dualsensitivity{T1}(task:: MSKtask,subj:: Vector{T1})
    (leftpricej,rightpricej,leftrangej,rightrangej) = dualsensitivity(task_:: MSKtask,subj_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. Indexes of objective coefficients to analyze.
* `leftpricej :: Vector{Float64}`. Left shadow prices for requested coefficients.
* `rightpricej :: Vector{Float64}`. Right shadow prices for requested coefficients.
* `leftrangej :: Vector{Float64}`. Left range for requested coefficients.
* `rightrangej :: Vector{Float64}`. Right range for requested coefficients.

Calculates sensitivity information for objective coefficients. The indexes of the coefficients to analyze are

```math
 \\{\\mathtt{subj}[i] ~|~ i = 0,\\ldots,\\mathtt{numj}-1\\}
```
The type of sensitivity analysis to perform (basis or optimal partition) is controlled by the parameter `MSK_IPAR_SENSITIVITY_TYPE``.

For an example, please see Section :ref:`doc.shared.sensitivity_example`.
"""
function dualsensitivity end
dualsensitivity(task:: MSKtask,subj:: Vector{T1}) where {T1} = dualsensitivity(task,convert(Vector{Int32},subj))
function dualsensitivity(task_:: MSKtask,subj_:: Vector{Int32})
  numj_ = minimum([ length(subj_) ])
  __tmp_var_0 = (numj_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  leftpricej_ = __tmp_var_1
  __tmp_var_4 = (numj_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  leftrangej_ = __tmp_var_5
  __tmp_var_2 = (numj_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  rightpricej_ = __tmp_var_3
  __tmp_var_6 = (numj_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  rightrangej_ = __tmp_var_7
  res = disable_sigint() do
    @MSK_dualsensitivity(task_.task,numj_,subj_ .- Int32(1),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    echointro{T1}(env:: MSKenv,longver:: T1)
    echointro(env_:: MSKenv,longver_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `longver :: Int32`. If non-zero, then the intro is slightly longer.

Prints an intro to message stream.
"""
function echointro end
echointro(env:: MSKenv,longver:: T1) where {T1} = echointro(env,convert(Int32,longver))
function echointro(env_:: MSKenv,longver_:: Int32)
  res = disable_sigint() do
    @MSK_echointro(env_.env,longver_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    emptyafebarfrow{T1}(task:: MSKtask,afeidx:: T1)
    emptyafebarfrow(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index of barF.

Clears a row in ``\\barF`` i.e. sets ``\\barF_{\\mathrm{afeidx},*} = 0``.
"""
function emptyafebarfrow end
emptyafebarfrow(task:: MSKtask,afeidx:: T1) where {T1} = emptyafebarfrow(task,convert(Int64,afeidx))
function emptyafebarfrow(task_:: MSKtask,afeidx_:: Int64)
  res = disable_sigint() do
    @MSK_emptyafebarfrow(task_.task,afeidx_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    emptyafebarfrowlist{T1}(task:: MSKtask,afeidxlist:: Vector{T1})
    emptyafebarfrowlist(task_:: MSKtask,afeidxlist_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `afeidxlist :: Vector{Int64}`. Indices of rows in barF to clear.

Clears a number of rows in ``\\barF`` i.e. sets ``\\barF_{i,*} = 0`` for all indices ``i`` in `afeidxlist`.
"""
function emptyafebarfrowlist end
emptyafebarfrowlist(task:: MSKtask,afeidxlist:: Vector{T1}) where {T1} = emptyafebarfrowlist(task,convert(Vector{Int64},afeidxlist))
function emptyafebarfrowlist(task_:: MSKtask,afeidxlist_:: Vector{Int64})
  numafeidx_ = minimum([ length(afeidxlist_) ])
  res = disable_sigint() do
    @MSK_emptyafebarfrowlist(task_.task,numafeidx_,afeidxlist_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    emptyafefcol{T1}(task:: MSKtask,j:: T1)
    emptyafefcol(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Variable index.

Clears one column in the affine constraint matrix ``F``, that is sets ``F_{*,j}=0``.
"""
function emptyafefcol end
emptyafefcol(task:: MSKtask,j:: T1) where {T1} = emptyafefcol(task,convert(Int32,j))
function emptyafefcol(task_:: MSKtask,j_:: Int32)
  res = disable_sigint() do
    @MSK_emptyafefcol(task_.task,j_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    emptyafefcollist{T1}(task:: MSKtask,varidxlist:: Vector{T1})
    emptyafefcollist(task_:: MSKtask,varidxlist_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `varidxlist :: Vector{Int32}`. Indices of variables in F to clear.

Clears a number of columns in ``F`` i.e. sets ``F_{*,j} = 0`` for all indices ``j`` in `varidxlist`.
"""
function emptyafefcollist end
emptyafefcollist(task:: MSKtask,varidxlist:: Vector{T1}) where {T1} = emptyafefcollist(task,convert(Vector{Int32},varidxlist))
function emptyafefcollist(task_:: MSKtask,varidxlist_:: Vector{Int32})
  numvaridx_ = minimum([ length(varidxlist_) ])
  res = disable_sigint() do
    @MSK_emptyafefcollist(task_.task,numvaridx_,varidxlist_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    emptyafefrow{T1}(task:: MSKtask,afeidx:: T1)
    emptyafefrow(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index.

Clears one row in the affine constraint matrix ``F``, that is sets ``F_{\\mathrm{afeidx},*}=0``.
"""
function emptyafefrow end
emptyafefrow(task:: MSKtask,afeidx:: T1) where {T1} = emptyafefrow(task,convert(Int64,afeidx))
function emptyafefrow(task_:: MSKtask,afeidx_:: Int64)
  res = disable_sigint() do
    @MSK_emptyafefrow(task_.task,afeidx_-1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    emptyafefrowlist{T1}(task:: MSKtask,afeidxlist:: Vector{T1})
    emptyafefrowlist(task_:: MSKtask,afeidxlist_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `afeidxlist :: Vector{Int64}`. Indices of rows in F to clear.

Clears a number of rows in ``F`` i.e. sets ``F_{i,*} = 0`` for all indices ``i`` in `afeidxlist`.
"""
function emptyafefrowlist end
emptyafefrowlist(task:: MSKtask,afeidxlist:: Vector{T1}) where {T1} = emptyafefrowlist(task,convert(Vector{Int64},afeidxlist))
function emptyafefrowlist(task_:: MSKtask,afeidxlist_:: Vector{Int64})
  numafeidx_ = minimum([ length(afeidxlist_) ])
  res = disable_sigint() do
    @MSK_emptyafefrowlist(task_.task,numafeidx_,afeidxlist_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    activity = evaluateacc{T2}(task:: MSKtask,whichsol:: Soltype,accidx:: T2)
    activity = evaluateacc(task_:: MSKtask,whichsol_:: Soltype,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `accidx :: Int64`. The index of the affine conic constraint.
* `activity :: Vector{Float64}`. The activity of the affine conic constraint. The array should have length equal to the dimension of the constraint.

Evaluates the activity of an affine conic constraint.
"""
function evaluateacc end
evaluateacc(task:: MSKtask,whichsol:: Soltype,accidx:: T2) where {T2} = evaluateacc(task,whichsol,convert(Int64,accidx))
function evaluateacc(task_:: MSKtask,whichsol_:: Soltype,accidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_evaluateacc_0 = Ref{Int64}(); @MSK_getaccn(task_.task,(accidx_),__tmp_var_evaluateacc_0); __tmp_var_evaluateacc_0.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  activity_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_evaluateacc(task_.task,whichsol_.value,accidx_,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    activity = evaluateaccs(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `activity :: Vector{Float64}`. The activity of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.

Evaluates the activities of all affine conic constraints.
"""
function evaluateaccs end
function evaluateaccs(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = begin __tmp_var_evaluateaccs_0 = Ref{Int64}(); @MSK_getaccntot(task_.task,__tmp_var_evaluateaccs_0); __tmp_var_evaluateaccs_0.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  activity_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_evaluateaccs(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    generateaccnames{T1,T3}(task:: MSKtask,sub:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3})
    generateaccnames(task_:: MSKtask,sub_:: Vector{Int64},fmt_:: AbstractString,dims_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int64}`. Indexes of the affine conic constraints.
* `fmt :: String`. The variable name formatting string.
* `dims :: Vector{Int32}`. Dimensions in the shape.

Internal.
"""
function generateaccnames end
generateaccnames(task:: MSKtask,sub:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3}) where {T1,T3} = generateaccnames(task,convert(Vector{Int64},sub),fmt,convert(Vector{Int32},dims))
function generateaccnames(task_:: MSKtask,sub_:: Vector{Int64},fmt_:: AbstractString,dims_:: Vector{Int32})
  ndims_ = minimum([ length(dims_) ])
  num_ = minimum([ length(sub_) ])
  res = disable_sigint() do
    @MSK_generateaccnames(task_.task,num_,sub_ .- Int32(1),string(fmt_),ndims_,dims_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    generateconenames{T1,T3,T4}(task:: MSKtask,subk:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3},sp:: Vector{T4})
    generateconenames(task_:: MSKtask,subk_:: Vector{Int32},fmt_:: AbstractString,dims_:: Vector{Int32},sp_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `subk :: Vector{Int32}`. Indexes of the cone.
* `fmt :: String`. The cone name formatting string.
* `dims :: Vector{Int32}`. Dimensions in the shape.
* `sp :: Vector{Int64}`. Items that should be named.

Internal, deprecated.
"""
function generateconenames end
generateconenames(task:: MSKtask,subk:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3},sp:: Vector{T4}) where {T1,T3,T4} = generateconenames(task,convert(Vector{Int32},subk),fmt,convert(Vector{Int32},dims),convert(Vector{Int64},sp))
function generateconenames(task_:: MSKtask,subk_:: Vector{Int32},fmt_:: AbstractString,dims_:: Vector{Int32},sp_:: Vector{Int64})
  ndims_ = minimum([ length(dims_) ])
  num_ = minimum([ length(subk_) ])
  __tmp_var_0 = (num_)
  if length(sp_) < __tmp_var_0
    println("Array argument sp is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_generateconenames(task_.task,num_,subk_ .- Int32(1),string(fmt_),ndims_,dims_,sp_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    generateconnames{T1,T3,T4}(task:: MSKtask,subi:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3},sp:: Vector{T4})
    generateconnames(task_:: MSKtask,subi_:: Vector{Int32},fmt_:: AbstractString,dims_:: Vector{Int32},sp_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Indexes of the constraints.
* `fmt :: String`. The constraint name formatting string.
* `dims :: Vector{Int32}`. Dimensions in the shape.
* `sp :: Vector{Int64}`. Items that should be named.

Generates systematic names for constraints.
"""
function generateconnames end
generateconnames(task:: MSKtask,subi:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3},sp:: Vector{T4}) where {T1,T3,T4} = generateconnames(task,convert(Vector{Int32},subi),fmt,convert(Vector{Int32},dims),convert(Vector{Int64},sp))
function generateconnames(task_:: MSKtask,subi_:: Vector{Int32},fmt_:: AbstractString,dims_:: Vector{Int32},sp_:: Vector{Int64})
  ndims_ = minimum([ length(dims_) ])
  num_ = minimum([ length(subi_) ])
  __tmp_var_0 = (num_)
  if length(sp_) < __tmp_var_0
    println("Array argument sp is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_generateconnames(task_.task,num_,subi_ .- Int32(1),string(fmt_),ndims_,dims_,sp_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    generatevarnames{T1,T3,T4}(task:: MSKtask,subj:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3},sp:: Vector{T4})
    generatevarnames(task_:: MSKtask,subj_:: Vector{Int32},fmt_:: AbstractString,dims_:: Vector{Int32},sp_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. Indexes of the variables.
* `fmt :: String`. The variable name formatting string.
* `dims :: Vector{Int32}`. Dimensions in the shape.
* `sp :: Vector{Int64}`. Items that should be named.

Generates systematic names for variables.
"""
function generatevarnames end
generatevarnames(task:: MSKtask,subj:: Vector{T1},fmt:: AbstractString,dims:: Vector{T3},sp:: Vector{T4}) where {T1,T3,T4} = generatevarnames(task,convert(Vector{Int32},subj),fmt,convert(Vector{Int32},dims),convert(Vector{Int64},sp))
function generatevarnames(task_:: MSKtask,subj_:: Vector{Int32},fmt_:: AbstractString,dims_:: Vector{Int32},sp_:: Vector{Int64})
  ndims_ = minimum([ length(dims_) ])
  num_ = minimum([ length(subj_) ])
  __tmp_var_0 = (num_)
  if length(sp_) < __tmp_var_0
    println("Array argument sp is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_generatevarnames(task_.task,num_,subj_ .- Int32(1),string(fmt_),ndims_,dims_,sp_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    afeidxlist = getaccafeidxlist{T1}(task:: MSKtask,accidx:: T1)
    afeidxlist = getaccafeidxlist(task_:: MSKtask,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Index of the affine conic constraint.
* `afeidxlist :: Vector{Int64}`. List of indexes of affine expressions appearing in the constraint.

Obtains the list of affine expressions appearing in the affine conic constraint.
"""
function getaccafeidxlist end
getaccafeidxlist(task:: MSKtask,accidx:: T1) where {T1} = getaccafeidxlist(task,convert(Int64,accidx))
function getaccafeidxlist(task_:: MSKtask,accidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getaccafeidxlist_0 = Ref{Int64}(); @MSK_getaccn(task_.task,(accidx_-1),__tmp_var_getaccafeidxlist_0); __tmp_var_getaccafeidxlist_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  afeidxlist_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getaccafeidxlist(task_.task,accidx_-1,__tmp_var_1)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    b = getaccb{T1}(task:: MSKtask,accidx:: T1)
    b = getaccb(task_:: MSKtask,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Index of the affine conic constraint.
* `b :: Vector{Float64}`. The vector b appearing in the constraint.

Obtains the additional constant term vector appearing in the affine conic constraint.
"""
function getaccb end
getaccb(task:: MSKtask,accidx:: T1) where {T1} = getaccb(task,convert(Int64,accidx))
function getaccb(task_:: MSKtask,accidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getaccb_0 = Ref{Int64}(); @MSK_getaccn(task_.task,(accidx_-1),__tmp_var_getaccb_0); __tmp_var_getaccb_0.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  b_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getaccb(task_.task,accidx_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    domidx = getaccdomain{T1}(task:: MSKtask,accidx:: T1)
    domidx = getaccdomain(task_:: MSKtask,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. The index of the affine conic constraint.
* `domidx :: Int64`. The index of domain in the affine conic constraint.

Obtains the domain appearing in the affine conic constraint.
"""
function getaccdomain end
getaccdomain(task:: MSKtask,accidx:: T1) where {T1} = getaccdomain(task,convert(Int64,accidx))
function getaccdomain(task_:: MSKtask,accidx_:: Int64)
  domidx_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getaccdomain(task_.task,accidx_-1,domidx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,domidx_.x+1))
end

"""
    doty = getaccdoty{T2}(task:: MSKtask,whichsol:: Soltype,accidx:: T2)
    doty = getaccdoty(task_:: MSKtask,whichsol_:: Soltype,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `accidx :: Int64`. The index of the affine conic constraint.
* `doty :: Vector{Float64}`. The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.

Obtains the ``\\dot{y}`` vector for a solution (the dual values of an affine conic constraint).
"""
function getaccdoty end
getaccdoty(task:: MSKtask,whichsol:: Soltype,accidx:: T2) where {T2} = getaccdoty(task,whichsol,convert(Int64,accidx))
function getaccdoty(task_:: MSKtask,whichsol_:: Soltype,accidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getaccdoty_0 = Ref{Int64}(); @MSK_getaccn(task_.task,(accidx_),__tmp_var_getaccdoty_0); __tmp_var_getaccdoty_0.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  doty_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getaccdoty(task_.task,whichsol_.value,accidx_,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    n = getaccn{T1}(task:: MSKtask,accidx:: T1)
    n = getaccn(task_:: MSKtask,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. The index of the affine conic constraint.
* `n :: Int64`. The dimension of the affine conic constraint (equal to the dimension of its domain).

Obtains the dimension of the affine conic constraint.
"""
function getaccn end
getaccn(task:: MSKtask,accidx:: T1) where {T1} = getaccn(task,convert(Int64,accidx))
function getaccn(task_:: MSKtask,accidx_:: Int64)
  n_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getaccn(task_.task,accidx_-1,n_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,n_.x))
end

"""
    name = getaccname{T1}(task:: MSKtask,accidx:: T1)
    name = getaccname(task_:: MSKtask,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Index of an affine conic constraint.
* `name :: AbstractString`. Returns the required name.

Obtains the name of an affine conic constraint.
"""
function getaccname end
getaccname(task:: MSKtask,accidx:: T1) where {T1} = getaccname(task,convert(Int64,accidx))
function getaccname(task_:: MSKtask,accidx_:: Int64)
  sizename_ = (1 + begin __tmp_var_getaccname_0 = Ref{Int32}(); @MSK_getaccnamelen(task_.task,(accidx_-1),__tmp_var_getaccname_0); __tmp_var_getaccname_0.x end)
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getaccname(task_.task,accidx_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    len = getaccnamelen{T1}(task:: MSKtask,accidx:: T1)
    len = getaccnamelen(task_:: MSKtask,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Index of an affine conic constraint.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of an affine conic constraint.
"""
function getaccnamelen end
getaccnamelen(task:: MSKtask,accidx:: T1) where {T1} = getaccnamelen(task,convert(Int64,accidx))
function getaccnamelen(task_:: MSKtask,accidx_:: Int64)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getaccnamelen(task_.task,accidx_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    n = getaccntot(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `n :: Int64`. The total dimension of all affine conic constraints.

Obtains the total dimension of all affine conic constraints (the sum of all their dimensions).
"""
function getaccntot end
function getaccntot(task_:: MSKtask)
  n_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getaccntot(task_.task,n_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,n_.x))
end

"""
    (domidxlist,afeidxlist,b) = getaccs(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `domidxlist :: Vector{Int64}`. The list of domains appearing in all affine conic constraints.
* `afeidxlist :: Vector{Int64}`. The concatenation of index lists of affine expressions appearing in all affine conic constraints.
* `b :: Vector{Float64}`. The concatenation of vectors b appearing in all affine conic constraints.

Obtains full data of all affine conic constraints. The output array `domainidxlist` must have at least length determined by `Mosek.getnumacc`. The output arrays `afeidxlist` and `b` must have at least length determined by `Mosek.getaccntot`.
"""
function getaccs end
function getaccs(task_:: MSKtask)
  __tmp_var_2 = begin __tmp_var_getaccs_0 = Ref{Int64}(); @MSK_getaccntot(task_.task,__tmp_var_getaccs_0); __tmp_var_getaccs_0.x end
  __tmp_var_3 = zeros(Int64,__tmp_var_2)
  afeidxlist_ = __tmp_var_3
  __tmp_var_4 = begin __tmp_var_getaccs_0 = Ref{Int64}(); @MSK_getaccntot(task_.task,__tmp_var_getaccs_0); __tmp_var_getaccs_0.x end
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  b_ = __tmp_var_5
  __tmp_var_0 = begin __tmp_var_getaccs_0 = Ref{Int64}(); @MSK_getnumacc(task_.task,__tmp_var_getaccs_0); __tmp_var_getaccs_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  domidxlist_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getaccs(task_.task,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    (nzj,subj,valj) = getacol{T1}(task:: MSKtask,j:: T1)
    (nzj,subj,valj) = getacol(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the column.
* `nzj :: Int32`. Number of non-zeros in the column obtained.
* `subj :: Vector{Int32}`. Row indices of the non-zeros in the column obtained.
* `valj :: Vector{Float64}`. Numerical values in the column obtained.

Obtains one column of ``A`` in a sparse format.
"""
function getacol end
getacol(task:: MSKtask,j:: T1) where {T1} = getacol(task,convert(Int32,j))
function getacol(task_:: MSKtask,j_:: Int32)
  nzj_ = Ref(Int32(1))
  __tmp_var_0 = getacolnumnz(task_,(j_))
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subj_ = __tmp_var_1
  __tmp_var_2 = getacolnumnz(task_,(j_))
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  valj_ = __tmp_var_3
  res = disable_sigint() do
    @MSK_getacol(task_.task,j_-1,nzj_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzj_.x),__tmp_var_1,__tmp_var_3)
end

"""
    nzj = getacolnumnz{T1}(task:: MSKtask,i:: T1)
    nzj = getacolnumnz(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the column.
* `nzj :: Int32`. Number of non-zeros in the j'th column of (A).

Obtains the number of non-zero elements in one column of ``A``.
"""
function getacolnumnz end
getacolnumnz(task:: MSKtask,i:: T1) where {T1} = getacolnumnz(task,convert(Int32,i))
function getacolnumnz(task_:: MSKtask,i_:: Int32)
  nzj_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getacolnumnz(task_.task,i_-1,nzj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzj_.x))
end

"""
    (ptrb,ptre,sub,val) = getacolslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (ptrb,ptre,sub,val) = getacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first column in the sequence.
* `last :: Int32`. Index of the last column in the sequence plus one.
* `ptrb :: Vector{Int64}`. Column start pointers.
* `ptre :: Vector{Int64}`. Column end pointers.
* `sub :: Vector{Int32}`. Contains the row subscripts.
* `val :: Vector{Float64}`. Contains the coefficient values.

Obtains a sequence of columns from ``A`` in sparse format.
"""
function getacolslice end
getacolslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getacolslice(task,convert(Int32,first),convert(Int32,last))
function getacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  maxnumnz_ = getacolslicenumnz(task_,(first_),(last_))
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  ptrb_ = __tmp_var_1
  __tmp_var_2 = ((last_) - (first_))
  __tmp_var_3 = zeros(Int64,__tmp_var_2)
  ptre_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  sub_ = __tmp_var_5
  __tmp_var_6 = (maxnumnz_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  val_ = __tmp_var_7
  surp_ = convert(Int64,length(sub_))
  res = disable_sigint() do
    @MSK_getacolslice64(task_.task,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  __tmp_var_5 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    numnz = getacolslicenumnz{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    numnz = getacolslicenumnz(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first column in the sequence.
* `last :: Int32`. Index of the last column plus one in the sequence.
* `numnz :: Int64`. Number of non-zeros in the slice.

Obtains the number of non-zeros in a slice of columns of ``A``.
"""
function getacolslicenumnz end
getacolslicenumnz(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getacolslicenumnz(task,convert(Int32,first),convert(Int32,last))
function getacolslicenumnz(task_:: MSKtask,first_:: Int32,last_:: Int32)
  numnz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getacolslicenumnz64(task_.task,first_-1,last_-1,numnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_.x))
end

"""
    (subi,subj,val) = getacolslicetrip{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (subi,subj,val) = getacolslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first column in the sequence.
* `last :: Int32`. Index of the last column in the sequence plus one.
* `subi :: Vector{Int32}`. Constraint subscripts.
* `subj :: Vector{Int32}`. Column subscripts.
* `val :: Vector{Float64}`. Values.

Obtains a sequence of columns from ``A`` in sparse triplet format. The function returns the content of all columns whose index `j` satisfies `first <= j < last`. The triplets corresponding to nonzero entries are stored in the arrays `subi`, `subj` and `val`.
"""
function getacolslicetrip end
getacolslicetrip(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getacolslicetrip(task,convert(Int32,first),convert(Int32,last))
function getacolslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)
  maxnumnz_ = getacolslicenumnz(task_,(first_),(last_))
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxnumnz_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  val_ = __tmp_var_5
  surp_ = convert(Int64,length(subi_))
  res = disable_sigint() do
    @MSK_getacolslicetrip(task_.task,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    numentries = getafebarfnumrowentries{T1}(task:: MSKtask,afeidx:: T1)
    numentries = getafebarfnumrowentries(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index of barF.
* `numentries :: Int32`. Number of nonzero entries in a row of barF.

Obtains the number of nonzero entries in one row of ``\\barF``, that is the number of ``j`` such that ``\\barF_{\\mathrm{afeidx},j}`` is not the zero matrix.
"""
function getafebarfnumrowentries end
getafebarfnumrowentries(task:: MSKtask,afeidx:: T1) where {T1} = getafebarfnumrowentries(task,convert(Int64,afeidx))
function getafebarfnumrowentries(task_:: MSKtask,afeidx_:: Int64)
  numentries_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getafebarfnumrowentries(task_.task,afeidx_-1,numentries_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numentries_.x))
end

"""
    (barvaridx,termptr,numterms,termidx,termweight) = getafebarfrow{T1}(task:: MSKtask,afeidx:: T1)
    (barvaridx,termptr,numterms,termidx,termweight) = getafebarfrow(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index of barF.
* `barvaridx :: Vector{Int32}`. Semidefinite variable indices.
* `termptr :: Vector{Int64}`. Pointers to the description of entries.
* `numterms :: Vector{Int64}`. Number of terms in each entry.
* `termidx :: Vector{Int64}`. Indices of semidefinite matrices from E.
* `termweight :: Vector{Float64}`. Weights appearing in the weighted sum representation.

Obtains all nonzero entries in one row ``\\barF_{\\mathrm{afeidx},*}`` of ``\\barF``. For every ``k`` there is a nonzero entry ``\\barF_{\\mathrm{afeidx}, \\mathrm{barvaridx}[k]}``, which is represented as a weighted sum of ``\\mathrm{numterms}[k]`` terms. The indices in the matrix store ``E`` and their weights for the ``k``-th entry appear in the arrays `termidx` and `termweight` in positions

```math
 \\mathrm{termptr}[k],\\ldots,\\mathrm{termptr}[k]+\\mathrm{numterms}[k]-1.
```
The arrays should be long enough to accommodate the data; their required lengths can be obtained with `Mosek.getafebarfrowinfo`.
"""
function getafebarfrow end
getafebarfrow(task:: MSKtask,afeidx:: T1) where {T1} = getafebarfrow(task,convert(Int64,afeidx))
function getafebarfrow(task_:: MSKtask,afeidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getafebarfrow_0 = Ref{Int32}(); __tmp_var_getafebarfrow_1 = Ref{Int64}(); @MSK_getafebarfrowinfo(task_.task,(afeidx_-1),__tmp_var_getafebarfrow_0,__tmp_var_getafebarfrow_1); __tmp_var_getafebarfrow_0.x end
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  barvaridx_ = __tmp_var_1
  __tmp_var_4 = begin __tmp_var_getafebarfrow_0 = Ref{Int32}(); __tmp_var_getafebarfrow_1 = Ref{Int64}(); @MSK_getafebarfrowinfo(task_.task,(afeidx_-1),__tmp_var_getafebarfrow_0,__tmp_var_getafebarfrow_1); __tmp_var_getafebarfrow_0.x end
  __tmp_var_5 = zeros(Int64,__tmp_var_4)
  numterms_ = __tmp_var_5
  __tmp_var_6 = begin __tmp_var_getafebarfrow_0 = Ref{Int32}(); __tmp_var_getafebarfrow_1 = Ref{Int64}(); @MSK_getafebarfrowinfo(task_.task,(afeidx_-1),__tmp_var_getafebarfrow_0,__tmp_var_getafebarfrow_1); __tmp_var_getafebarfrow_1.x end
  __tmp_var_7 = zeros(Int64,__tmp_var_6)
  termidx_ = __tmp_var_7
  __tmp_var_2 = begin __tmp_var_getafebarfrow_0 = Ref{Int32}(); __tmp_var_getafebarfrow_1 = Ref{Int64}(); @MSK_getafebarfrowinfo(task_.task,(afeidx_-1),__tmp_var_getafebarfrow_0,__tmp_var_getafebarfrow_1); __tmp_var_getafebarfrow_0.x end
  __tmp_var_3 = zeros(Int64,__tmp_var_2)
  termptr_ = __tmp_var_3
  __tmp_var_8 = begin __tmp_var_getafebarfrow_0 = Ref{Int32}(); __tmp_var_getafebarfrow_1 = Ref{Int64}(); @MSK_getafebarfrowinfo(task_.task,(afeidx_-1),__tmp_var_getafebarfrow_0,__tmp_var_getafebarfrow_1); __tmp_var_getafebarfrow_1.x end
  __tmp_var_9 = zeros(Float64,__tmp_var_8)
  termweight_ = __tmp_var_9
  res = disable_sigint() do
    @MSK_getafebarfrow(task_.task,afeidx_-1,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  __tmp_var_7 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
end

"""
    (numentries,numterms) = getafebarfrowinfo{T1}(task:: MSKtask,afeidx:: T1)
    (numentries,numterms) = getafebarfrowinfo(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index of barF.
* `numentries :: Int32`. Number of nonzero entries in a row of barF.
* `numterms :: Int64`. Number of terms in the weighted sums representation of the row of barF.

Obtains information about one row of ``\\barF``: the number of nonzero entries, that is the number of ``j`` such that ``\\barF_{\\mathrm{afeidx},j}`` is not the zero matrix, as well as the total number of terms in the representations of all
these entries as weighted sums of matrices from ``E``. This information provides the data sizes required for a call to
`Mosek.getafebarfrow`.
"""
function getafebarfrowinfo end
getafebarfrowinfo(task:: MSKtask,afeidx:: T1) where {T1} = getafebarfrowinfo(task,convert(Int64,afeidx))
function getafebarfrowinfo(task_:: MSKtask,afeidx_:: Int64)
  numentries_ = Ref(Int32(1))
  numterms_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getafebarfrowinfo(task_.task,afeidx_-1,numentries_,numterms_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numentries_.x),convert(Int64,numterms_.x))
end

"""
    numfnz = getafefnumnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numfnz :: Int64`. Number of nonzeros in F.

Obtains the total number of nonzeros in ``F``.
"""
function getafefnumnz end
function getafefnumnz(task_:: MSKtask)
  numfnz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getafefnumnz(task_.task,numfnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numfnz_.x))
end

"""
    (nzi,subi,vali) = getafefrow{T1}(task:: MSKtask,afeidx:: T1)
    (nzi,subi,vali) = getafefrow(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index.
* `nzi :: Int32`. Number of non-zeros in the row obtained.
* `subi :: Vector{Int32}`. Column indices of the non-zeros in the row obtained.
* `vali :: Vector{Float64}`. Column indices of the non-zeros in the row obtained.

Obtains one row of ``F`` in sparse format.
"""
function getafefrow end
getafefrow(task:: MSKtask,afeidx:: T1) where {T1} = getafefrow(task,convert(Int64,afeidx))
function getafefrow(task_:: MSKtask,afeidx_:: Int64)
  nzi_ = Ref(Int32(1))
  __tmp_var_0 = begin __tmp_var_getafefrow_0 = Ref{Int32}(); @MSK_getafefrownumnz(task_.task,(afeidx_-1),__tmp_var_getafefrow_0); __tmp_var_getafefrow_0.x end
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = begin __tmp_var_getafefrow_0 = Ref{Int32}(); @MSK_getafefrownumnz(task_.task,(afeidx_-1),__tmp_var_getafefrow_0); __tmp_var_getafefrow_0.x end
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  vali_ = __tmp_var_3
  res = disable_sigint() do
    @MSK_getafefrow(task_.task,afeidx_-1,nzi_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzi_.x),__tmp_var_1,__tmp_var_3)
end

"""
    nzi = getafefrownumnz{T1}(task:: MSKtask,afeidx:: T1)
    nzi = getafefrownumnz(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index.
* `nzi :: Int32`. Number of non-zeros in the row.

Obtains the number of nonzeros in one row of ``F``.
"""
function getafefrownumnz end
getafefrownumnz(task:: MSKtask,afeidx:: T1) where {T1} = getafefrownumnz(task,convert(Int64,afeidx))
function getafefrownumnz(task_:: MSKtask,afeidx_:: Int64)
  nzi_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getafefrownumnz(task_.task,afeidx_-1,nzi_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzi_.x))
end

"""
    (subi,subj,vali) = getafeftrip(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int64}`. Row indices of nonzeros.
* `subj :: Vector{Int32}`. Column indices of nonzeros.
* `vali :: Vector{Float64}`. Values of nonzero entries.

Obtains the ``F`` in triplet format.
"""
function getafeftrip end
function getafeftrip(task_:: MSKtask)
  __tmp_var_0 = begin __tmp_var_getafeftrip_0 = Ref{Int64}(); @MSK_getafefnumnz(task_.task,__tmp_var_getafeftrip_0); __tmp_var_getafeftrip_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = begin __tmp_var_getafeftrip_0 = Ref{Int64}(); @MSK_getafefnumnz(task_.task,__tmp_var_getafeftrip_0); __tmp_var_getafeftrip_0.x end
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = begin __tmp_var_getafeftrip_0 = Ref{Int64}(); @MSK_getafefnumnz(task_.task,__tmp_var_getafeftrip_0); __tmp_var_getafeftrip_0.x end
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  vali_ = __tmp_var_5
  res = disable_sigint() do
    @MSK_getafeftrip(task_.task,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    g = getafeg{T1}(task:: MSKtask,afeidx:: T1)
    g = getafeg(task_:: MSKtask,afeidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Element index.
* `g :: Float64`. The entry in g.

Obtains a single coefficient in ``g``.
"""
function getafeg end
getafeg(task:: MSKtask,afeidx:: T1) where {T1} = getafeg(task,convert(Int64,afeidx))
function getafeg(task_:: MSKtask,afeidx_:: Int64)
  g_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getafeg(task_.task,afeidx_-1,g_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,g_.x))
end

"""
    g = getafegslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    g = getafegslice(task_:: MSKtask,first_:: Int64,last_:: Int64)

* `task :: MSKtask`. An optimization task.
* `first :: Int64`. First index in the sequence.
* `last :: Int64`. Last index plus 1 in the sequence.
* `g :: Vector{Float64}`. The slice of g as a dense vector.

Obtains a sequence of elements from the vector ``g`` of constant terms in the affine expressions list.
"""
function getafegslice end
getafegslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getafegslice(task,convert(Int64,first),convert(Int64,last))
function getafegslice(task_:: MSKtask,first_:: Int64,last_:: Int64)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  g_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getafegslice(task_.task,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    aij = getaij{T1,T2}(task:: MSKtask,i:: T1,j:: T2)
    aij = getaij(task_:: MSKtask,i_:: Int32,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index of the coefficient to be returned.
* `j :: Int32`. Column index of the coefficient to be returned.
* `aij :: Float64`. Returns the requested coefficient.

Obtains a single coefficient in ``A``.
"""
function getaij end
getaij(task:: MSKtask,i:: T1,j:: T2) where {T1,T2} = getaij(task,convert(Int32,i),convert(Int32,j))
function getaij(task_:: MSKtask,i_:: Int32,j_:: Int32)
  aij_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getaij(task_.task,i_-1,j_-1,aij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,aij_.x))
end

"""
    numnz = getapiecenumnz{T1,T2,T3,T4}(task:: MSKtask,firsti:: T1,lasti:: T2,firstj:: T3,lastj:: T4)
    numnz = getapiecenumnz(task_:: MSKtask,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32)

* `task :: MSKtask`. An optimization task.
* `firsti :: Int32`. Index of the first row in the rectangular piece.
* `lasti :: Int32`. Index of the last row plus one in the rectangular piece.
* `firstj :: Int32`. Index of the first column in the rectangular piece.
* `lastj :: Int32`. Index of the last column plus one in the rectangular piece.
* `numnz :: Int32`. Number of non-zero elements in the rectangular piece of the linear constraint matrix.

Obtains the number non-zeros in a rectangular piece of ``A``, i.e. the number of elements in the set

```math
 \\{ (i,j)~:~ a_{i,j} \\neq 0,~ \\mathtt{firsti} \\leq i \\leq \\mathtt{lasti}-1, ~\\mathtt{firstj} \\leq j \\leq \\mathtt{lastj}-1\\}
```
This function is not an efficient way to obtain the number of non-zeros in one
row or column. In that case use the function `Mosek.getarownumnz` or `Mosek.getacolnumnz`.
"""
function getapiecenumnz end
getapiecenumnz(task:: MSKtask,firsti:: T1,lasti:: T2,firstj:: T3,lastj:: T4) where {T1,T2,T3,T4} = getapiecenumnz(task,convert(Int32,firsti),convert(Int32,lasti),convert(Int32,firstj),convert(Int32,lastj))
function getapiecenumnz(task_:: MSKtask,firsti_:: Int32,lasti_:: Int32,firstj_:: Int32,lastj_:: Int32)
  numnz_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getapiecenumnz(task_.task,firsti_-1,lasti_-1,firstj_-1,lastj_-1,numnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numnz_.x))
end

"""
    (nzi,subi,vali) = getarow{T1}(task:: MSKtask,i:: T1)
    (nzi,subi,vali) = getarow(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the row.
* `nzi :: Int32`. Number of non-zeros in the row obtained.
* `subi :: Vector{Int32}`. Column indices of the non-zeros in the row obtained.
* `vali :: Vector{Float64}`. Numerical values of the row obtained.

Obtains one row of ``A`` in a sparse format.
"""
function getarow end
getarow(task:: MSKtask,i:: T1) where {T1} = getarow(task,convert(Int32,i))
function getarow(task_:: MSKtask,i_:: Int32)
  nzi_ = Ref(Int32(1))
  __tmp_var_0 = getarownumnz(task_,(i_))
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = getarownumnz(task_,(i_))
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  vali_ = __tmp_var_3
  res = disable_sigint() do
    @MSK_getarow(task_.task,i_-1,nzi_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzi_.x),__tmp_var_1,__tmp_var_3)
end

"""
    nzi = getarownumnz{T1}(task:: MSKtask,i:: T1)
    nzi = getarownumnz(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the row.
* `nzi :: Int32`. Number of non-zeros in the i'th row of `A`.

Obtains the number of non-zero elements in one row of ``A``.
"""
function getarownumnz end
getarownumnz(task:: MSKtask,i:: T1) where {T1} = getarownumnz(task,convert(Int32,i))
function getarownumnz(task_:: MSKtask,i_:: Int32)
  nzi_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getarownumnz(task_.task,i_-1,nzi_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nzi_.x))
end

"""
    (ptrb,ptre,sub,val) = getarowslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (ptrb,ptre,sub,val) = getarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first row in the sequence.
* `last :: Int32`. Index of the last row in the sequence plus one.
* `ptrb :: Vector{Int64}`. Row start pointers.
* `ptre :: Vector{Int64}`. Row end pointers.
* `sub :: Vector{Int32}`. Contains the column subscripts.
* `val :: Vector{Float64}`. Contains the coefficient values.

Obtains a sequence of rows from ``A`` in sparse format.
"""
function getarowslice end
getarowslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getarowslice(task,convert(Int32,first),convert(Int32,last))
function getarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  maxnumnz_ = getarowslicenumnz(task_,(first_),(last_))
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  ptrb_ = __tmp_var_1
  __tmp_var_2 = ((last_) - (first_))
  __tmp_var_3 = zeros(Int64,__tmp_var_2)
  ptre_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  sub_ = __tmp_var_5
  __tmp_var_6 = (maxnumnz_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  val_ = __tmp_var_7
  surp_ = convert(Int64,length(sub_))
  res = disable_sigint() do
    @MSK_getarowslice64(task_.task,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  __tmp_var_5 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    numnz = getarowslicenumnz{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    numnz = getarowslicenumnz(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first row in the sequence.
* `last :: Int32`. Index of the last row plus one in the sequence.
* `numnz :: Int64`. Number of non-zeros in the slice.

Obtains the number of non-zeros in a slice of rows of ``A``.
"""
function getarowslicenumnz end
getarowslicenumnz(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getarowslicenumnz(task,convert(Int32,first),convert(Int32,last))
function getarowslicenumnz(task_:: MSKtask,first_:: Int32,last_:: Int32)
  numnz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getarowslicenumnz64(task_.task,first_-1,last_-1,numnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_.x))
end

"""
    (subi,subj,val) = getarowslicetrip{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (subi,subj,val) = getarowslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. Index of the first row in the sequence.
* `last :: Int32`. Index of the last row in the sequence plus one.
* `subi :: Vector{Int32}`. Constraint subscripts.
* `subj :: Vector{Int32}`. Column subscripts.
* `val :: Vector{Float64}`. Values.

Obtains a sequence of rows from ``A`` in sparse triplet format. The function returns the
content of all rows whose index `i` satisfies `first <= i < last`.
The triplets corresponding to nonzero entries are stored in the arrays `subi`, `subj` and `val`.
"""
function getarowslicetrip end
getarowslicetrip(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getarowslicetrip(task,convert(Int32,first),convert(Int32,last))
function getarowslicetrip(task_:: MSKtask,first_:: Int32,last_:: Int32)
  maxnumnz_ = getarowslicenumnz(task_,(first_),(last_))
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxnumnz_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxnumnz_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  val_ = __tmp_var_5
  surp_ = convert(Int64,length(subi_))
  res = disable_sigint() do
    @MSK_getarowslicetrip(task_.task,first_-1,last_-1,maxnumnz_,Ref(surp_),__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    tolzero = getatruncatetol(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `tolzero :: Vector{Float64}`. Truncation tolerance.

Obtains the tolerance value set with `Mosek.putatruncatetol`.
"""
function getatruncatetol end
function getatruncatetol(task_:: MSKtask)
  __tmp_var_0 = 1
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  tolzero_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getatruncatetol(task_.task,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (num,subi,subj,subk,subl,valijkl) = getbarablocktriplet(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subi :: Vector{Int32}`. Constraint index.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valijkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Obtains ``\\bar A`` in block triplet form.
"""
function getbarablocktriplet end
function getbarablocktriplet(task_:: MSKtask)
  maxnum_ = getnumbarablocktriplets(task_)
  num_ = Ref(Int64(1))
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxnum_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  subk_ = __tmp_var_5
  __tmp_var_6 = (maxnum_)
  __tmp_var_7 = zeros(Int32,__tmp_var_6)
  subl_ = __tmp_var_7
  __tmp_var_8 = (maxnum_)
  __tmp_var_9 = zeros(Float64,__tmp_var_8)
  valijkl_ = __tmp_var_9
  res = disable_sigint() do
    @MSK_getbarablocktriplet(task_.task,maxnum_,num_,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  __tmp_var_5 .+= 1
  __tmp_var_7 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
end

"""
    (i,j,num,sub,weights) = getbaraidx{T1}(task:: MSKtask,idx:: T1)
    (i,j,num,sub,weights) = getbaraidx(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Position of the element in the vectorized form.
* `i :: Int32`. Row index of the element at position idx.
* `j :: Int32`. Column index of the element at position idx.
* `num :: Int64`. Number of terms in weighted sum that forms the element.
* `sub :: Vector{Int64}`. A list indexes of the elements from symmetric matrix storage that appear in the weighted sum.
* `weights :: Vector{Float64}`. The weights associated with each term in the weighted sum.

Obtains information about an element in ``\\bar A``. Since ``\\bar A``
is a sparse matrix of symmetric matrices, only the nonzero elements in
``\\bar A`` are stored in order to save space. Now ``\\bar A`` is
stored vectorized i.e. as one long vector. This function makes it
possible to obtain information such as the row index and the column index of a
particular element of the vectorized form of ``\\bar A``.

Please observe if one element of ``\\bar A`` is inputted multiple times
then it may be stored several times in vectorized form. In that case the
element with the highest index is the one that is used.
"""
function getbaraidx end
getbaraidx(task:: MSKtask,idx:: T1) where {T1} = getbaraidx(task,convert(Int64,idx))
function getbaraidx(task_:: MSKtask,idx_:: Int64)
  i_ = Ref(Int32(1))
  j_ = Ref(Int32(1))
  num_ = Ref(Int64(1))
  maxnum_ = getbaraidxinfo(task_,(idx_))
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  sub_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  weights_ = __tmp_var_3
  res = disable_sigint() do
    @MSK_getbaraidx(task_.task,idx_-1,maxnum_,i_,j_,num_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,i_.x+1),convert(Int32,j_.x+1),convert(Int64,num_.x),__tmp_var_1,__tmp_var_3)
end

"""
    (i,j) = getbaraidxij{T1}(task:: MSKtask,idx:: T1)
    (i,j) = getbaraidxij(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Position of the element in the vectorized form.
* `i :: Int32`. Row index of the element at position idx.
* `j :: Int32`. Column index of the element at position idx.

Obtains information about an element in ``\\bar A``. Since ``\\bar A``
is a sparse matrix of symmetric matrices, only the nonzero elements in
``\\bar A`` are stored in order to save space. Now ``\\bar A`` is
stored vectorized i.e. as one long vector.  This function makes it
possible to obtain information such as the row index and the column index of a
particular element of the vectorized form of ``\\bar A``.

Please note that if one element of ``\\bar A`` is inputted multiple times
then it may be stored several times in vectorized form. In that case the
element with the highest index is the one that is used.
"""
function getbaraidxij end
getbaraidxij(task:: MSKtask,idx:: T1) where {T1} = getbaraidxij(task,convert(Int64,idx))
function getbaraidxij(task_:: MSKtask,idx_:: Int64)
  i_ = Ref(Int32(1))
  j_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getbaraidxij(task_.task,idx_-1,i_,j_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,i_.x+1),convert(Int32,j_.x+1))
end

"""
    num = getbaraidxinfo{T1}(task:: MSKtask,idx:: T1)
    num = getbaraidxinfo(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. The internal position of the element for which information should be obtained.
* `num :: Int64`. Number of terms in the weighted sum that form the specified element in barA.

Each nonzero element in ``\\bar A_{ij}`` is formed as a weighted sum of
symmetric matrices. Using this function the number of terms in the weighted sum
can be obtained. See description of `Mosek.appendsparsesymmat` for details
about the weighted sum.
"""
function getbaraidxinfo end
getbaraidxinfo(task:: MSKtask,idx:: T1) where {T1} = getbaraidxinfo(task,convert(Int64,idx))
function getbaraidxinfo(task_:: MSKtask,idx_:: Int64)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getbaraidxinfo(task_.task,idx_-1,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    (numnz,idxij) = getbarasparsity(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numnz :: Int64`. Number of nonzero elements in barA.
* `idxij :: Vector{Int64}`. Position of each nonzero element in the vector representation of barA.

The matrix ``\\bar A`` is assumed to be a sparse matrix of symmetric matrices.
This implies that many of the elements in ``\\bar A`` are likely to be zero matrices.
Therefore, in order to save space, only nonzero elements in ``\\bar A`` are stored
on vectorized form. This function is used to obtain the sparsity pattern of
``\\bar A`` and the position of each nonzero element in the vectorized form of
``\\bar A``. From the index detailed information about each nonzero ``\\bar A_{i,j}`` can be
obtained using `Mosek.getbaraidxinfo` and `Mosek.getbaraidx`.
"""
function getbarasparsity end
function getbarasparsity(task_:: MSKtask)
  maxnumnz_ = getnumbaranz(task_)
  numnz_ = Ref(Int64(1))
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  idxij_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getbarasparsity(task_.task,maxnumnz_,numnz_,__tmp_var_1)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_.x),__tmp_var_1)
end

"""
    (num,subj,subk,subl,valjkl) = getbarcblocktriplet(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valjkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Obtains ``\\bar C`` in block triplet form.
"""
function getbarcblocktriplet end
function getbarcblocktriplet(task_:: MSKtask)
  maxnum_ = getnumbarcblocktriplets(task_)
  num_ = Ref(Int64(1))
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subj_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subk_ = __tmp_var_3
  __tmp_var_4 = (maxnum_)
  __tmp_var_5 = zeros(Int32,__tmp_var_4)
  subl_ = __tmp_var_5
  __tmp_var_6 = (maxnum_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  valjkl_ = __tmp_var_7
  res = disable_sigint() do
    @MSK_getbarcblocktriplet(task_.task,maxnum_,num_,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  __tmp_var_5 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x),__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7)
end

"""
    (j,num,sub,weights) = getbarcidx{T1}(task:: MSKtask,idx:: T1)
    (j,num,sub,weights) = getbarcidx(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the element for which information should be obtained.
* `j :: Int32`. Row index in barc.
* `num :: Int64`. Number of terms in the weighted sum.
* `sub :: Vector{Int64}`. Elements appearing the weighted sum.
* `weights :: Vector{Float64}`. Weights of terms in the weighted sum.

Obtains information about an element in ``\\bar C``.
"""
function getbarcidx end
getbarcidx(task:: MSKtask,idx:: T1) where {T1} = getbarcidx(task,convert(Int64,idx))
function getbarcidx(task_:: MSKtask,idx_:: Int64)
  j_ = Ref(Int32(1))
  num_ = Ref(Int64(1))
  maxnum_ = getbarcidxinfo(task_,(idx_))
  __tmp_var_0 = (maxnum_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  sub_ = __tmp_var_1
  __tmp_var_2 = (maxnum_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  weights_ = __tmp_var_3
  res = disable_sigint() do
    @MSK_getbarcidx(task_.task,idx_-1,maxnum_,j_,num_,__tmp_var_1,__tmp_var_3)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,j_.x+1),convert(Int64,num_.x),__tmp_var_1,__tmp_var_3)
end

"""
    num = getbarcidxinfo{T1}(task:: MSKtask,idx:: T1)
    num = getbarcidxinfo(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the element for which information should be obtained. The value is an index of a symmetric sparse variable.
* `num :: Int64`. Number of terms that appear in the weighted sum that forms the requested element.

Obtains the number of terms in the weighted sum that forms a particular element in ``\\bar C``.
"""
function getbarcidxinfo end
getbarcidxinfo(task:: MSKtask,idx:: T1) where {T1} = getbarcidxinfo(task,convert(Int64,idx))
function getbarcidxinfo(task_:: MSKtask,idx_:: Int64)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getbarcidxinfo(task_.task,idx_-1,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    j = getbarcidxj{T1}(task:: MSKtask,idx:: T1)
    j = getbarcidxj(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the element for which information should be obtained.
* `j :: Int32`. Row index in barc.

Obtains the row index of an element in ``\\bar C``.
"""
function getbarcidxj end
getbarcidxj(task:: MSKtask,idx:: T1) where {T1} = getbarcidxj(task,convert(Int64,idx))
function getbarcidxj(task_:: MSKtask,idx_:: Int64)
  j_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getbarcidxj(task_.task,idx_-1,j_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,j_.x+1))
end

"""
    (numnz,idxj) = getbarcsparsity(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numnz :: Int64`. Number of nonzero elements in barc.
* `idxj :: Vector{Int64}`. Internal positions of the nonzeros elements in barc.

Internally only the nonzero elements of ``\\bar C`` are stored
in a vector. This function is used to obtain the nonzero elements of ``\\bar C``
and their indexes in the internal vector representation (in `idx`). From the index
detailed information about each nonzero ``\\bar C_j`` can be
obtained using `Mosek.getbarcidxinfo` and `Mosek.getbarcidx`.
"""
function getbarcsparsity end
function getbarcsparsity(task_:: MSKtask)
  maxnumnz_ = getnumbarcnz(task_)
  numnz_ = Ref(Int64(1))
  __tmp_var_0 = (maxnumnz_)
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  idxj_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getbarcsparsity(task_.task,maxnumnz_,numnz_,__tmp_var_1)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numnz_.x),__tmp_var_1)
end

"""
    barsj = getbarsj{T2}(task:: MSKtask,whichsol:: Soltype,j:: T2)
    barsj = getbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barsj :: Vector{Float64}`. Value of the j'th dual variable of barx.

Obtains the dual solution for a semidefinite variable. Only the lower triangular part of ``\\bar S_j`` is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.
"""
function getbarsj end
getbarsj(task:: MSKtask,whichsol:: Soltype,j:: T2) where {T2} = getbarsj(task,whichsol,convert(Int32,j))
function getbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  barsj_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getbarsj(task_.task,whichsol_.value,j_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    barsslice = getbarsslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slicesize:: T4)
    barsslice = getbarsslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slicesize_:: Int64)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. Index of the first semidefinite variable in the slice.
* `last :: Int32`. Index of the last semidefinite variable in the slice plus one.
* `slicesize :: Int64`. Denotes the length of the array barsslice.
* `barsslice :: Vector{Float64}`. Dual solution values of symmetric matrix variables in the slice, stored sequentially.

Obtains the dual solution for a sequence of semidefinite variables. The format is that matrices are stored sequentially, and in each matrix the columns are stored as in `Mosek.getbarsj`.
"""
function getbarsslice end
getbarsslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slicesize:: T4) where {T2,T3,T4} = getbarsslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Int64,slicesize))
function getbarsslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slicesize_:: Int64)
  __tmp_var_0 = (slicesize_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  barsslice_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getbarsslice(task_.task,whichsol_.value,first_-1,last_-1,slicesize_,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    name = getbarvarname{T1}(task:: MSKtask,i:: T1)
    name = getbarvarname(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the variable.
* `name :: AbstractString`. The requested name is copied to this buffer.

Obtains the name of a semidefinite variable.
"""
function getbarvarname end
getbarvarname(task:: MSKtask,i:: T1) where {T1} = getbarvarname(task,convert(Int32,i))
function getbarvarname(task_:: MSKtask,i_:: Int32)
  sizename_ = (1 + getbarvarnamelen(task_,(i_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getbarvarname(task_.task,i_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    (asgn,index) = getbarvarnameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name of the variable.
* `asgn :: Int32`. Non-zero if the name somename is assigned to some semidefinite variable.
* `index :: Int32`. The index of a semidefinite variable with the name somename (if one exists).

Obtains the index of semidefinite variable from its name.
"""
function getbarvarnameindex end
function getbarvarnameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Ref(Int32(1))
  index_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getbarvarnameindex(task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_.x),convert(Int32,index_.x))
end

"""
    len = getbarvarnamelen{T1}(task:: MSKtask,i:: T1)
    len = getbarvarnamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the variable.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a semidefinite variable.
"""
function getbarvarnamelen end
getbarvarnamelen(task:: MSKtask,i:: T1) where {T1} = getbarvarnamelen(task,convert(Int32,i))
function getbarvarnamelen(task_:: MSKtask,i_:: Int32)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getbarvarnamelen(task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    barxj = getbarxj{T2}(task:: MSKtask,whichsol:: Soltype,j:: T2)
    barxj = getbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barxj :: Vector{Float64}`. Value of the j'th variable of barx.

Obtains the primal solution for a semidefinite variable. Only the lower triangular part of ``\\bar X_j`` is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.
"""
function getbarxj end
getbarxj(task:: MSKtask,whichsol:: Soltype,j:: T2) where {T2} = getbarxj(task,whichsol,convert(Int32,j))
function getbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32)
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  barxj_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getbarxj(task_.task,whichsol_.value,j_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    barxslice = getbarxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slicesize:: T4)
    barxslice = getbarxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slicesize_:: Int64)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. Index of the first semidefinite variable in the slice.
* `last :: Int32`. Index of the last semidefinite variable in the slice plus one.
* `slicesize :: Int64`. Denotes the length of the array barxslice.
* `barxslice :: Vector{Float64}`. Solution values of symmetric matrix variables in the slice, stored sequentially.

Obtains the primal solution for a sequence of semidefinite variables. The format is that matrices are stored sequentially, and in each matrix the columns are stored as in `Mosek.getbarxj`.
"""
function getbarxslice end
getbarxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slicesize:: T4) where {T2,T3,T4} = getbarxslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Int64,slicesize))
function getbarxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slicesize_:: Int64)
  __tmp_var_0 = (slicesize_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  barxslice_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getbarxslice(task_.task,whichsol_.value,first_-1,last_-1,slicesize_,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    c = getc(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `c :: Vector{Float64}`. Linear terms of the objective as a dense vector. The length is the number of variables.

Obtains all objective coefficients ``c``.
"""
function getc end
function getc(task_:: MSKtask)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  c_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getc(task_.task,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    cfix = getcfix(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `cfix :: Float64`. Fixed term in the objective.

Obtains the fixed term in the objective.
"""
function getcfix end
function getcfix(task_:: MSKtask)
  cfix_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getcfix(task_.task,cfix_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,cfix_.x))
end

"""
    cj = getcj{T1}(task:: MSKtask,j:: T1)
    cj = getcj(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable for which the c coefficient should be obtained.
* `cj :: Float64`. The c coefficient value.

Obtains one coefficient of ``c``.
"""
function getcj end
getcj(task:: MSKtask,j:: T1) where {T1} = getcj(task,convert(Int32,j))
function getcj(task_:: MSKtask,j_:: Int32)
  cj_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getcj(task_.task,j_-1,cj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,cj_.x))
end

"""
    c = getclist{T1}(task:: MSKtask,subj:: Vector{T1})
    c = getclist(task_:: MSKtask,subj_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. A list of variable indexes.
* `c :: Vector{Float64}`. Linear terms of the requested list of the objective as a dense vector.

Obtains a sequence of elements in ``c``.
"""
function getclist end
getclist(task:: MSKtask,subj:: Vector{T1}) where {T1} = getclist(task,convert(Vector{Int32},subj))
function getclist(task_:: MSKtask,subj_:: Vector{Int32})
  num_ = minimum([ length(subj_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  c_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getclist(task_.task,num_,subj_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (symname,str) = getcodedesc(code_:: Rescode)

* `code :: Rescode`. A valid response code.
* `symname :: AbstractString`. Symbolic name corresponding to the code.
* `str :: AbstractString`. Obtains a short description of a response code.

Obtains a short description of the meaning of the response code given by `code`.
"""
function getcodedesc end
function getcodedesc(code_:: Rescode)
  str_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  symname_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @MSK_getcodedesc(code_.value,symname_,str_)
  end
  symname_str = String(symname_[1:findfirst(isequal(0),symname_)-1])
  str_str = String(str_[1:findfirst(isequal(0),str_)-1])
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
  (symname_str,str_str)
end

"""
    (bk,bl,bu) = getconbound{T1}(task:: MSKtask,i:: T1)
    (bk,bl,bu) = getconbound(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint for which the bound information should be obtained.
* `bk :: Boundkey`. Bound keys.
* `bl :: Float64`. Values for lower bounds.
* `bu :: Float64`. Values for upper bounds.

Obtains bound information for one constraint.
"""
function getconbound end
getconbound(task:: MSKtask,i:: T1) where {T1} = getconbound(task,convert(Int32,i))
function getconbound(task_:: MSKtask,i_:: Int32)
  bk_ = Ref(Int32(1))
  bl_ = Ref(Float64(1))
  bu_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getconbound(task_.task,i_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey(bk_.x),convert(Float64,bl_.x),convert(Float64,bu_.x))
end

"""
    (bk,bl,bu) = getconboundslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (bk,bl,bu) = getconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Boundkey}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Obtains bounds information for a slice of the constraints.
"""
function getconboundslice end
getconboundslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getconboundslice(task,convert(Int32,first),convert(Int32,last))
function getconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  bk_ = Vector{Int32}(undef,__tmp_var_0)
  __tmp_var_1 = ((last_) - (first_))
  __tmp_var_2 = zeros(Float64,__tmp_var_1)
  bl_ = __tmp_var_2
  __tmp_var_3 = ((last_) - (first_))
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  bu_ = __tmp_var_4
  res = disable_sigint() do
    @MSK_getconboundslice(task_.task,first_-1,last_-1,bk_,__tmp_var_2,__tmp_var_4)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey[ Boundkey(i) for i in bk_],__tmp_var_2,__tmp_var_4)
end

"""
    (ct,conepar,nummem,submem) = getcone{T1}(task:: MSKtask,k:: T1)
    (ct,conepar,nummem,submem) = getcone(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
* `nummem :: Int32`. Number of member variables in the cone.
* `submem :: Vector{Int32}`. Variable subscripts of the members in the cone.

Deprecated in MOSEK 10
"""
function getcone end
getcone(task:: MSKtask,k:: T1) where {T1} = getcone(task,convert(Int32,k))
function getcone(task_:: MSKtask,k_:: Int32)
  conepar_ = Ref(Float64(1))
  ct_ = Ref(Int32(1))
  nummem_ = Ref(Int32(1))
  __tmp_var_0 = getconeinfo(task_,(k_))[3]
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  submem_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getcone(task_.task,k_-1,ct_,conepar_,nummem_,__tmp_var_1)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Conetype(ct_.x),convert(Float64,conepar_.x),convert(Int32,nummem_.x),__tmp_var_1)
end

"""
    (ct,conepar,nummem) = getconeinfo{T1}(task:: MSKtask,k:: T1)
    (ct,conepar,nummem) = getconeinfo(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
* `nummem :: Int32`. Number of member variables in the cone.

Deprecated in MOSEK 10
"""
function getconeinfo end
getconeinfo(task:: MSKtask,k:: T1) where {T1} = getconeinfo(task,convert(Int32,k))
function getconeinfo(task_:: MSKtask,k_:: Int32)
  conepar_ = Ref(Float64(1))
  ct_ = Ref(Int32(1))
  nummem_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getconeinfo(task_.task,k_-1,ct_,conepar_,nummem_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Conetype(ct_.x),convert(Float64,conepar_.x),convert(Int32,nummem_.x))
end

"""
    name = getconename{T1}(task:: MSKtask,i:: T1)
    name = getconename(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the cone.
* `name :: AbstractString`. The required name.

Deprecated in MOSEK 10
"""
function getconename end
getconename(task:: MSKtask,i:: T1) where {T1} = getconename(task,convert(Int32,i))
function getconename(task_:: MSKtask,i_:: Int32)
  sizename_ = (1 + getconenamelen(task_,(i_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getconename(task_.task,i_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    (asgn,index) = getconenameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name which should be checked.
* `asgn :: Int32`. Is non-zero if the name somename is assigned to some cone.
* `index :: Int32`. If the name somename is assigned to some cone, this is the index of the cone.

Deprecated in MOSEK 10

Checks whether the name `somename` has been assigned to any cone. If it has been assigned to a cone, then the index of the cone is reported.
"""
function getconenameindex end
function getconenameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Ref(Int32(1))
  index_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getconenameindex(task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_.x),convert(Int32,index_.x))
end

"""
    len = getconenamelen{T1}(task:: MSKtask,i:: T1)
    len = getconenamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the cone.
* `len :: Int32`. Returns the length of the indicated name.

Deprecated in MOSEK 10
"""
function getconenamelen end
getconenamelen(task:: MSKtask,i:: T1) where {T1} = getconenamelen(task,convert(Int32,i))
function getconenamelen(task_:: MSKtask,i_:: Int32)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getconenamelen(task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    name = getconname{T1}(task:: MSKtask,i:: T1)
    name = getconname(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `name :: AbstractString`. The required name.

Obtains the name of a constraint.
"""
function getconname end
getconname(task:: MSKtask,i:: T1) where {T1} = getconname(task,convert(Int32,i))
function getconname(task_:: MSKtask,i_:: Int32)
  sizename_ = (1 + getconnamelen(task_,(i_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getconname(task_.task,i_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    (asgn,index) = getconnameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name which should be checked.
* `asgn :: Int32`. Is non-zero if the name somename is assigned to some constraint.
* `index :: Int32`. If the name somename is assigned to a constraint, then return the index of the constraint.

Checks whether the name `somename` has been assigned to any constraint. If so, the index of the constraint is reported.
"""
function getconnameindex end
function getconnameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Ref(Int32(1))
  index_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getconnameindex(task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_.x),convert(Int32,index_.x+1))
end

"""
    len = getconnamelen{T1}(task:: MSKtask,i:: T1)
    len = getconnamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a constraint.
"""
function getconnamelen end
getconnamelen(task:: MSKtask,i:: T1) where {T1} = getconnamelen(task,convert(Int32,i))
function getconnamelen(task_:: MSKtask,i_:: Int32)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getconnamelen(task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    c = getcslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    c = getcslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `c :: Vector{Float64}`. Linear terms of the requested slice of the objective as a dense vector.

Obtains a sequence of elements in ``c``.
"""
function getcslice end
getcslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getcslice(task,convert(Int32,first),convert(Int32,last))
function getcslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  c_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getcslice(task_.task,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    dimbarvarj = getdimbarvarj{T1}(task:: MSKtask,j:: T1)
    dimbarvarj = getdimbarvarj(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the semidefinite variable whose dimension is requested.
* `dimbarvarj :: Int32`. The dimension of the j'th semidefinite variable.

Obtains the dimension of a symmetric matrix variable.
"""
function getdimbarvarj end
getdimbarvarj(task:: MSKtask,j:: T1) where {T1} = getdimbarvarj(task,convert(Int32,j))
function getdimbarvarj(task_:: MSKtask,j_:: Int32)
  dimbarvarj_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getdimbarvarj(task_.task,j_-1,dimbarvarj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,dimbarvarj_.x))
end

"""
    afeidxlist = getdjcafeidxlist{T1}(task:: MSKtask,djcidx:: T1)
    afeidxlist = getdjcafeidxlist(task_:: MSKtask,djcidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of the disjunctive constraint.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.

Obtains the list of affine expression indexes in a disjunctive constraint.
"""
function getdjcafeidxlist end
getdjcafeidxlist(task:: MSKtask,djcidx:: T1) where {T1} = getdjcafeidxlist(task,convert(Int64,djcidx))
function getdjcafeidxlist(task_:: MSKtask,djcidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getdjcafeidxlist_0 = Ref{Int64}(); @MSK_getdjcnumafe(task_.task,(djcidx_-1),__tmp_var_getdjcafeidxlist_0); __tmp_var_getdjcafeidxlist_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  afeidxlist_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdjcafeidxlist(task_.task,djcidx_-1,__tmp_var_1)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    b = getdjcb{T1}(task:: MSKtask,djcidx:: T1)
    b = getdjcb(task_:: MSKtask,djcidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of the disjunctive constraint.
* `b :: Vector{Float64}`. The vector b.

Obtains the optional constant term vector of a disjunctive constraint.
"""
function getdjcb end
getdjcb(task:: MSKtask,djcidx:: T1) where {T1} = getdjcb(task,convert(Int64,djcidx))
function getdjcb(task_:: MSKtask,djcidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getdjcb_0 = Ref{Int64}(); @MSK_getdjcnumafe(task_.task,(djcidx_-1),__tmp_var_getdjcb_0); __tmp_var_getdjcb_0.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  b_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdjcb(task_.task,djcidx_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    domidxlist = getdjcdomainidxlist{T1}(task:: MSKtask,djcidx:: T1)
    domidxlist = getdjcdomainidxlist(task_:: MSKtask,djcidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of the disjunctive constraint.
* `domidxlist :: Vector{Int64}`. List of term sizes.

Obtains the list of domain indexes in a disjunctive constraint.
"""
function getdjcdomainidxlist end
getdjcdomainidxlist(task:: MSKtask,djcidx:: T1) where {T1} = getdjcdomainidxlist(task,convert(Int64,djcidx))
function getdjcdomainidxlist(task_:: MSKtask,djcidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getdjcdomainidxlist_0 = Ref{Int64}(); @MSK_getdjcnumdomain(task_.task,(djcidx_-1),__tmp_var_getdjcdomainidxlist_0); __tmp_var_getdjcdomainidxlist_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  domidxlist_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdjcdomainidxlist(task_.task,djcidx_-1,__tmp_var_1)
  end
  __tmp_var_1 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    name = getdjcname{T1}(task:: MSKtask,djcidx:: T1)
    name = getdjcname(task_:: MSKtask,djcidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of a disjunctive constraint.
* `name :: AbstractString`. Returns the required name.

Obtains the name of a disjunctive constraint.
"""
function getdjcname end
getdjcname(task:: MSKtask,djcidx:: T1) where {T1} = getdjcname(task,convert(Int64,djcidx))
function getdjcname(task_:: MSKtask,djcidx_:: Int64)
  sizename_ = (1 + begin __tmp_var_getdjcname_0 = Ref{Int32}(); @MSK_getdjcnamelen(task_.task,(djcidx_-1),__tmp_var_getdjcname_0); __tmp_var_getdjcname_0.x end)
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getdjcname(task_.task,djcidx_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    len = getdjcnamelen{T1}(task:: MSKtask,djcidx:: T1)
    len = getdjcnamelen(task_:: MSKtask,djcidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of a disjunctive constraint.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a disjunctive constraint.
"""
function getdjcnamelen end
getdjcnamelen(task:: MSKtask,djcidx:: T1) where {T1} = getdjcnamelen(task,convert(Int64,djcidx))
function getdjcnamelen(task_:: MSKtask,djcidx_:: Int64)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getdjcnamelen(task_.task,djcidx_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    numafe = getdjcnumafe{T1}(task:: MSKtask,idjc:: T1)
    numafe = getdjcnumafe(task_:: MSKtask,idjc_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idjc :: Int64`. Index of the disjunctive constraint.
* `numafe :: Int64`. Number of affine expressions in the disjunctive constraint.

Obtains the number of affine expressions in the disjunctive constraint.
"""
function getdjcnumafe end
getdjcnumafe(task:: MSKtask,idjc:: T1) where {T1} = getdjcnumafe(task,convert(Int64,idjc))
function getdjcnumafe(task_:: MSKtask,idjc_:: Int64)
  numafe_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdjcnumafe(task_.task,idjc_-1,numafe_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numafe_.x))
end

"""
    numafetot = getdjcnumafetot(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numafetot :: Int64`. Number of affine expressions in all disjunctive constraints.

Obtains the total number of affine expressions in all disjunctive constraints.
"""
function getdjcnumafetot end
function getdjcnumafetot(task_:: MSKtask)
  numafetot_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdjcnumafetot(task_.task,numafetot_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numafetot_.x))
end

"""
    numdomain = getdjcnumdomain{T1}(task:: MSKtask,idjc:: T1)
    numdomain = getdjcnumdomain(task_:: MSKtask,idjc_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idjc :: Int64`. Index of the disjunctive constraint.
* `numdomain :: Int64`. Number of domains in the disjunctive constraint.

Obtains the number of domains in the disjunctive constraint.
"""
function getdjcnumdomain end
getdjcnumdomain(task:: MSKtask,idjc:: T1) where {T1} = getdjcnumdomain(task,convert(Int64,idjc))
function getdjcnumdomain(task_:: MSKtask,idjc_:: Int64)
  numdomain_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdjcnumdomain(task_.task,idjc_-1,numdomain_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numdomain_.x))
end

"""
    numdomaintot = getdjcnumdomaintot(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numdomaintot :: Int64`. Number of domains in all disjunctive constraints.

Obtains the total number of domains in all disjunctive constraints.
"""
function getdjcnumdomaintot end
function getdjcnumdomaintot(task_:: MSKtask)
  numdomaintot_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdjcnumdomaintot(task_.task,numdomaintot_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numdomaintot_.x))
end

"""
    numterm = getdjcnumterm{T1}(task:: MSKtask,idjc:: T1)
    numterm = getdjcnumterm(task_:: MSKtask,idjc_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idjc :: Int64`. Index of the disjunctive constraint.
* `numterm :: Int64`. Number of terms in the disjunctive constraint.

Obtains the number terms in the disjunctive constraint.
"""
function getdjcnumterm end
getdjcnumterm(task:: MSKtask,idjc:: T1) where {T1} = getdjcnumterm(task,convert(Int64,idjc))
function getdjcnumterm(task_:: MSKtask,idjc_:: Int64)
  numterm_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdjcnumterm(task_.task,idjc_-1,numterm_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numterm_.x))
end

"""
    numtermtot = getdjcnumtermtot(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numtermtot :: Int64`. Total number of terms in all disjunctive constraints.

Obtains the total number of terms in all disjunctive constraints.
"""
function getdjcnumtermtot end
function getdjcnumtermtot(task_:: MSKtask)
  numtermtot_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdjcnumtermtot(task_.task,numtermtot_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numtermtot_.x))
end

"""
    (domidxlist,afeidxlist,b,termsizelist,numterms) = getdjcs(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `domidxlist :: Vector{Int64}`. The concatenation of index lists of domains appearing in all disjunctive constraints.
* `afeidxlist :: Vector{Int64}`. The concatenation of index lists of affine expressions appearing in all disjunctive constraints.
* `b :: Vector{Float64}`. The concatenation of vectors b appearing in all disjunctive constraints.
* `termsizelist :: Vector{Int64}`. The concatenation of lists of term sizes appearing in all disjunctive constraints.
* `numterms :: Vector{Int64}`. The number of terms in each of the disjunctive constraints.

Obtains full data of all disjunctive constraints. The output arrays must have minimal lengths determined by the following methods: `domainidxlist` by `Mosek.getdjcnumdomaintot`, `afeidxlist` and `b` by `Mosek.getdjcnumafetot`, `termsizelist` by `Mosek.getdjcnumtermtot` and `numterms` by `Mosek.getnumdomain`.
"""
function getdjcs end
function getdjcs(task_:: MSKtask)
  __tmp_var_2 = begin __tmp_var_getdjcs_0 = Ref{Int64}(); @MSK_getdjcnumafetot(task_.task,__tmp_var_getdjcs_0); __tmp_var_getdjcs_0.x end
  __tmp_var_3 = zeros(Int64,__tmp_var_2)
  afeidxlist_ = __tmp_var_3
  __tmp_var_4 = begin __tmp_var_getdjcs_0 = Ref{Int64}(); @MSK_getdjcnumafetot(task_.task,__tmp_var_getdjcs_0); __tmp_var_getdjcs_0.x end
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  b_ = __tmp_var_5
  __tmp_var_0 = begin __tmp_var_getdjcs_0 = Ref{Int64}(); @MSK_getdjcnumdomaintot(task_.task,__tmp_var_getdjcs_0); __tmp_var_getdjcs_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  domidxlist_ = __tmp_var_1
  __tmp_var_8 = begin __tmp_var_getdjcs_0 = Ref{Int64}(); @MSK_getnumdjc(task_.task,__tmp_var_getdjcs_0); __tmp_var_getdjcs_0.x end
  __tmp_var_9 = zeros(Int64,__tmp_var_8)
  numterms_ = __tmp_var_9
  __tmp_var_6 = begin __tmp_var_getdjcs_0 = Ref{Int64}(); @MSK_getdjcnumtermtot(task_.task,__tmp_var_getdjcs_0); __tmp_var_getdjcs_0.x end
  __tmp_var_7 = zeros(Int64,__tmp_var_6)
  termsizelist_ = __tmp_var_7
  res = disable_sigint() do
    @MSK_getdjcs(task_.task,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9)
end

"""
    termsizelist = getdjctermsizelist{T1}(task:: MSKtask,djcidx:: T1)
    termsizelist = getdjctermsizelist(task_:: MSKtask,djcidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of the disjunctive constraint.
* `termsizelist :: Vector{Int64}`. List of term sizes.

Obtains the list of term sizes in a disjunctive constraint.
"""
function getdjctermsizelist end
getdjctermsizelist(task:: MSKtask,djcidx:: T1) where {T1} = getdjctermsizelist(task,convert(Int64,djcidx))
function getdjctermsizelist(task_:: MSKtask,djcidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getdjctermsizelist_0 = Ref{Int64}(); @MSK_getdjcnumterm(task_.task,(djcidx_-1),__tmp_var_getdjctermsizelist_0); __tmp_var_getdjctermsizelist_0.x end
  __tmp_var_1 = zeros(Int64,__tmp_var_0)
  termsizelist_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdjctermsizelist(task_.task,djcidx_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    n = getdomainn{T1}(task:: MSKtask,domidx:: T1)
    n = getdomainn(task_:: MSKtask,domidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.
* `n :: Int64`. Dimension of the domain.

Obtains the dimension of the domain.
"""
function getdomainn end
getdomainn(task:: MSKtask,domidx:: T1) where {T1} = getdomainn(task,convert(Int64,domidx))
function getdomainn(task_:: MSKtask,domidx_:: Int64)
  n_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getdomainn(task_.task,domidx_-1,n_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,n_.x))
end

"""
    name = getdomainname{T1}(task:: MSKtask,domidx:: T1)
    name = getdomainname(task_:: MSKtask,domidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of a domain.
* `name :: AbstractString`. Returns the required name.

Obtains the name of a domain.
"""
function getdomainname end
getdomainname(task:: MSKtask,domidx:: T1) where {T1} = getdomainname(task,convert(Int64,domidx))
function getdomainname(task_:: MSKtask,domidx_:: Int64)
  sizename_ = (1 + begin __tmp_var_getdomainname_0 = Ref{Int32}(); @MSK_getdomainnamelen(task_.task,(domidx_-1),__tmp_var_getdomainname_0); __tmp_var_getdomainname_0.x end)
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getdomainname(task_.task,domidx_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    len = getdomainnamelen{T1}(task:: MSKtask,domidx:: T1)
    len = getdomainnamelen(task_:: MSKtask,domidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of a domain.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a domain.
"""
function getdomainnamelen end
getdomainnamelen(task:: MSKtask,domidx:: T1) where {T1} = getdomainnamelen(task,convert(Int64,domidx))
function getdomainnamelen(task_:: MSKtask,domidx_:: Int64)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getdomainnamelen(task_.task,domidx_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    domaintype = getdomaintype{T1}(task:: MSKtask,domidx:: T1)
    domaintype = getdomaintype(task_:: MSKtask,domidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.
* `domaintype :: Domaintype`. The type of the domain.

Returns the type of the domain.
"""
function getdomaintype end
getdomaintype(task:: MSKtask,domidx:: T1) where {T1} = getdomaintype(task,convert(Int64,domidx))
function getdomaintype(task_:: MSKtask,domidx_:: Int64)
  domaintype_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getdomaintype(task_.task,domidx_-1,domaintype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Domaintype(domaintype_.x))
end

"""
    dvalue = getdouinf(task_:: MSKtask,whichdinf_:: Dinfitem)

* `task :: MSKtask`. An optimization task.
* `whichdinf :: Dinfitem`. Specifies a double information item.
* `dvalue :: Float64`. The value of the required double information item.

Obtains a double information item from the task information database.
"""
function getdouinf end
function getdouinf(task_:: MSKtask,whichdinf_:: Dinfitem)
  dvalue_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getdouinf(task_.task,whichdinf_.value,dvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,dvalue_.x))
end

"""
    parvalue = getdouparam(task_:: MSKtask,param_:: Dparam)

* `task :: MSKtask`. An optimization task.
* `param :: Dparam`. Which parameter.
* `parvalue :: Float64`. Parameter value.

Obtains the value of a double parameter.
"""
function getdouparam end
function getdouparam(task_:: MSKtask,param_:: Dparam)
  parvalue_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getdouparam(task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,parvalue_.x))
end

"""
    dualobj = getdualobj(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `dualobj :: Float64`. Objective value corresponding to the dual solution.

Computes the dual objective value associated with the solution. Note that if the solution is a primal infeasibility certificate, then the fixed term in the objective value is not included.

Moreover, since there is no dual solution associated with an integer solution, an error will be reported if the dual objective value is requested for the integer solution.
"""
function getdualobj end
function getdualobj(task_:: MSKtask,whichsol_:: Soltype)
  dualobj_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getdualobj(task_.task,whichsol_.value,dualobj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,dualobj_.x))
end

"""
    (nrmy,nrmslc,nrmsuc,nrmslx,nrmsux,nrmsnx,nrmbars) = getdualsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `nrmy :: Float64`. The norm of the y vector.
* `nrmslc :: Float64`. The norm of the slc vector.
* `nrmsuc :: Float64`. The norm of the suc vector.
* `nrmslx :: Float64`. The norm of the slx vector.
* `nrmsux :: Float64`. The norm of the sux vector.
* `nrmsnx :: Float64`. The norm of the snx vector.
* `nrmbars :: Float64`. The norm of the bars vector.

Compute norms of the dual solution.
"""
function getdualsolutionnorms end
function getdualsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)
  nrmbars_ = Ref(Float64(1))
  nrmslc_ = Ref(Float64(1))
  nrmslx_ = Ref(Float64(1))
  nrmsnx_ = Ref(Float64(1))
  nrmsuc_ = Ref(Float64(1))
  nrmsux_ = Ref(Float64(1))
  nrmy_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getdualsolutionnorms(task_.task,whichsol_.value,nrmy_,nrmslc_,nrmsuc_,nrmslx_,nrmsux_,nrmsnx_,nrmbars_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,nrmy_.x),convert(Float64,nrmslc_.x),convert(Float64,nrmsuc_.x),convert(Float64,nrmslx_.x),convert(Float64,nrmsux_.x),convert(Float64,nrmsnx_.x),convert(Float64,nrmbars_.x))
end

"""
    viol = getdviolacc{T2}(task:: MSKtask,whichsol:: Soltype,accidxlist:: Vector{T2})
    viol = getdviolacc(task_:: MSKtask,whichsol_:: Soltype,accidxlist_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `accidxlist :: Vector{Int64}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Let ``(s_n^x)^*`` be the value of variable ``(s_n^x)`` for the
specified solution. For simplicity let us assume that ``s_n^x`` is a member
of a quadratic cone, then the violation is computed as follows

```math
\\left\\{
  \\begin{array}{ll}
    \\max(0,(\\|s_n^x\\|_{2:n}^*-(s_n^x)_1^*) / \\sqrt{2}, & (s_n^x)^* \\geq -\\|(s_n^x)_{2:n}^*\\|, \\\\
    \\|(s_n^x)^*\\|, & \\mbox{otherwise.}
  \\end{array}
\\right.
```
Both when the solution is a certificate of primal infeasibility or when it is a
dual feasible solution the violation should be small.
"""
function getdviolacc end
getdviolacc(task:: MSKtask,whichsol:: Soltype,accidxlist:: Vector{T2}) where {T2} = getdviolacc(task,whichsol,convert(Vector{Int64},accidxlist))
function getdviolacc(task_:: MSKtask,whichsol_:: Soltype,accidxlist_:: Vector{Int64})
  numaccidx_ = minimum([ length(accidxlist_) ])
  __tmp_var_0 = (numaccidx_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdviolacc(task_.task,whichsol_.value,numaccidx_,accidxlist_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolbarvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of barx variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Let ``(\\bar S_j)^*`` be the value of variable ``\\bar S_j`` for the
specified solution.  Then the dual violation of the solution associated with
variable ``\\bar S_j`` is given by

```math
 \\max(-\\lambda_{\\min}(\\bar S_j),\\ 0.0).
```
Both when the solution is a certificate of primal infeasibility and when it is
dual feasible solution the violation should be small.
"""
function getdviolbarvar end
getdviolbarvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolbarvar(task,whichsol,convert(Vector{Int32},sub))
function getdviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdviolbarvar(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolcon{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

The violation of the dual solution associated with the ``i``-th constraint
is computed as follows

```math
 \\max( \\rho( (s_l^c)_i^*,(b_l^c)_i ),\\ \\rho( (s_u^c)_i^*, -(b_u^c)_i ),\\ |-y_i+(s_l^c)_i^*-(s_u^c)_i^*| )
```
where

```math
\\rho(x,l) =
  \\left\\{
    \\begin{array}{ll}
       -x,   & l > -\\infty , \\\\
       |x|, &  \\mbox{otherwise}.\\\\
    \\end{array}
  \\right.
```
Both when the solution is a certificate of primal infeasibility or it is a dual feasible solution the violation should be small.
"""
function getdviolcon end
getdviolcon(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolcon(task,whichsol,convert(Vector{Int32},sub))
function getdviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdviolcon(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolcones{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Deprecated in MOSEK 10

Let ``(s_n^x)^*`` be the value of variable ``(s_n^x)`` for the
specified solution. For simplicity let us assume that ``s_n^x`` is a member
of a quadratic cone, then the violation is computed as follows

```math
\\left\\{
  \\begin{array}{ll}
    \\max(0,(\\|s_n^x\\|_{2:n}^*-(s_n^x)_1^*) / \\sqrt{2}, & (s_n^x)^* \\geq -\\|(s_n^x)_{2:n}^*\\|, \\\\
    \\|(s_n^x)^*\\|, & \\mbox{otherwise.}
  \\end{array}
\\right.
```
Both when the solution is a certificate of primal infeasibility or when it is a
dual feasible solution the violation should be small.
"""
function getdviolcones end
getdviolcones(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolcones(task,whichsol,convert(Vector{Int32},sub))
function getdviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdviolcones(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getdviolvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getdviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of x variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

The violation of the dual solution associated with the ``j``-th variable is
computed as follows

```math
 \\max \\left(\\rho((s_l^x)_j^*,(b_l^x)_j),\\ \\rho((s_u^x)_j^*,-(b_u^x)_j),\\ |\\sum_{i=1}^{+1{numcon}} a_{ij} y_i+(s_l^x)_j^*-(s_u^x)_j^* - \\tau c_j| \\right)
```
where

```math
\\rho(x,l) =
  \\left\\{
    \\begin{array}{ll}
       -x,   & l > -\\infty , \\\\
       |x|, &  \\mbox{otherwise}
    \\end{array}
  \\right.
```
and ``\\tau=0`` if the solution is a certificate of primal infeasibility and ``\\tau=1`` otherwise. The formula for computing the violation is only shown
for the linear case but is generalized appropriately for the more general problems. Both when the solution is a certificate of primal infeasibility or when it is a dual feasible solution the violation should be small.
"""
function getdviolvar end
getdviolvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getdviolvar(task,whichsol,convert(Vector{Int32},sub))
function getdviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getdviolvar(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    inftask = getinfeasiblesubproblem(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Which solution to use when determining the infeasible subproblem.
* `inftask :: MSKtask`. A new task containing the infeasible subproblem.

Given the solution is a certificate of primal or dual infeasibility then a
primal or dual infeasible subproblem is obtained respectively.  The subproblem
tends to be much smaller than the original problem and hence it is easier to locate
the infeasibility inspecting the subproblem than the original problem.

For the procedure to be useful it is important to assign meaningful
names to constraints, variables etc. in the original task because those names
will be duplicated in the subproblem.

The function is only applicable to linear and conic quadratic optimization problems.

For more information see :numref:`doc.debugging.infeas` and :numref:`doc.shared.feas_repair`.
"""
function getinfeasiblesubproblem end
function getinfeasiblesubproblem(task_:: MSKtask,whichsol_:: Soltype)
  inftask_ = Ref(Ptr{Nothing}(1))
  res = disable_sigint() do
    @MSK_getinfeasiblesubproblem(task_.task,whichsol_.value,inftask_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(MSKtask,inftask_.x))
end

"""
    infname = getinfname{T2}(task:: MSKtask,inftype:: Inftype,whichinf:: T2)
    infname = getinfname(task_:: MSKtask,inftype_:: Inftype,whichinf_:: Int32)

* `task :: MSKtask`. An optimization task.
* `inftype :: Inftype`. Type of the information item.
* `whichinf :: Int32`. An information item.
* `infname :: AbstractString`. Name of the information item.

Obtains the name of an information item.
"""
function getinfname end
getinfname(task:: MSKtask,inftype:: Inftype,whichinf:: T2) where {T2} = getinfname(task,inftype,convert(Int32,whichinf))
function getinfname(task_:: MSKtask,inftype_:: Inftype,whichinf_:: Int32)
  infname_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @MSK_getinfname(task_.task,inftype_.value,whichinf_,infname_)
  end
  infname_str = String(infname_[1:findfirst(isequal(0),infname_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (infname_str)
end

"""
    ivalue = getintinf(task_:: MSKtask,whichiinf_:: Iinfitem)

* `task :: MSKtask`. An optimization task.
* `whichiinf :: Iinfitem`. Specifies an integer information item.
* `ivalue :: Int32`. The value of the required integer information item.

Obtains an integer information item from the task information database.
"""
function getintinf end
function getintinf(task_:: MSKtask,whichiinf_:: Iinfitem)
  ivalue_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getintinf(task_.task,whichiinf_.value,ivalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,ivalue_.x))
end

"""
    parvalue = getintparam(task_:: MSKtask,param_:: Iparam)

* `task :: MSKtask`. An optimization task.
* `param :: Iparam`. Which parameter.
* `parvalue :: Int32`. Parameter value.

Obtains the value of an integer parameter.
"""
function getintparam end
function getintparam(task_:: MSKtask,param_:: Iparam)
  parvalue_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getintparam(task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,parvalue_.x))
end

"""
    lenbarvarj = getlenbarvarj{T1}(task:: MSKtask,j:: T1)
    lenbarvarj = getlenbarvarj(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the semidefinite variable whose length if requested.
* `lenbarvarj :: Int64`. Number of scalar elements in the lower triangular part of the semidefinite variable.

Obtains the length of the ``j``-th semidefinite variable i.e. the number of elements in the lower triangular part.
"""
function getlenbarvarj end
getlenbarvarj(task:: MSKtask,j:: T1) where {T1} = getlenbarvarj(task,convert(Int32,j))
function getlenbarvarj(task_:: MSKtask,j_:: Int32)
  lenbarvarj_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getlenbarvarj(task_.task,j_-1,lenbarvarj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,lenbarvarj_.x))
end

"""
    ivalue = getlintinf(task_:: MSKtask,whichliinf_:: Liinfitem)

* `task :: MSKtask`. An optimization task.
* `whichliinf :: Liinfitem`. Specifies a long information item.
* `ivalue :: Int64`. The value of the required long integer information item.

Obtains a long integer information item from the task information database.
"""
function getlintinf end
function getlintinf(task_:: MSKtask,whichliinf_:: Liinfitem)
  ivalue_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getlintinf(task_.task,whichliinf_.value,ivalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,ivalue_.x))
end

"""
    maxnumanz = getmaxnumanz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumanz :: Int64`. Number of preallocated non-zero linear matrix elements.

Obtains number of preallocated non-zeros in ``A``. When this number of non-zeros is reached MOSEK will automatically allocate more space for ``A``.
"""
function getmaxnumanz end
function getmaxnumanz(task_:: MSKtask)
  maxnumanz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getmaxnumanz64(task_.task,maxnumanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,maxnumanz_.x))
end

"""
    maxnumbarvar = getmaxnumbarvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumbarvar :: Int32`. Maximum number of symmetric matrix variables for which space is currently preallocated.

Obtains maximum number of symmetric matrix variables for which space is currently preallocated.
"""
function getmaxnumbarvar end
function getmaxnumbarvar(task_:: MSKtask)
  maxnumbarvar_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getmaxnumbarvar(task_.task,maxnumbarvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumbarvar_.x))
end

"""
    maxnumcon = getmaxnumcon(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. Number of preallocated constraints in the optimization task.

Obtains the number of preallocated constraints in the optimization task. When this number of constraints is reached MOSEK will automatically allocate more space for constraints.
"""
function getmaxnumcon end
function getmaxnumcon(task_:: MSKtask)
  maxnumcon_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getmaxnumcon(task_.task,maxnumcon_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumcon_.x))
end

"""
    maxnumcone = getmaxnumcone(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumcone :: Int32`. Number of preallocated conic constraints in the optimization task.

Deprecated in MOSEK 10

Obtains the number of preallocated cones in the optimization task. When this
number of cones is reached MOSEK will automatically allocate space for more
cones.
"""
function getmaxnumcone end
function getmaxnumcone(task_:: MSKtask)
  maxnumcone_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getmaxnumcone(task_.task,maxnumcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumcone_.x))
end

"""
    maxnumqnz = getmaxnumqnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumqnz :: Int64`. Number of non-zero elements preallocated in quadratic coefficient matrices.

Obtains the number of preallocated non-zeros for ``Q`` (both objective and
constraints). When this number of non-zeros is reached MOSEK will
automatically allocate more space for ``Q``.
"""
function getmaxnumqnz end
function getmaxnumqnz(task_:: MSKtask)
  maxnumqnz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getmaxnumqnz64(task_.task,maxnumqnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,maxnumqnz_.x))
end

"""
    maxnumvar = getmaxnumvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `maxnumvar :: Int32`. Number of preallocated variables in the optimization task.

Obtains the number of preallocated variables in the optimization task. When this number of variables is reached MOSEK will automatically allocate more space for variables.
"""
function getmaxnumvar end
function getmaxnumvar(task_:: MSKtask)
  maxnumvar_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getmaxnumvar(task_.task,maxnumvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,maxnumvar_.x))
end

"""
    (meminuse,maxmemuse) = getmemusage(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `meminuse :: Int64`. Amount of memory currently used by the task.
* `maxmemuse :: Int64`. Maximum amount of memory used by the task until now.

Obtains information about the amount of memory used by a task.
"""
function getmemusage end
function getmemusage(task_:: MSKtask)
  maxmemuse_ = Ref(Int64(1))
  meminuse_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getmemusagetask(task_.task,meminuse_,maxmemuse_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,meminuse_.x),convert(Int64,maxmemuse_.x))
end

"""
    dvalue = getnadouinf(task_:: MSKtask,infitemname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `infitemname :: String`. The name of a double information item.
* `dvalue :: Float64`. The value of the required double information item.

Obtains a named double information item from task information database.
"""
function getnadouinf end
function getnadouinf(task_:: MSKtask,infitemname_:: AbstractString)
  dvalue_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getnadouinf(task_.task,string(infitemname_),dvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,dvalue_.x))
end

"""
    parvalue = getnadouparam(task_:: MSKtask,paramname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Float64`. Parameter value.

Obtains the value of a named double parameter.
"""
function getnadouparam end
function getnadouparam(task_:: MSKtask,paramname_:: AbstractString)
  parvalue_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getnadouparam(task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,parvalue_.x))
end

"""
    ivalue = getnaintinf(task_:: MSKtask,infitemname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `infitemname :: String`. The name of an integer information item.
* `ivalue :: Int32`. The value of the required integer information item.

Obtains a named integer information item from the task information database.
"""
function getnaintinf end
function getnaintinf(task_:: MSKtask,infitemname_:: AbstractString)
  ivalue_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnaintinf(task_.task,string(infitemname_),ivalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,ivalue_.x))
end

"""
    parvalue = getnaintparam(task_:: MSKtask,paramname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Int32`. Parameter value.

Obtains the value of a named integer parameter.
"""
function getnaintparam end
function getnaintparam(task_:: MSKtask,paramname_:: AbstractString)
  parvalue_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnaintparam(task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,parvalue_.x))
end

"""
    (len,parvalue) = getnastrparam{T2}(task:: MSKtask,paramname:: AbstractString,sizeparamname:: T2)
    (len,parvalue) = getnastrparam(task_:: MSKtask,paramname_:: AbstractString,sizeparamname_:: Int32)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `sizeparamname :: Int32`. Size of the name buffer.
* `len :: Int32`. Returns the length of the parameter value.
* `parvalue :: AbstractString`. Parameter value.

Obtains the value of a named string parameter.
"""
function getnastrparam end
getnastrparam(task:: MSKtask,paramname:: AbstractString,sizeparamname:: T2) where {T2} = getnastrparam(task,paramname,convert(Int32,sizeparamname))
function getnastrparam(task_:: MSKtask,paramname_:: AbstractString,sizeparamname_:: Int32)
  len_ = Ref(Int32(1))
  parvalue_ = zeros(UInt8,(sizeparamname_)+1)
  res = disable_sigint() do
    @MSK_getnastrparam(task_.task,string(paramname_),sizeparamname_,len_,parvalue_)
  end
  parvalue_str = String(parvalue_[1:findfirst(isequal(0),parvalue_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x),parvalue_str)
end

"""
    num = getnumacc(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. The number of affine conic constraints.

Obtains the number of affine conic constraints.
"""
function getnumacc end
function getnumacc(task_:: MSKtask)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumacc(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    numafe = getnumafe(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numafe :: Int64`. Number of affine expressions.

Obtains the number of affine expressions.
"""
function getnumafe end
function getnumafe(task_:: MSKtask)
  numafe_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumafe(task_.task,numafe_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numafe_.x))
end

"""
    numanz = getnumanz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numanz :: Int32`. Number of non-zero elements in the linear constraint matrix.

Obtains the number of non-zeros in ``A``.
"""
function getnumanz end
function getnumanz(task_:: MSKtask)
  numanz_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumanz(task_.task,numanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numanz_.x))
end

"""
    numanz = getnumanz64(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numanz :: Int64`. Number of non-zero elements in the linear constraint matrix.

Obtains the number of non-zeros in ``A``.
"""
function getnumanz64 end
function getnumanz64(task_:: MSKtask)
  numanz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumanz64(task_.task,numanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numanz_.x))
end

"""
    num = getnumbarablocktriplets(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. An upper bound on the number of elements in the block triplet form of bara.

Obtains an upper bound on the number of elements in the block triplet form of ``\\bar A``.
"""
function getnumbarablocktriplets end
function getnumbarablocktriplets(task_:: MSKtask)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumbarablocktriplets(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    nz = getnumbaranz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `nz :: Int64`. The number of nonzero block elements in barA.

Get the number of nonzero elements in ``\\bar A``.
"""
function getnumbaranz end
function getnumbaranz(task_:: MSKtask)
  nz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumbaranz(task_.task,nz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,nz_.x))
end

"""
    num = getnumbarcblocktriplets(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. An upper bound on the number of elements in the block triplet form of barc.

Obtains an upper bound on the number of elements in the block triplet form of ``\\bar C``.
"""
function getnumbarcblocktriplets end
function getnumbarcblocktriplets(task_:: MSKtask)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumbarcblocktriplets(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    nz = getnumbarcnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `nz :: Int64`. The number of nonzero elements in barc.

Obtains the number of nonzero elements in ``\\bar C``.
"""
function getnumbarcnz end
function getnumbarcnz(task_:: MSKtask)
  nz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumbarcnz(task_.task,nz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,nz_.x))
end

"""
    numbarvar = getnumbarvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numbarvar :: Int32`. Number of semidefinite variables in the problem.

Obtains the number of semidefinite variables.
"""
function getnumbarvar end
function getnumbarvar(task_:: MSKtask)
  numbarvar_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumbarvar(task_.task,numbarvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numbarvar_.x))
end

"""
    numcon = getnumcon(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numcon :: Int32`. Number of constraints.

Obtains the number of constraints.
"""
function getnumcon end
function getnumcon(task_:: MSKtask)
  numcon_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumcon(task_.task,numcon_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numcon_.x))
end

"""
    numcone = getnumcone(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numcone :: Int32`. Number of conic constraints.

Deprecated in MOSEK 10
"""
function getnumcone end
function getnumcone(task_:: MSKtask)
  numcone_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumcone(task_.task,numcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numcone_.x))
end

"""
    nummem = getnumconemem{T1}(task:: MSKtask,k:: T1)
    nummem = getnumconemem(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `nummem :: Int32`. Number of member variables in the cone.

Deprecated in MOSEK 10
"""
function getnumconemem end
getnumconemem(task:: MSKtask,k:: T1) where {T1} = getnumconemem(task,convert(Int32,k))
function getnumconemem(task_:: MSKtask,k_:: Int32)
  nummem_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumconemem(task_.task,k_-1,nummem_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,nummem_.x))
end

"""
    num = getnumdjc(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. The number of disjunctive constraints.

Obtains the number of disjunctive constraints.
"""
function getnumdjc end
function getnumdjc(task_:: MSKtask)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumdjc(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    numdomain = getnumdomain(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numdomain :: Int64`. Number of domains in the task.

Obtain the number of domains defined.
"""
function getnumdomain end
function getnumdomain(task_:: MSKtask)
  numdomain_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumdomain(task_.task,numdomain_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numdomain_.x))
end

"""
    numintvar = getnumintvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numintvar :: Int32`. Number of integer variables.

Obtains the number of integer-constrained variables.
"""
function getnumintvar end
function getnumintvar(task_:: MSKtask)
  numintvar_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumintvar(task_.task,numintvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numintvar_.x))
end

"""
    numparam = getnumparam(task_:: MSKtask,partype_:: Parametertype)

* `task :: MSKtask`. An optimization task.
* `partype :: Parametertype`. Parameter type.
* `numparam :: Int32`. Returns the number of parameters of the requested type.

Obtains the number of parameters of a given type.
"""
function getnumparam end
function getnumparam(task_:: MSKtask,partype_:: Parametertype)
  numparam_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumparam(task_.task,partype_.value,numparam_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numparam_.x))
end

"""
    numqcnz = getnumqconknz{T1}(task:: MSKtask,k:: T1)
    numqcnz = getnumqconknz(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the constraint for which the number quadratic terms should be obtained.
* `numqcnz :: Int64`. Number of quadratic terms.

Obtains the number of non-zero quadratic terms in a constraint.
"""
function getnumqconknz end
getnumqconknz(task:: MSKtask,k:: T1) where {T1} = getnumqconknz(task,convert(Int32,k))
function getnumqconknz(task_:: MSKtask,k_:: Int32)
  numqcnz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumqconknz64(task_.task,k_-1,numqcnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqcnz_.x))
end

"""
    numqonz = getnumqobjnz(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numqonz :: Int64`. Number of non-zero elements in the quadratic objective terms.

Obtains the number of non-zero quadratic terms in the objective.
"""
function getnumqobjnz end
function getnumqobjnz(task_:: MSKtask)
  numqonz_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumqobjnz64(task_.task,numqonz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqonz_.x))
end

"""
    num = getnumsymmat(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. The number of symmetric sparse matrices.

Obtains the number of symmetric matrices stored in the vector ``E``.
"""
function getnumsymmat end
function getnumsymmat(task_:: MSKtask)
  num_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getnumsymmat(task_.task,num_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,num_.x))
end

"""
    numvar = getnumvar(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numvar :: Int32`. Number of variables.

Obtains the number of variables.
"""
function getnumvar end
function getnumvar(task_:: MSKtask)
  numvar_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getnumvar(task_.task,numvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,numvar_.x))
end

"""
    objname = getobjname(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `objname :: AbstractString`. Assigned the objective name.

Obtains the name assigned to the objective function.
"""
function getobjname end
function getobjname(task_:: MSKtask)
  sizeobjname_ = (1 + getobjnamelen(task_))
  objname_ = zeros(UInt8,(sizeobjname_)+1)
  res = disable_sigint() do
    @MSK_getobjname(task_.task,sizeobjname_,objname_)
  end
  objname_str = String(objname_[1:findfirst(isequal(0),objname_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (objname_str)
end

"""
    len = getobjnamelen(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `len :: Int32`. Assigned the length of the objective name.

Obtains the length of the name assigned to the objective function.
"""
function getobjnamelen end
function getobjnamelen(task_:: MSKtask)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getobjnamelen(task_.task,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    sense = getobjsense(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `sense :: Objsense`. The returned objective sense.

Gets the objective sense of the task.
"""
function getobjsense end
function getobjsense(task_:: MSKtask)
  sense_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getobjsense(task_.task,sense_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Objsense(sense_.x))
end

"""
    parname = getparamname{T2}(task:: MSKtask,partype:: Parametertype,param:: T2)
    parname = getparamname(task_:: MSKtask,partype_:: Parametertype,param_:: Int32)

* `task :: MSKtask`. An optimization task.
* `partype :: Parametertype`. Parameter type.
* `param :: Int32`. Which parameter.
* `parname :: AbstractString`. Parameter name.

Obtains the name for a parameter `param` of type `partype`.
"""
function getparamname end
getparamname(task:: MSKtask,partype:: Parametertype,param:: T2) where {T2} = getparamname(task,partype,convert(Int32,param))
function getparamname(task_:: MSKtask,partype_:: Parametertype,param_:: Int32)
  parname_ = zeros(UInt8,MSK_MAX_STR_LEN+1)
  res = disable_sigint() do
    @MSK_getparamname(task_.task,partype_.value,param_,parname_)
  end
  parname_str = String(parname_[1:findfirst(isequal(0),parname_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (parname_str)
end

"""
    alpha = getpowerdomainalpha{T1}(task:: MSKtask,domidx:: T1)
    alpha = getpowerdomainalpha(task_:: MSKtask,domidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.
* `alpha :: Vector{Float64}`. The exponent vector of the domain.

Obtains the exponent vector ``\\alpha`` of a primal or dual power cone domain.
"""
function getpowerdomainalpha end
getpowerdomainalpha(task:: MSKtask,domidx:: T1) where {T1} = getpowerdomainalpha(task,convert(Int64,domidx))
function getpowerdomainalpha(task_:: MSKtask,domidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_getpowerdomainalpha_0 = Ref{Int64}(); __tmp_var_getpowerdomainalpha_1 = Ref{Int64}(); @MSK_getpowerdomaininfo(task_.task,(domidx_-1),__tmp_var_getpowerdomainalpha_0,__tmp_var_getpowerdomainalpha_1); __tmp_var_getpowerdomainalpha_1.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  alpha_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpowerdomainalpha(task_.task,domidx_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (n,nleft) = getpowerdomaininfo{T1}(task:: MSKtask,domidx:: T1)
    (n,nleft) = getpowerdomaininfo(task_:: MSKtask,domidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.
* `n :: Int64`. Dimension of the domain.
* `nleft :: Int64`. Number of variables on the left hand side.

Obtains structural information about a primal or dual power cone domain.
"""
function getpowerdomaininfo end
getpowerdomaininfo(task:: MSKtask,domidx:: T1) where {T1} = getpowerdomaininfo(task,convert(Int64,domidx))
function getpowerdomaininfo(task_:: MSKtask,domidx_:: Int64)
  n_ = Ref(Int64(1))
  nleft_ = Ref(Int64(1))
  res = disable_sigint() do
    @MSK_getpowerdomaininfo(task_.task,domidx_-1,n_,nleft_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,n_.x),convert(Int64,nleft_.x))
end

"""
    primalobj = getprimalobj(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `primalobj :: Float64`. Objective value corresponding to the primal solution.

Computes the primal objective value for the desired solution. Note that if the solution is an infeasibility certificate, then the fixed term in the objective is not included.
"""
function getprimalobj end
function getprimalobj(task_:: MSKtask,whichsol_:: Soltype)
  primalobj_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getprimalobj(task_.task,whichsol_.value,primalobj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,primalobj_.x))
end

"""
    (nrmxc,nrmxx,nrmbarx) = getprimalsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `nrmxc :: Float64`. The norm of the xc vector.
* `nrmxx :: Float64`. The norm of the xx vector.
* `nrmbarx :: Float64`. The norm of the barX vector.

Compute norms of the primal solution.
"""
function getprimalsolutionnorms end
function getprimalsolutionnorms(task_:: MSKtask,whichsol_:: Soltype)
  nrmbarx_ = Ref(Float64(1))
  nrmxc_ = Ref(Float64(1))
  nrmxx_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getprimalsolutionnorms(task_.task,whichsol_.value,nrmxc_,nrmxx_,nrmbarx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,nrmxc_.x),convert(Float64,nrmxx_.x),convert(Float64,nrmbarx_.x))
end

"""
    probtype = getprobtype(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `probtype :: Problemtype`. The problem type.

Obtains the problem type.
"""
function getprobtype end
function getprobtype(task_:: MSKtask)
  probtype_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getprobtype(task_.task,probtype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Problemtype(probtype_.x))
end

"""
    prosta = getprosta(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `prosta :: Prosta`. Problem status.

Obtains the problem status.
"""
function getprosta end
function getprosta(task_:: MSKtask,whichsol_:: Soltype)
  prosta_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getprosta(task_.task,whichsol_.value,prosta_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Prosta(prosta_.x))
end

"""
    viol = getpviolacc{T2}(task:: MSKtask,whichsol:: Soltype,accidxlist:: Vector{T2})
    viol = getpviolacc(task_:: MSKtask,whichsol_:: Soltype,accidxlist_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `accidxlist :: Vector{Int64}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation for a set of affine conic constraints.
Let ``x^*`` be the value of the variable ``x`` for the specified solution.
For simplicity let us assume that ``x`` is a member of a quadratic cone, then
the violation is computed as follows

```math
\\left\\{
  \\begin{array}{ll}
    \\max(0,\\|x_{2:n}\\|-x_1) / \\sqrt{2}, & x_1 \\geq -\\|x_{2:n}\\|, \\\\
    \\|x\\|, & \\mbox{otherwise.}
  \\end{array}
\\right.
```
Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.
"""
function getpviolacc end
getpviolacc(task:: MSKtask,whichsol:: Soltype,accidxlist:: Vector{T2}) where {T2} = getpviolacc(task,whichsol,convert(Vector{Int64},accidxlist))
function getpviolacc(task_:: MSKtask,whichsol_:: Soltype,accidxlist_:: Vector{Int64})
  numaccidx_ = minimum([ length(accidxlist_) ])
  __tmp_var_0 = (numaccidx_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpviolacc(task_.task,whichsol_.value,numaccidx_,accidxlist_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolbarvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of barX variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation for a set of semidefinite variables.
Let ``(\\bar X_j)^*`` be the value of the variable ``\\bar X_j`` for the
specified solution.  Then the primal violation of the solution associated with
variable ``\\bar X_j`` is given by

```math
 \\max(-\\lambda_{\\min}(\\bar X_j),\\ 0.0).
```
Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.
"""
function getpviolbarvar end
getpviolbarvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolbarvar(task,whichsol,convert(Vector{Int32},sub))
function getpviolbarvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpviolbarvar(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolcon{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation for a set of constraints.
The primal violation of the solution associated with the ``i``-th constraint is given by

```math
 \\max(\\tau l_i^c - (x_i^c)^*,\\ (x_i^c)^* - \\tau u_i^c),\\ |\\sum_{j=1}^{+1{numvar}} a_{ij} x_j^* - x_i^c|)
```
where ``\\tau=0`` if the solution is a certificate of
dual infeasibility and ``\\tau=1`` otherwise. Both when
the solution is a certificate of dual infeasibility and when it is primal
feasible the violation should be small. The above formula applies for
the linear case but is appropriately generalized in other cases.
"""
function getpviolcon end
getpviolcon(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolcon(task,whichsol,convert(Vector{Int32},sub))
function getpviolcon(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpviolcon(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolcones{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Deprecated in MOSEK 10

Computes the primal solution violation for a set of conic constraints.
Let ``x^*`` be the value of the variable ``x`` for the specified solution.
For simplicity let us assume that ``x`` is a member of a quadratic cone, then
the violation is computed as follows

```math
\\left\\{
  \\begin{array}{ll}
    \\max(0,\\|x_{2:n}\\|-x_1) / \\sqrt{2}, & x_1 \\geq -\\|x_{2:n}\\|, \\\\
    \\|x\\|, & \\mbox{otherwise.}
  \\end{array}
\\right.
```
Both when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.
"""
function getpviolcones end
getpviolcones(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolcones(task,whichsol,convert(Vector{Int32},sub))
function getpviolcones(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpviolcones(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpvioldjc{T2}(task:: MSKtask,whichsol:: Soltype,djcidxlist:: Vector{T2})
    viol = getpvioldjc(task_:: MSKtask,whichsol_:: Soltype,djcidxlist_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `djcidxlist :: Vector{Int64}`. An array of indexes of conic constraints.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

TBD
"""
function getpvioldjc end
getpvioldjc(task:: MSKtask,whichsol:: Soltype,djcidxlist:: Vector{T2}) where {T2} = getpvioldjc(task,whichsol,convert(Vector{Int64},djcidxlist))
function getpvioldjc(task_:: MSKtask,whichsol_:: Soltype,djcidxlist_:: Vector{Int64})
  numdjcidx_ = minimum([ length(djcidxlist_) ])
  __tmp_var_0 = (numdjcidx_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpvioldjc(task_.task,whichsol_.value,numdjcidx_,djcidxlist_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    viol = getpviolvar{T2}(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2})
    viol = getpviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sub :: Vector{Int32}`. An array of indexes of x variables.
* `viol :: Vector{Float64}`. List of violations corresponding to sub.

Computes the primal solution violation associated to a set of variables.
Let ``x_j^*`` be the value of ``x_j`` for the specified
solution.  Then the primal violation of the solution associated with variable
``x_j`` is given by

```math
 \\max( \\tau l_j^x - x_j^*,\\ x_j^* - \\tau u_j^x,\\ 0).
```
where ``\\tau=0`` if the solution is a certificate of
dual infeasibility and ``\\tau=1`` otherwise. Both when
the solution is a certificate of dual infeasibility and when it is primal
feasible the violation should be small.
"""
function getpviolvar end
getpviolvar(task:: MSKtask,whichsol:: Soltype,sub:: Vector{T2}) where {T2} = getpviolvar(task,whichsol,convert(Vector{Int32},sub))
function getpviolvar(task_:: MSKtask,whichsol_:: Soltype,sub_:: Vector{Int32})
  num_ = minimum([ length(sub_) ])
  __tmp_var_0 = (num_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  viol_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getpviolvar(task_.task,whichsol_.value,num_,sub_ .- Int32(1),__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (numqcnz,qcsubi,qcsubj,qcval) = getqconk{T1}(task:: MSKtask,k:: T1)
    (numqcnz,qcsubi,qcsubj,qcval) = getqconk(task_:: MSKtask,k_:: Int32)

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Which constraint.
* `numqcnz :: Int64`. Number of quadratic terms.
* `qcsubi :: Vector{Int32}`. Row subscripts for quadratic constraint matrix.
* `qcsubj :: Vector{Int32}`. Column subscripts for quadratic constraint matrix.
* `qcval :: Vector{Float64}`. Quadratic constraint coefficient values.

Obtains all the quadratic terms in a constraint. The quadratic
terms are stored sequentially in `qcsubi`, `qcsubj`, and `qcval`.
"""
function getqconk end
getqconk(task:: MSKtask,k:: T1) where {T1} = getqconk(task,convert(Int32,k))
function getqconk(task_:: MSKtask,k_:: Int32)
  numqcnz_ = Ref(Int64(1))
  maxnumqcnz_ = getnumqconknz(task_,(k_))
  __tmp_var_0 = getnumqconknz(task_,(k_))
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  qcsubi_ = __tmp_var_1
  __tmp_var_2 = getnumqconknz(task_,(k_))
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  qcsubj_ = __tmp_var_3
  __tmp_var_4 = getnumqconknz(task_,(k_))
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  qcval_ = __tmp_var_5
  qcsurp_ = convert(Int64,length(qcsubi_))
  res = disable_sigint() do
    @MSK_getqconk64(task_.task,k_-1,maxnumqcnz_,Ref(qcsurp_),numqcnz_,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqcnz_.x),__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    (numqonz,qosubi,qosubj,qoval) = getqobj(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `numqonz :: Int64`. Number of non-zero elements in the quadratic objective terms.
* `qosubi :: Vector{Int32}`. Row subscripts for quadratic objective coefficients.
* `qosubj :: Vector{Int32}`. Column subscripts for quadratic objective coefficients.
* `qoval :: Vector{Float64}`. Quadratic objective coefficient values.

Obtains the quadratic terms in the objective. The required quadratic terms
are stored sequentially in `qosubi`, `qosubj`, and `qoval`.
"""
function getqobj end
function getqobj(task_:: MSKtask)
  maxnumqonz_ = getnumqobjnz(task_)
  numqonz_ = Ref(Int64(1))
  __tmp_var_0 = (maxnumqonz_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  qosubi_ = __tmp_var_1
  __tmp_var_2 = (maxnumqonz_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  qosubj_ = __tmp_var_3
  __tmp_var_4 = (maxnumqonz_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  qoval_ = __tmp_var_5
  qosurp_ = convert(Int64,length(qosubi_))
  res = disable_sigint() do
    @MSK_getqobj64(task_.task,maxnumqonz_,Ref(qosurp_),numqonz_,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int64,numqonz_.x),__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    qoij = getqobjij{T1,T2}(task:: MSKtask,i:: T1,j:: T2)
    qoij = getqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index of the coefficient.
* `j :: Int32`. Column index of coefficient.
* `qoij :: Float64`. The required coefficient.

Obtains one coefficient ``q_{ij}^o`` in the quadratic term of the objective.
"""
function getqobjij end
getqobjij(task:: MSKtask,i:: T1,j:: T2) where {T1,T2} = getqobjij(task,convert(Int32,i),convert(Int32,j))
function getqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32)
  qoij_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getqobjij(task_.task,i_-1,j_-1,qoij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,qoij_.x))
end

"""
    redcosts = getreducedcosts{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    redcosts = getreducedcosts(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. The index of the first variable in the sequence.
* `last :: Int32`. The index of the last variable in the sequence plus 1.
* `redcosts :: Vector{Float64}`. Returns the requested reduced costs.

Computes the reduced costs for a slice of variables and returns them in the array `redcosts` i.e.

```math
:label: ais-eq-redcost

\\mathtt{redcosts}[j-\\mathtt{first}] = (s_l^x)_j-(s_u^x)_j, ~j=\\mathtt{first},\\ldots,\\mathtt{last}-1
```

"""
function getreducedcosts end
getreducedcosts(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getreducedcosts(task,whichsol,convert(Int32,first),convert(Int32,last))
function getreducedcosts(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  redcosts_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getreducedcosts(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    skc = getskc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Stakey}`. Status keys for the constraints.

Obtains the status keys for the constraints.
"""
function getskc end
function getskc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  skc_ = Vector{Int32}(undef,__tmp_var_0)
  res = disable_sigint() do
    @MSK_getskc(task_.task,whichsol_.value,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skc_])
end

"""
    skc = getskcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    skc = getskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skc :: Vector{Stakey}`. Status keys for the constraints.

Obtains the status keys for a slice of the constraints.
"""
function getskcslice end
getskcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getskcslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  skc_ = Vector{Int32}(undef,__tmp_var_0)
  res = disable_sigint() do
    @MSK_getskcslice(task_.task,whichsol_.value,first_-1,last_-1,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skc_])
end

"""
    skn = getskn(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skn :: Vector{Stakey}`. Status keys for the conic constraints.

Obtains the status keys for the conic constraints.
"""
function getskn end
function getskn(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcone(task_)
  skn_ = Vector{Int32}(undef,__tmp_var_0)
  res = disable_sigint() do
    @MSK_getskn(task_.task,whichsol_.value,skn_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skn_])
end

"""
    skx = getskx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skx :: Vector{Stakey}`. Status keys for the variables.

Obtains the status keys for the scalar variables.
"""
function getskx end
function getskx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  skx_ = Vector{Int32}(undef,__tmp_var_0)
  res = disable_sigint() do
    @MSK_getskx(task_.task,whichsol_.value,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skx_])
end

"""
    skx = getskxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    skx = getskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skx :: Vector{Stakey}`. Status keys for the variables.

Obtains the status keys for a slice of the scalar variables.
"""
function getskxslice end
getskxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getskxslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  skx_ = Vector{Int32}(undef,__tmp_var_0)
  res = disable_sigint() do
    @MSK_getskxslice(task_.task,whichsol_.value,first_-1,last_-1,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey[ Stakey(i) for i in skx_])
end

"""
    slc = getslc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Obtains the ``s_l^c`` vector for a solution.
"""
function getslc end
function getslc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getslc(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    slc = getslcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    slc = getslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Obtains a slice of the ``s_l^c`` vector for a solution.
"""
function getslcslice end
getslcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getslcslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getslcslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    slx = getslx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Obtains the ``s_l^x`` vector for a solution.
"""
function getslx end
function getslx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slx_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getslx(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    slx = getslxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    slx = getslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Obtains a slice of the ``s_l^x`` vector for a solution.
"""
function getslxslice end
getslxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getslxslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slx_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getslxslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    snx = getsnx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Obtains the ``s_n^x`` vector for a solution.
"""
function getsnx end
function getsnx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  snx_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsnx(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    snx = getsnxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    snx = getsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Obtains a slice of the ``s_n^x`` vector for a solution.
"""
function getsnxslice end
getsnxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getsnxslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  snx_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsnxslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    solsta = getsolsta(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `solsta :: Solsta`. Solution status.

Obtains the solution status.
"""
function getsolsta end
function getsolsta(task_:: MSKtask,whichsol_:: Soltype)
  solsta_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getsolsta(task_.task,whichsol_.value,solsta_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Solsta(solsta_.x))
end

"""
    (prosta,solsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx) = getsolution(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `prosta :: Prosta`. Problem status.
* `solsta :: Solsta`. Solution status.
* `skc :: Vector{Stakey}`. Status keys for the constraints.
* `skx :: Vector{Stakey}`. Status keys for the variables.
* `skn :: Vector{Stakey}`. Status keys for the conic constraints.
* `xc :: Vector{Float64}`. Primal constraint solution.
* `xx :: Vector{Float64}`. Primal variable solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Obtains the complete solution.

Consider the case of linear programming. The primal problem is given by

```math
\\begin{array}{lccccl}
  \\mbox{minimize}              &      &      & c^T x+c^f &      &        \\\\
  \\mbox{subject to} &  l^c & \\leq & A x       & \\leq & u^c,     \\\\
  &  l^x & \\leq & x         & \\leq & u^x.   \\\\
\\end{array}
```
and the corresponding dual problem is

```math
\\begin{array}{lccl}
  \\mbox{maximize}   & (l^c)^T s_l^c - (u^c)^T s_u^c         &  \\\\
  & + (l^x)^T s_l^x - (u^x)^T s_u^x + c^f &  \\\\
  \\mbox{subject to} & A^T y + s_l^x - s_u^x                 & = & c, \\\\
  & -y    + s_l^c - s_u^c                 & = & 0, \\\\
  & s_l^c,s_u^c,s_l^x,s_u^x \\geq 0.       &   &    \\\\
\\end{array}
```
A conic optimization problem has the same primal variables as in the linear case. Recall that the dual of a conic optimization problem is given by:

```math
\\begin{array}{lccccc}
  \\mbox{maximize}   & (l^c)^T s_l^c - (u^c)^T s_u^c         &      &    \\\\
  & +(l^x)^T s_l^x - (u^x)^T s_u^x + c^f  &      &    \\\\
  \\mbox{subject to} & A^T y + s_l^x - s_u^x + s_n^x         & =    & c, \\\\
  & -y + s_l^c - s_u^c                    & =    & 0, \\\\
  & s_l^c,s_u^c,s_l^x,s_u^x               & \\geq & 0, \\\\
  & s_n^x \\in \\mathcal{K}^*                        &      &    \\\\
\\end{array}
```
The mapping between variables and arguments to the function is as follows:

* `xx` : Corresponds to variable ``x`` (also denoted ``x^x``).
* `xc` : Corresponds to ``x^c:=Ax``.
* `y`  : Corresponds to variable ``y``.
* `slc`: Corresponds to variable ``s_l^c``.
* `suc`: Corresponds to variable ``s_u^c``.
* `slx`: Corresponds to variable ``s_l^x``.
* `sux`: Corresponds to variable ``s_u^x``.
* `snx`: Corresponds to variable ``s_n^x``.

The meaning of the values returned by this function depend on the *solution status* returned in the argument `solsta`. The most important possible values  of `solsta` are:

* `MSK_SOL_STA_OPTIMAL` : An optimal solution satisfying the optimality criteria for continuous problems is returned.

* `MSK_SOL_STA_INTEGER_OPTIMAL` : An optimal solution satisfying the optimality criteria for integer problems is returned.

* `MSK_SOL_STA_PRIM_FEAS` : A solution satisfying the feasibility criteria.

* `MSK_SOL_STA_PRIM_INFEAS_CER` : A primal certificate of infeasibility is returned.

* `MSK_SOL_STA_DUAL_INFEAS_CER` : A dual certificate of infeasibility is returned.

In order to retrieve the primal and dual values of semidefinite variables see `Mosek.getbarxj` and `Mosek.getbarsj`.
"""
function getsolution end
function getsolution(task_:: MSKtask,whichsol_:: Soltype)
  prosta_ = Ref(Int32(1))
  __tmp_var_0 = getnumcon(task_)
  skc_ = Vector{Int32}(undef,__tmp_var_0)
  __tmp_var_2 = getnumcone(task_)
  skn_ = Vector{Int32}(undef,__tmp_var_2)
  __tmp_var_1 = getnumvar(task_)
  skx_ = Vector{Int32}(undef,__tmp_var_1)
  __tmp_var_9 = getnumcon(task_)
  __tmp_var_10 = zeros(Float64,__tmp_var_9)
  slc_ = __tmp_var_10
  __tmp_var_13 = getnumvar(task_)
  __tmp_var_14 = zeros(Float64,__tmp_var_13)
  slx_ = __tmp_var_14
  __tmp_var_17 = getnumvar(task_)
  __tmp_var_18 = zeros(Float64,__tmp_var_17)
  snx_ = __tmp_var_18
  solsta_ = Ref(Int32(1))
  __tmp_var_11 = getnumcon(task_)
  __tmp_var_12 = zeros(Float64,__tmp_var_11)
  suc_ = __tmp_var_12
  __tmp_var_15 = getnumvar(task_)
  __tmp_var_16 = zeros(Float64,__tmp_var_15)
  sux_ = __tmp_var_16
  __tmp_var_3 = getnumcon(task_)
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  xc_ = __tmp_var_4
  __tmp_var_5 = getnumvar(task_)
  __tmp_var_6 = zeros(Float64,__tmp_var_5)
  xx_ = __tmp_var_6
  __tmp_var_7 = getnumcon(task_)
  __tmp_var_8 = zeros(Float64,__tmp_var_7)
  y_ = __tmp_var_8
  res = disable_sigint() do
    @MSK_getsolution(task_.task,whichsol_.value,prosta_,solsta_,skc_,skx_,skn_,__tmp_var_4,__tmp_var_6,__tmp_var_8,__tmp_var_10,__tmp_var_12,__tmp_var_14,__tmp_var_16,__tmp_var_18)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Prosta(prosta_.x),Solsta(solsta_.x),Stakey[ Stakey(i) for i in skc_],Stakey[ Stakey(i) for i in skx_],Stakey[ Stakey(i) for i in skn_],__tmp_var_4,__tmp_var_6,__tmp_var_8,__tmp_var_10,__tmp_var_12,__tmp_var_14,__tmp_var_16,__tmp_var_18)
end

"""
    (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone) = getsolutioninfo(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `pobj :: Float64`. The primal objective value.
* `pviolcon :: Float64`. Maximal primal bound violation for a xc variable.
* `pviolvar :: Float64`. Maximal primal bound violation for a xx variable.
* `pviolbarvar :: Float64`. Maximal primal bound violation for a barx variable.
* `pviolcone :: Float64`. Maximal primal violation of the solution with respect to the conic constraints.
* `pviolitg :: Float64`. Maximal violation in the integer constraints.
* `dobj :: Float64`. Dual objective value.
* `dviolcon :: Float64`. Maximal dual bound violation for a xc variable.
* `dviolvar :: Float64`. Maximal dual bound violation for a xx variable.
* `dviolbarvar :: Float64`. Maximal dual bound violation for a bars variable.
* `dviolcone :: Float64`. Maximum violation of the dual solution in the dual conic constraints.

Obtains information about a solution.
"""
function getsolutioninfo end
function getsolutioninfo(task_:: MSKtask,whichsol_:: Soltype)
  dobj_ = Ref(Float64(1))
  dviolbarvar_ = Ref(Float64(1))
  dviolcon_ = Ref(Float64(1))
  dviolcone_ = Ref(Float64(1))
  dviolvar_ = Ref(Float64(1))
  pobj_ = Ref(Float64(1))
  pviolbarvar_ = Ref(Float64(1))
  pviolcon_ = Ref(Float64(1))
  pviolcone_ = Ref(Float64(1))
  pviolitg_ = Ref(Float64(1))
  pviolvar_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getsolutioninfo(task_.task,whichsol_.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,pobj_.x),convert(Float64,pviolcon_.x),convert(Float64,pviolvar_.x),convert(Float64,pviolbarvar_.x),convert(Float64,pviolcone_.x),convert(Float64,pviolitg_.x),convert(Float64,dobj_.x),convert(Float64,dviolcon_.x),convert(Float64,dviolvar_.x),convert(Float64,dviolbarvar_.x),convert(Float64,dviolcone_.x))
end

"""
    (pobj,pviolcon,pviolvar,pviolbarvar,pviolcone,pviolacc,pvioldjc,pviolitg,dobj,dviolcon,dviolvar,dviolbarvar,dviolcone,dviolacc) = getsolutioninfonew(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `pobj :: Float64`. The primal objective value.
* `pviolcon :: Float64`. Maximal primal bound violation for a xc variable.
* `pviolvar :: Float64`. Maximal primal bound violation for a xx variable.
* `pviolbarvar :: Float64`. Maximal primal bound violation for a barx variable.
* `pviolcone :: Float64`. Maximal primal violation of the solution with respect to the conic constraints.
* `pviolacc :: Float64`. Maximal primal violation of the solution with respect to the affine conic constraints.
* `pvioldjc :: Float64`. Maximal primal violation of the solution with respect to the disjunctive constraints.
* `pviolitg :: Float64`. Maximal violation in the integer constraints.
* `dobj :: Float64`. Dual objective value.
* `dviolcon :: Float64`. Maximal dual bound violation for a xc variable.
* `dviolvar :: Float64`. Maximal dual bound violation for a xx variable.
* `dviolbarvar :: Float64`. Maximal dual bound violation for a bars variable.
* `dviolcone :: Float64`. Maximum violation of the dual solution in the dual conic constraints.
* `dviolacc :: Float64`. Maximum violation of the dual solution in the dual affine conic constraints.

Obtains information about a solution.
"""
function getsolutioninfonew end
function getsolutioninfonew(task_:: MSKtask,whichsol_:: Soltype)
  dobj_ = Ref(Float64(1))
  dviolacc_ = Ref(Float64(1))
  dviolbarvar_ = Ref(Float64(1))
  dviolcon_ = Ref(Float64(1))
  dviolcone_ = Ref(Float64(1))
  dviolvar_ = Ref(Float64(1))
  pobj_ = Ref(Float64(1))
  pviolacc_ = Ref(Float64(1))
  pviolbarvar_ = Ref(Float64(1))
  pviolcon_ = Ref(Float64(1))
  pviolcone_ = Ref(Float64(1))
  pvioldjc_ = Ref(Float64(1))
  pviolitg_ = Ref(Float64(1))
  pviolvar_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getsolutioninfonew(task_.task,whichsol_.value,pobj_,pviolcon_,pviolvar_,pviolbarvar_,pviolcone_,pviolacc_,pvioldjc_,pviolitg_,dobj_,dviolcon_,dviolvar_,dviolbarvar_,dviolcone_,dviolacc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Float64,pobj_.x),convert(Float64,pviolcon_.x),convert(Float64,pviolvar_.x),convert(Float64,pviolbarvar_.x),convert(Float64,pviolcone_.x),convert(Float64,pviolacc_.x),convert(Float64,pvioldjc_.x),convert(Float64,pviolitg_.x),convert(Float64,dobj_.x),convert(Float64,dviolcon_.x),convert(Float64,dviolvar_.x),convert(Float64,dviolbarvar_.x),convert(Float64,dviolcone_.x),convert(Float64,dviolacc_.x))
end

"""
    (prosta,solsta,skc,skx,skn,xc,xx,y,slc,suc,slx,sux,snx,doty) = getsolutionnew(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `prosta :: Prosta`. Problem status.
* `solsta :: Solsta`. Solution status.
* `skc :: Vector{Stakey}`. Status keys for the constraints.
* `skx :: Vector{Stakey}`. Status keys for the variables.
* `skn :: Vector{Stakey}`. Status keys for the conic constraints.
* `xc :: Vector{Float64}`. Primal constraint solution.
* `xx :: Vector{Float64}`. Primal variable solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.
* `doty :: Vector{Float64}`. Dual variables corresponding to affine conic constraints.

Obtains the complete solution. See `Mosek.getsolution` for further information.

In order to retrieve the primal and dual values of semidefinite variables see `Mosek.getbarxj` and `Mosek.getbarsj`.
"""
function getsolutionnew end
function getsolutionnew(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_19 = begin __tmp_var_getsolutionnew_0 = Ref{Int64}(); @MSK_getaccntot(task_.task,__tmp_var_getsolutionnew_0); __tmp_var_getsolutionnew_0.x end
  __tmp_var_20 = zeros(Float64,__tmp_var_19)
  doty_ = __tmp_var_20
  prosta_ = Ref(Int32(1))
  __tmp_var_0 = getnumcon(task_)
  skc_ = Vector{Int32}(undef,__tmp_var_0)
  __tmp_var_2 = getnumcone(task_)
  skn_ = Vector{Int32}(undef,__tmp_var_2)
  __tmp_var_1 = getnumvar(task_)
  skx_ = Vector{Int32}(undef,__tmp_var_1)
  __tmp_var_9 = getnumcon(task_)
  __tmp_var_10 = zeros(Float64,__tmp_var_9)
  slc_ = __tmp_var_10
  __tmp_var_13 = getnumvar(task_)
  __tmp_var_14 = zeros(Float64,__tmp_var_13)
  slx_ = __tmp_var_14
  __tmp_var_17 = getnumvar(task_)
  __tmp_var_18 = zeros(Float64,__tmp_var_17)
  snx_ = __tmp_var_18
  solsta_ = Ref(Int32(1))
  __tmp_var_11 = getnumcon(task_)
  __tmp_var_12 = zeros(Float64,__tmp_var_11)
  suc_ = __tmp_var_12
  __tmp_var_15 = getnumvar(task_)
  __tmp_var_16 = zeros(Float64,__tmp_var_15)
  sux_ = __tmp_var_16
  __tmp_var_3 = getnumcon(task_)
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  xc_ = __tmp_var_4
  __tmp_var_5 = getnumvar(task_)
  __tmp_var_6 = zeros(Float64,__tmp_var_5)
  xx_ = __tmp_var_6
  __tmp_var_7 = getnumcon(task_)
  __tmp_var_8 = zeros(Float64,__tmp_var_7)
  y_ = __tmp_var_8
  res = disable_sigint() do
    @MSK_getsolutionnew(task_.task,whichsol_.value,prosta_,solsta_,skc_,skx_,skn_,__tmp_var_4,__tmp_var_6,__tmp_var_8,__tmp_var_10,__tmp_var_12,__tmp_var_14,__tmp_var_16,__tmp_var_18,__tmp_var_20)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Prosta(prosta_.x),Solsta(solsta_.x),Stakey[ Stakey(i) for i in skc_],Stakey[ Stakey(i) for i in skx_],Stakey[ Stakey(i) for i in skn_],__tmp_var_4,__tmp_var_6,__tmp_var_8,__tmp_var_10,__tmp_var_12,__tmp_var_14,__tmp_var_16,__tmp_var_18,__tmp_var_20)
end

"""
    values = getsolutionslice{T3,T4}(task:: MSKtask,whichsol:: Soltype,solitem:: Solitem,first:: T3,last:: T4)
    values = getsolutionslice(task_:: MSKtask,whichsol_:: Soltype,solitem_:: Solitem,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `solitem :: Solitem`. Which part of the solution is required.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `values :: Vector{Float64}`. The values of the requested solution elements.

Obtains a slice of one item from the solution. The format of the solution is exactly as in `Mosek.getsolution`. The parameter `solitem` determines which of the solution vectors should be returned.
"""
function getsolutionslice end
getsolutionslice(task:: MSKtask,whichsol:: Soltype,solitem:: Solitem,first:: T3,last:: T4) where {T3,T4} = getsolutionslice(task,whichsol,solitem,convert(Int32,first),convert(Int32,last))
function getsolutionslice(task_:: MSKtask,whichsol_:: Soltype,solitem_:: Solitem,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  values_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsolutionslice(task_.task,whichsol_.value,solitem_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (subi,subj,valij) = getsparsesymmat{T1}(task:: MSKtask,idx:: T1)
    (subi,subj,valij) = getsparsesymmat(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the matrix to retrieve.
* `subi :: Vector{Int32}`. Row subscripts of the matrix non-zero elements.
* `subj :: Vector{Int32}`. Column subscripts of the matrix non-zero elements.
* `valij :: Vector{Float64}`. Coefficients of the matrix non-zero elements.

Get a single symmetric matrix from the matrix store.
"""
function getsparsesymmat end
getsparsesymmat(task:: MSKtask,idx:: T1) where {T1} = getsparsesymmat(task,convert(Int64,idx))
function getsparsesymmat(task_:: MSKtask,idx_:: Int64)
  maxlen_ = getsymmatinfo(task_,(idx_))[2]
  __tmp_var_0 = (maxlen_)
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  subi_ = __tmp_var_1
  __tmp_var_2 = (maxlen_)
  __tmp_var_3 = zeros(Int32,__tmp_var_2)
  subj_ = __tmp_var_3
  __tmp_var_4 = (maxlen_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  valij_ = __tmp_var_5
  res = disable_sigint() do
    @MSK_getsparsesymmat(task_.task,idx_-1,maxlen_,__tmp_var_1,__tmp_var_3,__tmp_var_5)
  end
  __tmp_var_1 .+= 1
  __tmp_var_3 .+= 1
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5)
end

"""
    (len,parvalue) = getstrparam(task_:: MSKtask,param_:: Sparam)

* `task :: MSKtask`. An optimization task.
* `param :: Sparam`. Which parameter.
* `len :: Int32`. The length of the parameter value.
* `parvalue :: AbstractString`. If this is not a null pointer, the parameter value is stored here.

Obtains the value of a string parameter.
"""
function getstrparam end
function getstrparam(task_:: MSKtask,param_:: Sparam)
  len_ = Ref(Int32(1))
  maxlen_ = (1 + getstrparamlen(task_,(param_)))
  parvalue_ = zeros(UInt8,(maxlen_)+1)
  res = disable_sigint() do
    @MSK_getstrparam(task_.task,param_.value,maxlen_,len_,parvalue_)
  end
  parvalue_str = String(parvalue_[1:findfirst(isequal(0),parvalue_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x),parvalue_str)
end

"""
    len = getstrparamlen(task_:: MSKtask,param_:: Sparam)

* `task :: MSKtask`. An optimization task.
* `param :: Sparam`. Which parameter.
* `len :: Int32`. The length of the parameter value.

Obtains the length of a string parameter.
"""
function getstrparamlen end
function getstrparamlen(task_:: MSKtask,param_:: Sparam)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getstrparamlen(task_.task,param_.value,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    suc = getsuc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Obtains the ``s_u^c`` vector for a solution.
"""
function getsuc end
function getsuc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  suc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsuc(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    suc = getsucslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    suc = getsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Obtains a slice of the ``s_u^c`` vector for a solution.
"""
function getsucslice end
getsucslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getsucslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  suc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsucslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    sux = getsux(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Obtains the ``s_u^x`` vector for a solution.
"""
function getsux end
function getsux(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  sux_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsux(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    sux = getsuxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    sux = getsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Obtains a slice of the ``s_u^x`` vector for a solution.
"""
function getsuxslice end
getsuxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getsuxslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  sux_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getsuxslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    (dim,nz,type) = getsymmatinfo{T1}(task:: MSKtask,idx:: T1)
    (dim,nz,type) = getsymmatinfo(task_:: MSKtask,idx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `idx :: Int64`. Index of the matrix for which information is requested.
* `dim :: Int32`. Returns the dimension of the requested matrix.
* `nz :: Int64`. Returns the number of non-zeros in the requested matrix.
* `type :: Symmattype`. Returns the type of the requested matrix.

MOSEK maintains a vector denoted by ``E`` of symmetric data matrices. This function makes it possible to obtain important information about a single matrix in ``E``.
"""
function getsymmatinfo end
getsymmatinfo(task:: MSKtask,idx:: T1) where {T1} = getsymmatinfo(task,convert(Int64,idx))
function getsymmatinfo(task_:: MSKtask,idx_:: Int64)
  dim_ = Ref(Int32(1))
  nz_ = Ref(Int64(1))
  type_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getsymmatinfo(task_.task,idx_-1,dim_,nz_,type_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,dim_.x),convert(Int64,nz_.x),Symmattype(type_.x))
end

"""
    taskname = gettaskname(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `taskname :: AbstractString`. Returns the task name.

Obtains the name assigned to the task.
"""
function gettaskname end
function gettaskname(task_:: MSKtask)
  sizetaskname_ = (1 + gettasknamelen(task_))
  taskname_ = zeros(UInt8,(sizetaskname_)+1)
  res = disable_sigint() do
    @MSK_gettaskname(task_.task,sizetaskname_,taskname_)
  end
  taskname_str = String(taskname_[1:findfirst(isequal(0),taskname_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (taskname_str)
end

"""
    len = gettasknamelen(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `len :: Int32`. Returns the length of the task name.

Obtains the length the task name.
"""
function gettasknamelen end
function gettasknamelen(task_:: MSKtask)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_gettasknamelen(task_.task,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    (bk,bl,bu) = getvarbound{T1}(task:: MSKtask,i:: T1)
    (bk,bl,bu) = getvarbound(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the variable for which the bound information should be obtained.
* `bk :: Boundkey`. Bound keys.
* `bl :: Float64`. Values for lower bounds.
* `bu :: Float64`. Values for upper bounds.

Obtains bound information for one variable.
"""
function getvarbound end
getvarbound(task:: MSKtask,i:: T1) where {T1} = getvarbound(task,convert(Int32,i))
function getvarbound(task_:: MSKtask,i_:: Int32)
  bk_ = Ref(Int32(1))
  bl_ = Ref(Float64(1))
  bu_ = Ref(Float64(1))
  res = disable_sigint() do
    @MSK_getvarbound(task_.task,i_-1,bk_,bl_,bu_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey(bk_.x),convert(Float64,bl_.x),convert(Float64,bu_.x))
end

"""
    (bk,bl,bu) = getvarboundslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    (bk,bl,bu) = getvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bk :: Vector{Boundkey}`. Bound keys.
* `bl :: Vector{Float64}`. Values for lower bounds.
* `bu :: Vector{Float64}`. Values for upper bounds.

Obtains bounds information for a slice of the variables.
"""
function getvarboundslice end
getvarboundslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = getvarboundslice(task,convert(Int32,first),convert(Int32,last))
function getvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  bk_ = Vector{Int32}(undef,__tmp_var_0)
  __tmp_var_1 = ((last_) - (first_))
  __tmp_var_2 = zeros(Float64,__tmp_var_1)
  bl_ = __tmp_var_2
  __tmp_var_3 = ((last_) - (first_))
  __tmp_var_4 = zeros(Float64,__tmp_var_3)
  bu_ = __tmp_var_4
  res = disable_sigint() do
    @MSK_getvarboundslice(task_.task,first_-1,last_-1,bk_,__tmp_var_2,__tmp_var_4)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Boundkey[ Boundkey(i) for i in bk_],__tmp_var_2,__tmp_var_4)
end

"""
    name = getvarname{T1}(task:: MSKtask,j:: T1)
    name = getvarname(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of a variable.
* `name :: AbstractString`. Returns the required name.

Obtains the name of a variable.
"""
function getvarname end
getvarname(task:: MSKtask,j:: T1) where {T1} = getvarname(task,convert(Int32,j))
function getvarname(task_:: MSKtask,j_:: Int32)
  sizename_ = (1 + getvarnamelen(task_,(j_)))
  name_ = zeros(UInt8,(sizename_)+1)
  res = disable_sigint() do
    @MSK_getvarname(task_.task,j_-1,sizename_,name_)
  end
  name_str = String(name_[1:findfirst(isequal(0),name_)-1])
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (name_str)
end

"""
    (asgn,index) = getvarnameindex(task_:: MSKtask,somename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `somename :: String`. The name which should be checked.
* `asgn :: Int32`. Is non-zero if the name somename is assigned to a variable.
* `index :: Int32`. If the name somename is assigned to a variable, then return the index of the variable.

Checks whether the name `somename` has been assigned to any variable. If so, the index of the variable is reported.
"""
function getvarnameindex end
function getvarnameindex(task_:: MSKtask,somename_:: AbstractString)
  asgn_ = Ref(Int32(1))
  index_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getvarnameindex(task_.task,string(somename_),asgn_,index_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,asgn_.x),convert(Int32,index_.x+1))
end

"""
    len = getvarnamelen{T1}(task:: MSKtask,i:: T1)
    len = getvarnamelen(task_:: MSKtask,i_:: Int32)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of a variable.
* `len :: Int32`. Returns the length of the indicated name.

Obtains the length of the name of a variable.
"""
function getvarnamelen end
getvarnamelen(task:: MSKtask,i:: T1) where {T1} = getvarnamelen(task,convert(Int32,i))
function getvarnamelen(task_:: MSKtask,i_:: Int32)
  len_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getvarnamelen(task_.task,i_-1,len_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Int32,len_.x))
end

"""
    vartype = getvartype{T1}(task:: MSKtask,j:: T1)
    vartype = getvartype(task_:: MSKtask,j_:: Int32)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `vartype :: Variabletype`. Variable type of variable index j.

Gets the variable type of one variable.
"""
function getvartype end
getvartype(task:: MSKtask,j:: T1) where {T1} = getvartype(task,convert(Int32,j))
function getvartype(task_:: MSKtask,j_:: Int32)
  vartype_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getvartype(task_.task,j_-1,vartype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Variabletype(vartype_.x))
end

"""
    vartype = getvartypelist{T1}(task:: MSKtask,subj:: Vector{T1})
    vartype = getvartypelist(task_:: MSKtask,subj_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. A list of variable indexes.
* `vartype :: Vector{Variabletype}`. Returns the variables types corresponding the variable indexes requested.

Obtains the variable type of one or more variables. Upon return `vartype[k]` is the variable type of variable `subj[k]`.
"""
function getvartypelist end
getvartypelist(task:: MSKtask,subj:: Vector{T1}) where {T1} = getvartypelist(task,convert(Vector{Int32},subj))
function getvartypelist(task_:: MSKtask,subj_:: Vector{Int32})
  num_ = minimum([ length(subj_) ])
  __tmp_var_0 = (num_)
  vartype_ = Vector{Int32}(undef,__tmp_var_0)
  res = disable_sigint() do
    @MSK_getvartypelist(task_.task,num_,subj_ .- Int32(1),vartype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Variabletype[ Variabletype(i) for i in vartype_])
end

"""
    (major,minor,revision) = getversion()

* `major :: Int32`. Major version number.
* `minor :: Int32`. Minor version number.
* `revision :: Int32`. Revision number.

Obtains MOSEK version information.
"""
function getversion end
function getversion()
  major_ = Ref(Int32(1))
  minor_ = Ref(Int32(1))
  revision_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_getversion(major_,minor_,revision_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
  (convert(Int32,major_.x),convert(Int32,minor_.x),convert(Int32,revision_.x))
end

"""
    xc = getxc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xc :: Vector{Float64}`. Primal constraint solution.

Obtains the ``x^c`` vector for a solution.
"""
function getxc end
function getxc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getxc(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    xc = getxcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    xc = getxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xc :: Vector{Float64}`. Primal constraint solution.

Obtains a slice of the ``x^c`` vector for a solution.
"""
function getxcslice end
getxcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getxcslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getxcslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    xx = getxx(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xx :: Vector{Float64}`. Primal variable solution.

Obtains the ``x^x`` vector for a solution.
"""
function getxx end
function getxx(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumvar(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xx_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getxx(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    xx = getxxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    xx = getxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xx :: Vector{Float64}`. Primal variable solution.

Obtains a slice of the ``x^x`` vector for a solution.
"""
function getxxslice end
getxxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getxxslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xx_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getxxslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    y = gety(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Obtains the ``y`` vector for a solution.
"""
function gety end
function gety(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  y_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_gety(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    y = getyslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3)
    y = getyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Obtains a slice of the ``y`` vector for a solution.
"""
function getyslice end
getyslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3) where {T2,T3} = getyslice(task,whichsol,convert(Int32,first),convert(Int32,last))
function getyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  y_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_getyslice(task_.task,whichsol_.value,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    basis = initbasissolve(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `basis :: Vector{Int32}`. The array of basis indexes to use.

Prepare a task for use with the `Mosek.solvewithbasis` function.

This function should be called

* immediately before the first call to `Mosek.solvewithbasis`, and
* immediately before any subsequent call to `Mosek.solvewithbasis` if the task has been modified.

If the basis is singular i.e. not invertible, then the error :msk:res:`err_basis_singular` is reported.
"""
function initbasissolve end
function initbasissolve(task_:: MSKtask)
  __tmp_var_0 = begin __tmp_var_initbasissolve_0 = Ref{Int32}(); @MSK_getnumcon(task_.task,__tmp_var_initbasissolve_0); __tmp_var_initbasissolve_0.x end
  __tmp_var_1 = zeros(Int32,__tmp_var_0)
  basis_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_initbasissolve(task_.task,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    inputdata{T1,T2,T3,T4,T5,T6,T7,T8,T10,T11,T13,T14}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,aptrb:: Vector{T5},aptre:: Vector{T6},asub:: Vector{T7},aval:: Vector{T8},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14})
    inputdata{T1,T2,T3,T4,T10,T11,T13,T14}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,A:: SparseMatrixCSC{Float64},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14})
    inputdata(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,c_:: Vector{Float64},cfix_:: Float64,aptrb_:: Vector{Int64},aptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. Number of preallocated constraints in the optimization task.
* `maxnumvar :: Int32`. Number of preallocated variables in the optimization task.
* `c :: Vector{Float64}`. Linear terms of the objective as a dense vector. The length is the number of variables.
* `cfix :: Float64`. Fixed term in the objective.
* `aptrb :: Vector{Int64}`. Row or column start pointers.
* `aptre :: Vector{Int64}`. Row or column end pointers.
* `asub :: Vector{Int32}`. Coefficient subscripts.
* `aval :: Vector{Float64}`. Coefficient values.
* `bkc :: Vector{Int32}`. Bound keys for the constraints.
* `blc :: Vector{Float64}`. Lower bounds for the constraints.
* `buc :: Vector{Float64}`. Upper bounds for the constraints.
* `bkx :: Vector{Int32}`. Bound keys for the variables.
* `blx :: Vector{Float64}`. Lower bounds for the variables.
* `bux :: Vector{Float64}`. Upper bounds for the variables.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

Input the linear part of an optimization problem.


The non-zeros of ``A`` are inputted column-wise in the format described in Section :ref:`doc.optimizer.cmo_rmo_matrix`.

For an explained code example see Section :ref:`doc.tutorial_lo` and Section :ref:`doc.optimizer.matrix_formats`.
"""
function inputdata end
inputdata(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,aptrb:: Vector{T5},aptre:: Vector{T6},asub:: Vector{T7},aval:: Vector{T8},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14}) where {T1,T2,T3,T4,T5,T6,T7,T8,T10,T11,T13,T14} = inputdata(task,convert(Int32,maxnumcon),convert(Int32,maxnumvar),convert(Vector{Float64},c),convert(Float64,cfix),convert(Vector{Int64},aptrb),convert(Vector{Int64},aptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval),bkc,convert(Vector{Float64},blc),convert(Vector{Float64},buc),bkx,convert(Vector{Float64},blx),convert(Vector{Float64},bux))
function inputdata(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,c:: Vector{T3},cfix:: T4,A:: SparseMatrixCSC{Float64},bkc:: Vector{Boundkey},blc:: Vector{T10},buc:: Vector{T11},bkx:: Vector{Boundkey},blx:: Vector{T13},bux:: Vector{T14}) where {T1,T2,T3,T4,T10,T11,T13,T14}
  aptrb = A.colptr[1:size(A,2)]
  aptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  inputdata(task,maxnumcon,maxnumvar,c,cfix,aptrb,aptre,asub,aval,bkc,blc,buc,bkx,blx,bux)
end
function inputdata(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,c_:: Vector{Float64},cfix_:: Float64,aptrb_:: Vector{Int64},aptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})
  bkc_i32 = Int32[item.value for item in bkc_]
  bkx_i32 = Int32[item.value for item in bkx_]
  numcon_ = minimum([ length(buc_),length(blc_),length(bkc_) ])
  numvar_ = minimum([ length(c_),length(bux_),length(blx_),length(bkx_),length(aptrb_),length(aptre_) ])
  res = disable_sigint() do
    @MSK_inputdata64(task_.task,maxnumcon_,maxnumvar_,numcon_,numvar_,c_,cfix_,aptrb_ .- Int32(1),aptre_ .- Int32(1),asub_ .- Int32(1),aval_,bkc_,blc_,buc_,bkx_,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    param = isdouparname(task_:: MSKtask,parname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `param :: Dparam`. Returns the parameter corresponding to the name, if one exists.

Checks whether `parname` is a valid double parameter name.
"""
function isdouparname end
function isdouparname(task_:: MSKtask,parname_:: AbstractString)
  param_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_isdouparname(task_.task,string(parname_),param_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Dparam(param_.x))
end

"""
    param = isintparname(task_:: MSKtask,parname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `param :: Iparam`. Returns the parameter corresponding to the name, if one exists.

Checks whether `parname` is a valid integer parameter name.
"""
function isintparname end
function isintparname(task_:: MSKtask,parname_:: AbstractString)
  param_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_isintparname(task_.task,string(parname_),param_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Iparam(param_.x))
end

"""
    param = isstrparname(task_:: MSKtask,parname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `param :: Sparam`. Returns the parameter corresponding to the name, if one exists.

Checks whether `parname` is a valid string parameter name.
"""
function isstrparname end
function isstrparname(task_:: MSKtask,parname_:: AbstractString)
  param_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_isstrparname(task_.task,string(parname_),param_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Sparam(param_.x))
end

"""
    licensecleanup()


Stops all threads and deletes all handles used by the license system. If this
function is called, it must be called as the last MOSEK API call. No other
MOSEK API calls are valid after this.
"""
function licensecleanup end
function licensecleanup()
  res = disable_sigint() do
    @MSK_licensecleanup()
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    linkfiletostream{T3}(env:: MSKenv,whichstream:: Streamtype,filename:: AbstractString,append:: T3)
    linkfiletostream(env_:: MSKenv,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `whichstream :: Streamtype`. Index of the stream.
* `filename :: String`. A valid file name.
* `append :: Int32`. If this argument is 0 the file will be overwritten, otherwise it will be appended to.

Sends all output from the stream defined by `whichstream` to the file given by `filename`.
"""
function linkfiletostream end
linkfiletostream(env:: MSKenv,whichstream:: Streamtype,filename:: AbstractString,append:: T3) where {T3} = linkfiletostream(env,whichstream,filename,convert(Int32,append))
function linkfiletostream(env_:: MSKenv,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)
  res = disable_sigint() do
    @MSK_linkfiletoenvstream(env_.env,whichstream_.value,string(filename_),append_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    linkfiletostream{T3}(task:: MSKtask,whichstream:: Streamtype,filename:: AbstractString,append:: T3)
    linkfiletostream(task_:: MSKtask,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `filename :: String`. A valid file name.
* `append :: Int32`. If this argument is 0 the output file will be overwritten, otherwise it will be appended to.

Directs all output from a task stream `whichstream` to a file `filename`.
"""
linkfiletostream(task:: MSKtask,whichstream:: Streamtype,filename:: AbstractString,append:: T3) where {T3} = linkfiletostream(task,whichstream,filename,convert(Int32,append))
function linkfiletostream(task_:: MSKtask,whichstream_:: Streamtype,filename_:: AbstractString,append_:: Int32)
  res = disable_sigint() do
    @MSK_linkfiletotaskstream(task_.task,whichstream_.value,string(filename_),append_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    onesolutionsummary(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.
* `whichsol :: Soltype`. Selects a solution.

Prints a short summary of a specified solution.
"""
function onesolutionsummary end
function onesolutionsummary(task_:: MSKtask,whichstream_:: Streamtype,whichsol_:: Soltype)
  res = disable_sigint() do
    @MSK_onesolutionsummary(task_.task,whichstream_.value,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    trmcode = optimizermt(task_:: MSKtask,addr_:: AbstractString,accesstoken_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `addr :: String`. Address of the OptServer.
* `accesstoken :: String`. Access token.
* `trmcode :: Rescode`. Is either OK or a termination response code.

Offload the optimization task to an instance of OptServer specified by `addr`, which should be a valid URL,
for example `http://server:port` or `https://server:port`. The call will block until a result is
available or the connection closes.

If the server requires authentication, the authentication token can be passed in the `accesstoken` argument.

If the server requires encryption, the keys can be passed using one of the solver parameters
:msk:sparam:`remote_tls_cert` or :msk:sparam:`remote_tls_cert_path`.
"""
function optimizermt end
function optimizermt(task_:: MSKtask,addr_:: AbstractString,accesstoken_:: AbstractString)
  trmcode_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_optimizermt(task_.task,string(addr_),string(accesstoken_),trmcode_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Rescode(trmcode_.x))
end

"""
    optimizersummary(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Prints a short summary with optimizer statistics from last optimization.
"""
function optimizersummary end
function optimizersummary(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @MSK_optimizersummary(task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    trmcode = optimize(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.
* `trmcode :: Rescode`. Is either OK or a termination response code.

Calls the optimizer. Depending on the problem type and the selected optimizer
this will call one of the optimizers in MOSEK. By default the interior point
optimizer will be selected for continuous problems.  The optimizer may be
selected manually by setting the parameter `MSK_IPAR_OPTIMIZER``.

.. msk_only:: c

   This function is equivalent to `Mosek.optimize` except for the handling of return values. This function returns errors on the left hand side. Warnings are not returned and termination codes are returned through the separate argument `trmcode`.

.. msk_only:: java and dotnet and python

   This function throws an exception if an error has occurred during the optimization, e.g the optimizer has run out of memory. Moreover it provides a termination code, relaying information about the conditions under which the optimizer terminated. For example `MSK_RES_TRM_MAX_ITERATIONS` indicates that the optimizer finished because it reached the maximum number of iterations specified by the user.
"""
function optimize end
function optimize(task_:: MSKtask)
  trmcode_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_optimizetrm(task_.task,trmcode_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Rescode(trmcode_.x))
end

"""
    primalrepair{T1,T2,T3,T4}(task:: MSKtask,wlc:: Vector{T1},wuc:: Vector{T2},wlx:: Vector{T3},wux:: Vector{T4})
    primalrepair(task_:: MSKtask,wlc_:: Vector{Float64},wuc_:: Vector{Float64},wlx_:: Vector{Float64},wux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `wlc :: Vector{Float64}`. Weights associated with relaxing lower bounds on the constraints.
* `wuc :: Vector{Float64}`. Weights associated with relaxing the upper bound on the constraints.
* `wlx :: Vector{Float64}`. Weights associated with relaxing the lower bounds of the variables.
* `wux :: Vector{Float64}`. Weights associated with relaxing the upper bounds of variables.

The function repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables where the adjustment
is computed as the minimal weighted sum of relaxations to the bounds on the constraints and variables. Observe the function only repairs the problem but does not
solve it. If an optimal solution is required the problem should be optimized after the repair.

The function is applicable to linear and conic problems possibly with integer variables.

Observe that when computing the minimal weighted relaxation the termination tolerance specified by the parameters of the task is employed. For instance
the parameter `MSK_IPAR_MIO_MODE`` can be used to make MOSEK ignore the integer constraints during the repair which usually leads to a much faster repair.
However, the drawback is of course that the repaired problem may not have an integer feasible solution.

Note the function modifies the task in place. If this is not desired, then apply the function to a cloned task.
"""
function primalrepair end
primalrepair(task:: MSKtask,wlc:: Vector{T1},wuc:: Vector{T2},wlx:: Vector{T3},wux:: Vector{T4}) where {T1,T2,T3,T4} = primalrepair(task,convert(Vector{Float64},wlc),convert(Vector{Float64},wuc),convert(Vector{Float64},wlx),convert(Vector{Float64},wux))
function primalrepair(task_:: MSKtask,wlc_:: Vector{Float64},wuc_:: Vector{Float64},wlx_:: Vector{Float64},wux_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(wlc_) < __tmp_var_0
    println("Array argument wlc is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = getnumvar(task_)
  if length(wlx_) < __tmp_var_2
    println("Array argument wlx is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = getnumcon(task_)
  if length(wuc_) < __tmp_var_1
    println("Array argument wuc is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = getnumvar(task_)
  if length(wux_) < __tmp_var_3
    println("Array argument wux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_primalrepair(task_.task,wlc_,wuc_,wlx_,wux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej) = primalsensitivity{T1,T3}(task:: MSKtask,subi:: Vector{T1},marki:: Vector{Mark},subj:: Vector{T3},markj:: Vector{Mark})
    (leftpricei,rightpricei,leftrangei,rightrangei,leftpricej,rightpricej,leftrangej,rightrangej) = primalsensitivity(task_:: MSKtask,subi_:: Vector{Int32},marki_:: Vector{Mark},subj_:: Vector{Int32},markj_:: Vector{Mark})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Indexes of constraints to analyze.
* `marki :: Vector{Int32}`. Mark which constraint bounds to analyze.
* `subj :: Vector{Int32}`. Indexes of variables to analyze.
* `markj :: Vector{Int32}`. Mark which variable bounds to analyze.
* `leftpricei :: Vector{Float64}`. Left shadow price for constraints.
* `rightpricei :: Vector{Float64}`. Right shadow price for constraints.
* `leftrangei :: Vector{Float64}`. Left range for constraints.
* `rightrangei :: Vector{Float64}`. Right range for constraints.
* `leftpricej :: Vector{Float64}`. Left shadow price for variables.
* `rightpricej :: Vector{Float64}`. Right shadow price for variables.
* `leftrangej :: Vector{Float64}`. Left range for variables.
* `rightrangej :: Vector{Float64}`. Right range for variables.

Calculates sensitivity information for bounds on variables and constraints. For details on sensitivity
analysis, the definitions of *shadow price* and *linearity interval* and an example see Section :ref:`doc.sensitivity_analysis`.

The type of sensitivity analysis to be performed (basis or optimal partition)
is controlled by the parameter `MSK_IPAR_SENSITIVITY_TYPE``.
"""
function primalsensitivity end
primalsensitivity(task:: MSKtask,subi:: Vector{T1},marki:: Vector{Mark},subj:: Vector{T3},markj:: Vector{Mark}) where {T1,T3} = primalsensitivity(task,convert(Vector{Int32},subi),marki,convert(Vector{Int32},subj),markj)
function primalsensitivity(task_:: MSKtask,subi_:: Vector{Int32},marki_:: Vector{Mark},subj_:: Vector{Int32},markj_:: Vector{Mark})
  marki_i32 = Int32[item.value for item in marki_]
  markj_i32 = Int32[item.value for item in markj_]
  numi_ = minimum([ length(subi_),length(marki_) ])
  numj_ = minimum([ length(subj_),length(markj_) ])
  __tmp_var_0 = (numi_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  leftpricei_ = __tmp_var_1
  __tmp_var_8 = (numj_)
  __tmp_var_9 = zeros(Float64,__tmp_var_8)
  leftpricej_ = __tmp_var_9
  __tmp_var_4 = (numi_)
  __tmp_var_5 = zeros(Float64,__tmp_var_4)
  leftrangei_ = __tmp_var_5
  __tmp_var_12 = (numj_)
  __tmp_var_13 = zeros(Float64,__tmp_var_12)
  leftrangej_ = __tmp_var_13
  __tmp_var_2 = (numi_)
  __tmp_var_3 = zeros(Float64,__tmp_var_2)
  rightpricei_ = __tmp_var_3
  __tmp_var_10 = (numj_)
  __tmp_var_11 = zeros(Float64,__tmp_var_10)
  rightpricej_ = __tmp_var_11
  __tmp_var_6 = (numi_)
  __tmp_var_7 = zeros(Float64,__tmp_var_6)
  rightrangei_ = __tmp_var_7
  __tmp_var_14 = (numj_)
  __tmp_var_15 = zeros(Float64,__tmp_var_14)
  rightrangej_ = __tmp_var_15
  res = disable_sigint() do
    @MSK_primalsensitivity(task_.task,numi_,subi_ .- Int32(1),marki_,numj_,subj_ .- Int32(1),markj_,__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9,__tmp_var_11,__tmp_var_13,__tmp_var_15)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1,__tmp_var_3,__tmp_var_5,__tmp_var_7,__tmp_var_9,__tmp_var_11,__tmp_var_13,__tmp_var_15)
end

"""
    printparam(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

Prints the current parameter settings to the message stream.
"""
function printparam end
function printparam(task_:: MSKtask)
  res = disable_sigint() do
    @MSK_printparam(task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacc{T1,T2,T3,T4}(task:: MSKtask,accidx:: T1,domidx:: T2,afeidxlist:: Vector{T3},b:: Vector{T4})
    putacc(task_:: MSKtask,accidx_:: Int64,domidx_:: Int64,afeidxlist_:: Vector{Int64},b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Affine conic constraint index.
* `domidx :: Int64`. Domain index.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Puts an affine conic constraint. This method overwrites an existing affine conic constraint number `accidx` with new data specified in the same format as in `Mosek.appendacc`.
"""
function putacc end
putacc(task:: MSKtask,accidx:: T1,domidx:: T2,afeidxlist:: Vector{T3},b:: Vector{T4}) where {T1,T2,T3,T4} = putacc(task,convert(Int64,accidx),convert(Int64,domidx),convert(Vector{Int64},afeidxlist),convert(Vector{Float64},b))
function putacc(task_:: MSKtask,accidx_:: Int64,domidx_:: Int64,afeidxlist_:: Vector{Int64},b_:: Vector{Float64})
  numafeidx_ = minimum([ length(afeidxlist_) ])
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putacc(task_.task,accidx_-1,domidx_-1,numafeidx_-1,afeidxlist_ .- Int32(1),b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putaccb{T1,T2}(task:: MSKtask,accidx:: T1,b:: Vector{T2})
    putaccb(task_:: MSKtask,accidx_:: Int64,b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Affine conic constraint index.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Updates an existing affine conic constraint number `accidx` by putting a new vector ``b``.
"""
function putaccb end
putaccb(task:: MSKtask,accidx:: T1,b:: Vector{T2}) where {T1,T2} = putaccb(task,convert(Int64,accidx),convert(Vector{Float64},b))
function putaccb(task_:: MSKtask,accidx_:: Int64,b_:: Vector{Float64})
  lengthb_ = minimum([ length(b_) ])
  res = disable_sigint() do
    @MSK_putaccb(task_.task,accidx_-1,lengthb_,b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putaccbj{T1,T2,T3}(task:: MSKtask,accidx:: T1,j:: T2,bj:: T3)
    putaccbj(task_:: MSKtask,accidx_:: Int64,j_:: Int64,bj_:: Float64)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Affine conic constraint index.
* `j :: Int64`. The index of an element in b to change.
* `bj :: Float64`. The new value of b[j].

Sets one value ``b[j]`` in the ``b`` vector for the affine conic constraint number `accidx`.
"""
function putaccbj end
putaccbj(task:: MSKtask,accidx:: T1,j:: T2,bj:: T3) where {T1,T2,T3} = putaccbj(task,convert(Int64,accidx),convert(Int64,j),convert(Float64,bj))
function putaccbj(task_:: MSKtask,accidx_:: Int64,j_:: Int64,bj_:: Float64)
  res = disable_sigint() do
    @MSK_putaccbj(task_.task,accidx_-1,j_-1,bj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    doty = putaccdoty{T2}(task:: MSKtask,whichsol:: Soltype,accidx:: T2)
    doty = putaccdoty(task_:: MSKtask,whichsol_:: Soltype,accidx_:: Int64)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `accidx :: Int64`. The index of the affine conic constraint.
* `doty :: Vector{Float64}`. The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.

Puts the ``\\dot{y}`` vector for a solution (the dual values of an affine conic constraint).
"""
function putaccdoty end
putaccdoty(task:: MSKtask,whichsol:: Soltype,accidx:: T2) where {T2} = putaccdoty(task,whichsol,convert(Int64,accidx))
function putaccdoty(task_:: MSKtask,whichsol_:: Soltype,accidx_:: Int64)
  __tmp_var_0 = begin __tmp_var_putaccdoty_0 = Ref{Int64}(); @MSK_getaccn(task_.task,(accidx_),__tmp_var_putaccdoty_0); __tmp_var_putaccdoty_0.x end
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  doty_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_putaccdoty(task_.task,whichsol_.value,accidx_,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    putacclist{T1,T2,T3,T4}(task:: MSKtask,accidxs:: Vector{T1},domidxs:: Vector{T2},afeidxlist:: Vector{T3},b:: Vector{T4})
    putacclist(task_:: MSKtask,accidxs_:: Vector{Int64},domidxs_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `accidxs :: Vector{Int64}`. Affine conic constraint indices.
* `domidxs :: Vector{Int64}`. Domain indices.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, can be NULL.

Puts affine conic constraints. This method overwrites existing affine conic constraints whose numbers are provided in the list `accidxs` with new data which is a concatenation of individual constraint descriptions in the same format as in `Mosek.appendacc` (see also `Mosek.appendaccs`).
"""
function putacclist end
putacclist(task:: MSKtask,accidxs:: Vector{T1},domidxs:: Vector{T2},afeidxlist:: Vector{T3},b:: Vector{T4}) where {T1,T2,T3,T4} = putacclist(task,convert(Vector{Int64},accidxs),convert(Vector{Int64},domidxs),convert(Vector{Int64},afeidxlist),convert(Vector{Float64},b))
function putacclist(task_:: MSKtask,accidxs_:: Vector{Int64},domidxs_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64})
  numaccs_ = minimum([ length(domidxs_),length(accidxs_) ])
  numafeidx_ = minimum([ length(afeidxlist_) ])
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putacclist(task_.task,numaccs_,accidxs_ .- Int32(1),domidxs_ .- Int32(1),numafeidx_-1,afeidxlist_ .- Int32(1),b_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putaccname{T1}(task:: MSKtask,accidx:: T1,name:: AbstractString)
    putaccname(task_:: MSKtask,accidx_:: Int64,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `accidx :: Int64`. Index of the affine conic constraint.
* `name :: String`. The name of the affine conic constraint.

Sets the name of an affine conic constraint.
"""
function putaccname end
putaccname(task:: MSKtask,accidx:: T1,name:: AbstractString) where {T1} = putaccname(task,convert(Int64,accidx),name)
function putaccname(task_:: MSKtask,accidx_:: Int64,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putaccname(task_.task,accidx_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacol{T1,T2,T3}(task:: MSKtask,j:: T1,subj:: Vector{T2},valj:: Vector{T3})
    putacol(task_:: MSKtask,j_:: Int32,subj_:: Vector{Int32},valj_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Column index.
* `subj :: Vector{Int32}`. Row indexes of non-zero values in column.
* `valj :: Vector{Float64}`. New non-zero values of column.

Change one column of the linear constraint matrix ``A``. Resets all the elements in column ``j`` to zero and then sets

```math
 a_{\\mathtt{subj}[k],\\mathtt{j}} = \\mathtt{valj}[k], \\mathcal{C}_q k=0,\\ldots,\\mathtt{nzj}-1.
```

"""
function putacol end
putacol(task:: MSKtask,j:: T1,subj:: Vector{T2},valj:: Vector{T3}) where {T1,T2,T3} = putacol(task,convert(Int32,j),convert(Vector{Int32},subj),convert(Vector{Float64},valj))
function putacol(task_:: MSKtask,j_:: Int32,subj_:: Vector{Int32},valj_:: Vector{Float64})
  nzj_ = minimum([ length(subj_),length(valj_) ])
  res = disable_sigint() do
    @MSK_putacol(task_.task,j_-1,nzj_,subj_ .- Int32(1),valj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacollist{T1,T2,T3,T4,T5}(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5})
    putacollist{T1}(task:: MSKtask,sub:: Vector{T1},A:: SparseMatrixCSC{Float64})
    putacollist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. Indexes of columns that should be replaced.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the columns.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the columns.
* `asub :: Vector{Int32}`. Row indexes
* `aval :: Vector{Float64}`. Coefficient values.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

Change a set of columns in the linear constraint matrix ``A`` with data in sparse triplet format. The requested columns are set to zero and then updated with:

```math
\\begin{array}{rl}
  \\mathtt{for} & i=1,\\ldots,+1{num}\\\\
              & a_{\\mathtt{asub}[k],\\mathtt{sub}[i]} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.
\\end{array}
```

"""
function putacollist end
putacollist(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5}) where {T1,T2,T3,T4,T5} = putacollist(task,convert(Vector{Int32},sub),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putacollist(task:: MSKtask,sub:: Vector{T1},A:: SparseMatrixCSC{Float64}) where {T1}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacollist(task,sub,ptrb,ptre,asub,aval)
end
function putacollist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(ptrb_),length(ptre_) ])
  res = disable_sigint() do
    @MSK_putacollist64(task_.task,num_,sub_ .- Int32(1),ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putacolslice{T1,T2,T3,T4,T5,T6}(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6})
    putacolslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2,A:: SparseMatrixCSC{Float64})
    putacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First column in the slice.
* `last :: Int32`. Last column plus one in the slice.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the columns.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the columns.
* `asub :: Vector{Int32}`. Row indexes
* `aval :: Vector{Float64}`. Coefficient values.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

Change a slice of columns in the linear constraint matrix ``A`` with data in sparse triplet format. The requested columns are set to zero and then updated with:

```math
\\begin{array}{rl}
  \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1\\\\
              & a_{\\mathtt{asub}[k],i} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.
\\end{array}
```

"""
function putacolslice end
putacolslice(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putacolslice(task,convert(Int32,first),convert(Int32,last),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putacolslice(task:: MSKtask,first:: T1,last:: T2,A:: SparseMatrixCSC{Float64}) where {T1,T2}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  asub = A.rowval
  aval = A.nzval
  putacolslice(task,first,last,ptrb,ptre,asub,aval)
end
function putacolslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  res = disable_sigint() do
    @MSK_putacolslice64(task_.task,first_-1,last_-1,ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafebarfblocktriplet{T1,T2,T3,T4,T5,T6}(task:: MSKtask,num:: T1,afeidx:: Vector{T2},barvaridx:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valkl:: Vector{T6})
    putafebarfblocktriplet(task_:: MSKtask,num_:: Int64,afeidx_:: Vector{Int64},barvaridx_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valkl_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `afeidx :: Vector{Int64}`. Constraint index.
* `barvaridx :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Inputs the ``\\barF`` matrix data in block triplet form.
"""
function putafebarfblocktriplet end
putafebarfblocktriplet(task:: MSKtask,num:: T1,afeidx:: Vector{T2},barvaridx:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valkl:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putafebarfblocktriplet(task,convert(Int64,num),convert(Vector{Int64},afeidx),convert(Vector{Int32},barvaridx),convert(Vector{Int32},subk),convert(Vector{Int32},subl),convert(Vector{Float64},valkl))
function putafebarfblocktriplet(task_:: MSKtask,num_:: Int64,afeidx_:: Vector{Int64},barvaridx_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valkl_:: Vector{Float64})
  __tmp_var_0 = (num_)
  if length(afeidx_) < __tmp_var_0
    println("Array argument afeidx is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = (num_)
  if length(barvaridx_) < __tmp_var_1
    println("Array argument barvaridx is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = (num_)
  if length(subk_) < __tmp_var_2
    println("Array argument subk is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = (num_)
  if length(subl_) < __tmp_var_3
    println("Array argument subl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_4 = (num_)
  if length(valkl_) < __tmp_var_4
    println("Array argument valkl is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putafebarfblocktriplet(task_.task,num_,afeidx_ .- Int32(1),barvaridx_ .- Int32(1),subk_ .- Int32(1),subl_ .- Int32(1),valkl_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafebarfentry{T1,T2,T3,T4}(task:: MSKtask,afeidx:: T1,barvaridx:: T2,termidx:: Vector{T3},termweight:: Vector{T4})
    putafebarfentry(task_:: MSKtask,afeidx_:: Int64,barvaridx_:: Int32,termidx_:: Vector{Int64},termweight_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index of barF.
* `barvaridx :: Int32`. Semidefinite variable index.
* `termidx :: Vector{Int64}`. Element indices in matrix storage.
* `termweight :: Vector{Float64}`. Weights in the weighted sum.

This function sets one entry ``\\barF_{ij}`` where ``i=\\mathrm{afeidx}`` is the row index in the store of
affine expressions and ``j=\\mathrm{barvaridx}`` is the index of a symmetric variable. That is, the expression

```math
\\langle \\barF_{ij}, \\bar X_j\\rangle
```
will be added to the ``i``-th affine expression.

The matrix ``\\barF_{ij}`` is specified as a weighted sum of
symmetric matrices from the symmetric matrix storage ``E``, so
``\\barF_{ij}`` is a symmetric matrix, precisely:

```math
\\barF_{\\mathrm{afeidx},\\mathrm{barvaridx}} = \\sum_{k} \\mathrm{termweight}[k] \\cdot E_{\\mathrm{termidx}[k]}.
```
By default all elements in
``\\barF`` are 0, so only non-zero elements need be added.
Setting the same entry again will overwrite the earlier entry.

The symmetric matrices from ``E`` are defined separately
using the function `Mosek.appendsparsesymmat`.
"""
function putafebarfentry end
putafebarfentry(task:: MSKtask,afeidx:: T1,barvaridx:: T2,termidx:: Vector{T3},termweight:: Vector{T4}) where {T1,T2,T3,T4} = putafebarfentry(task,convert(Int64,afeidx),convert(Int32,barvaridx),convert(Vector{Int64},termidx),convert(Vector{Float64},termweight))
function putafebarfentry(task_:: MSKtask,afeidx_:: Int64,barvaridx_:: Int32,termidx_:: Vector{Int64},termweight_:: Vector{Float64})
  numterms_ = minimum([ length(termidx_),length(termweight_) ])
  res = disable_sigint() do
    @MSK_putafebarfentry(task_.task,afeidx_-1,barvaridx_-1,numterms_,termidx_ .- Int32(1),termweight_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafebarfentrylist{T1,T2,T3,T4,T5,T6}(task:: MSKtask,afeidxlist:: Vector{T1},barvaridxlist:: Vector{T2},numtermslist:: Vector{T3},ptrtermslist:: Vector{T4},termidx:: Vector{T5},termweight:: Vector{T6})
    putafebarfentrylist(task_:: MSKtask,afeidxlist_:: Vector{Int64},barvaridxlist_:: Vector{Int32},numtermslist_:: Vector{Int64},ptrtermslist_:: Vector{Int64},termidx_:: Vector{Int64},termweight_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidxlist :: Vector{Int64}`. Row indexes of barF.
* `barvaridxlist :: Vector{Int32}`. Semidefinite variable indexes.
* `numtermslist :: Vector{Int64}`. Number of terms in the weighted sums.
* `ptrtermslist :: Vector{Int64}`. Pointer to the terms forming each entry.
* `termidx :: Vector{Int64}`. Concatenated element indexes in matrix storage.
* `termweight :: Vector{Float64}`. Concatenated weights in the weighted sum.

This function sets a list of entries in ``\\barF``. Each entry should be described as in `Mosek.putafebarfentry`
and all those descriptions should be concatenated in the input to this method. That means the ``k``-th entry set will
have row index `afeidxlist[k]`, symmetric variable index `barvaridx[k]` and the description of this term consists of
indices in ``E`` and weights appearing in positions

```math
\\mathrm{ptrtermlists}[k],\\ldots,\\mathrm{ptrtermlists}[k] + \\mathrm{numtermslist}[k] - 1
```
in the corresponding arrays `termidx` and `termweight`. See `Mosek.putafebarfentry` for details.
"""
function putafebarfentrylist end
putafebarfentrylist(task:: MSKtask,afeidxlist:: Vector{T1},barvaridxlist:: Vector{T2},numtermslist:: Vector{T3},ptrtermslist:: Vector{T4},termidx:: Vector{T5},termweight:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putafebarfentrylist(task,convert(Vector{Int64},afeidxlist),convert(Vector{Int32},barvaridxlist),convert(Vector{Int64},numtermslist),convert(Vector{Int64},ptrtermslist),convert(Vector{Int64},termidx),convert(Vector{Float64},termweight))
function putafebarfentrylist(task_:: MSKtask,afeidxlist_:: Vector{Int64},barvaridxlist_:: Vector{Int32},numtermslist_:: Vector{Int64},ptrtermslist_:: Vector{Int64},termidx_:: Vector{Int64},termweight_:: Vector{Float64})
  lenlist_ = minimum([ length(afeidxlist_),length(barvaridxlist_),length(numtermslist_),length(ptrtermslist_) ])
  lenterms_ = minimum([ length(termidx_),length(termweight_) ])
  res = disable_sigint() do
    @MSK_putafebarfentrylist(task_.task,lenlist_-1,afeidxlist_ .- Int32(1),barvaridxlist_ .- Int32(1),numtermslist_ .- Int32(1),ptrtermslist_ .- Int32(1),lenterms_-1,termidx_ .- Int32(1),termweight_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafebarfrow{T1,T2,T3,T4,T5,T6}(task:: MSKtask,afeidx:: T1,barvaridxlist:: Vector{T2},numtermlist:: Vector{T3},ptrtermlist:: Vector{T4},termidx:: Vector{T5},termweight:: Vector{T6})
    putafebarfrow(task_:: MSKtask,afeidx_:: Int64,barvaridxlist_:: Vector{Int32},numtermlist_:: Vector{Int64},ptrtermlist_:: Vector{Int64},termidx_:: Vector{Int64},termweight_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index of barF.
* `barvaridxlist :: Vector{Int32}`. Semidefinite variable indexes.
* `numtermlist :: Vector{Int64}`. Number of terms in the weighted sums.
* `ptrtermlist :: Vector{Int64}`. Pointer to the terms forming each entry.
* `termidx :: Vector{Int64}`. Concatenated element indexes in matrix storage.
* `termweight :: Vector{Float64}`. Concatenated weights in the weighted sum.

This function inputs one row in ``\\barF``. It first clears the row, i.e. sets ``\\barF_{\\mathrm{afeidx},*}=0`` and then sets the new entries. Each entry should be described as in `Mosek.putafebarfentry` and all those descriptions should be concatenated in the input to this method. That means the ``k``-th entry set will
have row index `afeidx`, symmetric variable index `barvaridx[k]` and the description of this term consists of
indices in ``E`` and weights appearing in positions

```math
\\mathrm{ptrtermlist}[k],\\ldots,\\mathrm{ptrtermlist}[k] + \\mathrm{numtermlist}[k] - 1
```
in the corresponding arrays `termidx` and `termweight`. See `Mosek.putafebarfentry` for details.
"""
function putafebarfrow end
putafebarfrow(task:: MSKtask,afeidx:: T1,barvaridxlist:: Vector{T2},numtermlist:: Vector{T3},ptrtermlist:: Vector{T4},termidx:: Vector{T5},termweight:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putafebarfrow(task,convert(Int64,afeidx),convert(Vector{Int32},barvaridxlist),convert(Vector{Int64},numtermlist),convert(Vector{Int64},ptrtermlist),convert(Vector{Int64},termidx),convert(Vector{Float64},termweight))
function putafebarfrow(task_:: MSKtask,afeidx_:: Int64,barvaridxlist_:: Vector{Int32},numtermlist_:: Vector{Int64},ptrtermlist_:: Vector{Int64},termidx_:: Vector{Int64},termweight_:: Vector{Float64})
  lenterms_ = minimum([ length(termidx_),length(termweight_) ])
  numentries_ = minimum([ length(barvaridxlist_),length(numtermlist_),length(ptrtermlist_) ])
  res = disable_sigint() do
    @MSK_putafebarfrow(task_.task,afeidx_-1,numentries_,barvaridxlist_ .- Int32(1),numtermlist_,ptrtermlist_ .- Int32(1),lenterms_,termidx_ .- Int32(1),termweight_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafefentry{T1,T2,T3}(task:: MSKtask,afeidx:: T1,j:: T2,value:: T3)
    putafefentry(task_:: MSKtask,afeidx_:: Int64,j_:: Int32,value_:: Float64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index in F.
* `j :: Int32`. Column index in F.
* `value :: Float64`. Value of the entry.

Replaces one entry in the affine expression store ``F``, that is it sets:

```math
 F_{\\mathrm{afeidx}, j} = \\mathrm{value}.
```

"""
function putafefentry end
putafefentry(task:: MSKtask,afeidx:: T1,j:: T2,value:: T3) where {T1,T2,T3} = putafefentry(task,convert(Int64,afeidx),convert(Int32,j),convert(Float64,value))
function putafefentry(task_:: MSKtask,afeidx_:: Int64,j_:: Int32,value_:: Float64)
  res = disable_sigint() do
    @MSK_putafefentry(task_.task,afeidx_-1,j_-1,value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafefentrylist{T1,T2,T3}(task:: MSKtask,afeidx:: Vector{T1},j:: Vector{T2},value:: Vector{T3})
    putafefentrylist(task_:: MSKtask,afeidx_:: Vector{Int64},j_:: Vector{Int32},value_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidx :: Vector{Int64}`. Row indices in F.
* `j :: Vector{Int32}`. Column indices in F.
* `value :: Vector{Float64}`. Values of the entries in F.

Replaces a number of entries in the affine expression store ``F``, that is it sets:

```math
 F_{\\mathrm{afeidxs}[k], j[k]} = \\mathrm{value}[k]
```
for all ``k``.
"""
function putafefentrylist end
putafefentrylist(task:: MSKtask,afeidx:: Vector{T1},j:: Vector{T2},value:: Vector{T3}) where {T1,T2,T3} = putafefentrylist(task,convert(Vector{Int64},afeidx),convert(Vector{Int32},j),convert(Vector{Float64},value))
function putafefentrylist(task_:: MSKtask,afeidx_:: Vector{Int64},j_:: Vector{Int32},value_:: Vector{Float64})
  numentries_ = minimum([ length(afeidx_),length(j_),length(value_) ])
  res = disable_sigint() do
    @MSK_putafefentrylist(task_.task,numentries_,afeidx_ .- Int32(1),j_ .- Int32(1),value_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafefrow{T1,T2,T3}(task:: MSKtask,afeidx:: T1,subi:: Vector{T2},vali:: Vector{T3})
    putafefrow(task_:: MSKtask,afeidx_:: Int64,subi_:: Vector{Int32},vali_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index.
* `subi :: Vector{Int32}`. Column indexes of non-zero values in the row.
* `vali :: Vector{Float64}`. New non-zero values in the row.

Change one row of the matrix ``F`` of affine expressions. Resets all the elements in row `afeidx` to zero and then sets

```math
 F_{\\mathtt{afeidx},\\mathtt{subi}[k]} = \\mathtt{vali}[k], \\mathcal{C}_q k=0,\\ldots,\\mathtt{nzi}-1.
```

"""
function putafefrow end
putafefrow(task:: MSKtask,afeidx:: T1,subi:: Vector{T2},vali:: Vector{T3}) where {T1,T2,T3} = putafefrow(task,convert(Int64,afeidx),convert(Vector{Int32},subi),convert(Vector{Float64},vali))
function putafefrow(task_:: MSKtask,afeidx_:: Int64,subi_:: Vector{Int32},vali_:: Vector{Float64})
  nzi_ = minimum([ length(subi_),length(vali_) ])
  res = disable_sigint() do
    @MSK_putafefrow(task_.task,afeidx_-1,nzi_,subi_ .- Int32(1),vali_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafefrowlist{T1,T2,T3,T4,T5}(task:: MSKtask,afeidxlist:: Vector{T1},nzrow:: Vector{T2},ptrrow:: Vector{T3},idxrow:: Vector{T4},valrow:: Vector{T5})
    putafefrowlist(task_:: MSKtask,afeidxlist_:: Vector{Int64},nzrow_:: Vector{Int32},ptrrow_:: Vector{Int64},idxrow_:: Vector{Int32},valrow_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidxlist :: Vector{Int64}`. Row indices.
* `nzrow :: Vector{Int32}`. Number of non-zeros in each row.
* `ptrrow :: Vector{Int64}`. Pointer to the first nonzero in each row.
* `idxrow :: Vector{Int32}`. Column indexes of non-zero values.
* `valrow :: Vector{Float64}`. New non-zero values in the rows.

Clears and then changes a number of rows of the matrix ``F`` of affine expressions. The ``k``-th of the rows to be changed has index ``i = \\mathrm{afeidxlist}[k]``, contains ``\\mathrm{numrow}[k]`` nonzeros and its description as in `Mosek.putafefrow` starts in position ``\\mathrm{ptrrow}[k]`` of the arrays `idxrow` and `valrow`. Formally, the row with index ``i`` is cleared and then set as:

```math
 F_{i,\\mathrm{idxrow}[\\mathrm{ptrrow}[k]+j]} = \\mathrm{valrow}[\\mathrm{ptrrow}[k] + j], \\mathcal{C}_q j=0,\\ldots,\\mathrm{nzrow}[k]-1.
```

"""
function putafefrowlist end
putafefrowlist(task:: MSKtask,afeidxlist:: Vector{T1},nzrow:: Vector{T2},ptrrow:: Vector{T3},idxrow:: Vector{T4},valrow:: Vector{T5}) where {T1,T2,T3,T4,T5} = putafefrowlist(task,convert(Vector{Int64},afeidxlist),convert(Vector{Int32},nzrow),convert(Vector{Int64},ptrrow),convert(Vector{Int32},idxrow),convert(Vector{Float64},valrow))
function putafefrowlist(task_:: MSKtask,afeidxlist_:: Vector{Int64},nzrow_:: Vector{Int32},ptrrow_:: Vector{Int64},idxrow_:: Vector{Int32},valrow_:: Vector{Float64})
  lenidxval_ = minimum([ length(idxrow_),length(valrow_) ])
  numafeidx_ = minimum([ length(afeidxlist_),length(nzrow_),length(ptrrow_) ])
  res = disable_sigint() do
    @MSK_putafefrowlist(task_.task,numafeidx_,afeidxlist_ .- Int32(1),nzrow_,ptrrow_ .- Int32(1),lenidxval_,idxrow_ .- Int32(1),valrow_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafeg{T1,T2}(task:: MSKtask,afeidx:: T1,gi:: T2)
    putafeg(task_:: MSKtask,afeidx_:: Int64,gi_:: Float64)

* `task :: MSKtask`. An optimization task.
* `afeidx :: Int64`. Row index.
* `gi :: Float64`. New value for the element of g.

Change one element of the vector ``g`` in affine expressions i.e.

```math
 g_{\\mathtt{afeidx}} = \\mathtt{gi}.
```

"""
function putafeg end
putafeg(task:: MSKtask,afeidx:: T1,gi:: T2) where {T1,T2} = putafeg(task,convert(Int64,afeidx),convert(Float64,gi))
function putafeg(task_:: MSKtask,afeidx_:: Int64,gi_:: Float64)
  res = disable_sigint() do
    @MSK_putafeg(task_.task,afeidx_-1,gi_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putafeglist{T1,T2}(task:: MSKtask,afeidxlist:: Vector{T1},glist:: Vector{T2})
    putafeglist(task_:: MSKtask,afeidxlist_:: Vector{Int64},glist_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `afeidxlist :: Vector{Int64}`. Indices of entries in g.
* `glist :: Vector{Float64}`. New values for the elements of g.

Changes a list of elements of the vector ``g`` in affine expressions i.e. for all ``k`` it sets

```math
 g_{\\mathrm{afeidx}[k]} = \\mathrm{glist}[k].
```

"""
function putafeglist end
putafeglist(task:: MSKtask,afeidxlist:: Vector{T1},glist:: Vector{T2}) where {T1,T2} = putafeglist(task,convert(Vector{Int64},afeidxlist),convert(Vector{Float64},glist))
function putafeglist(task_:: MSKtask,afeidxlist_:: Vector{Int64},glist_:: Vector{Float64})
  numafeidx_ = minimum([ length(afeidxlist_),length(glist_) ])
  res = disable_sigint() do
    @MSK_putafeglist(task_.task,numafeidx_-1,afeidxlist_ .- Int32(1),glist_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    slice = putafegslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2)
    slice = putafegslice(task_:: MSKtask,first_:: Int64,last_:: Int64)

* `task :: MSKtask`. An optimization task.
* `first :: Int64`. First index in the sequence.
* `last :: Int64`. Last index plus 1 in the sequence.
* `slice :: Vector{Float64}`. The slice of g as a dense vector.

Modifies a slice in the vector ``g`` of constant terms in affine expressions using the principle

```math
 g_{\\mathtt{j}} = \\mathtt{slice[j-first]}, \\mathcal{C}_q j=\\mathrm{first},..,+1{\\mathrm{last}}
```

"""
function putafegslice end
putafegslice(task:: MSKtask,first:: T1,last:: T2) where {T1,T2} = putafegslice(task,convert(Int64,first),convert(Int64,last))
function putafegslice(task_:: MSKtask,first_:: Int64,last_:: Int64)
  __tmp_var_0 = ((last_) - (first_))
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  slice_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_putafegslice(task_.task,first_-1,last_-1,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    putaij{T1,T2,T3}(task:: MSKtask,i:: T1,j:: T2,aij:: T3)
    putaij(task_:: MSKtask,i_:: Int32,j_:: Int32,aij_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Constraint (row) index.
* `j :: Int32`. Variable (column) index.
* `aij :: Float64`. New coefficient.

Changes a coefficient in the linear coefficient matrix ``A`` using the method

```math
 a_{i,j} = \\mathtt{aij}.
```

"""
function putaij end
putaij(task:: MSKtask,i:: T1,j:: T2,aij:: T3) where {T1,T2,T3} = putaij(task,convert(Int32,i),convert(Int32,j),convert(Float64,aij))
function putaij(task_:: MSKtask,i_:: Int32,j_:: Int32,aij_:: Float64)
  res = disable_sigint() do
    @MSK_putaij(task_.task,i_-1,j_-1,aij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putaijlist{T1,T2,T3}(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},valij:: Vector{T3})
    putaijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Constraint (row) indices.
* `subj :: Vector{Int32}`. Variable (column) indices.
* `valij :: Vector{Float64}`. New coefficient values.

Changes one or more coefficients in ``A`` using the method

```math
 a_{\\mathtt{subi[k]},\\mathtt{subj[k]}} = \\mathtt{valij[k]}, \\mathcal{C}_q k=1,\\ldots,+1{num}.
```
Duplicates are not allowed.
"""
function putaijlist end
putaijlist(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},valij:: Vector{T3}) where {T1,T2,T3} = putaijlist(task,convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Float64},valij))
function putaijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},valij_:: Vector{Float64})
  num_ = minimum([ length(subi_),length(subj_),length(valij_) ])
  res = disable_sigint() do
    @MSK_putaijlist64(task_.task,num_,subi_ .- Int32(1),subj_ .- Int32(1),valij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putarow{T1,T2,T3}(task:: MSKtask,i:: T1,subi:: Vector{T2},vali:: Vector{T3})
    putarow(task_:: MSKtask,i_:: Int32,subi_:: Vector{Int32},vali_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index.
* `subi :: Vector{Int32}`. Column indexes of non-zero values in row.
* `vali :: Vector{Float64}`. New non-zero values of row.

Change one row of the linear constraint matrix ``A``. Resets all the elements in row ``i`` to zero and then sets

```math
 a_{\\mathtt{i},\\mathtt{subi}[k]} = \\mathtt{vali}[k], \\mathcal{C}_q k=0,\\ldots,\\mathtt{nzi}-1.
```

"""
function putarow end
putarow(task:: MSKtask,i:: T1,subi:: Vector{T2},vali:: Vector{T3}) where {T1,T2,T3} = putarow(task,convert(Int32,i),convert(Vector{Int32},subi),convert(Vector{Float64},vali))
function putarow(task_:: MSKtask,i_:: Int32,subi_:: Vector{Int32},vali_:: Vector{Float64})
  nzi_ = minimum([ length(subi_),length(vali_) ])
  res = disable_sigint() do
    @MSK_putarow(task_.task,i_-1,nzi_,subi_ .- Int32(1),vali_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putarowlist{T1,T2,T3,T4,T5}(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5})
    putarowlist{T1}(task:: MSKtask,sub:: Vector{T1},At:: SparseMatrixCSC{Float64})
    putarowlist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. Indexes of rows or columns that should be replaced.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the rows.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the rows.
* `asub :: Vector{Int32}`. Variable indexes.
* `aval :: Vector{Float64}`. Coefficient values.
* `At :: SparseMatrixCSC{Float64}`. Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced

Change a set of rows in the linear constraint matrix ``A`` with data in sparse triplet format. The requested rows are set to zero and then updated with:

```math
\\begin{array}{rl}
  \\mathtt{for} & i=1,\\ldots,+1{num} \\\\
               & a_{\\mathtt{sub}[i],\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.
\\end{array}
```

"""
function putarowlist end
putarowlist(task:: MSKtask,sub:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},asub:: Vector{T4},aval:: Vector{T5}) where {T1,T2,T3,T4,T5} = putarowlist(task,convert(Vector{Int32},sub),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putarowlist(task:: MSKtask,sub:: Vector{T1},At:: SparseMatrixCSC{Float64}) where {T1}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowlist(task,sub,ptrb,ptre,asub,aval)
end
function putarowlist(task_:: MSKtask,sub_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(ptrb_),length(ptre_) ])
  res = disable_sigint() do
    @MSK_putarowlist64(task_.task,num_,sub_ .- Int32(1),ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putarowslice{T1,T2,T3,T4,T5,T6}(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6})
    putarowslice{T1,T2}(task:: MSKtask,first:: T1,last:: T2,At:: SparseMatrixCSC{Float64})
    putarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First row in the slice.
* `last :: Int32`. Last row plus one in the slice.
* `ptrb :: Vector{Int64}`. Array of pointers to the first element in the rows.
* `ptre :: Vector{Int64}`. Array of pointers to the last element plus one in the rows.
* `asub :: Vector{Int32}`. Column indexes of new elements.
* `aval :: Vector{Float64}`. Coefficient values.
* `At :: SparseMatrixCSC{Float64}`. Transposed matrix defining the row values. Note that for efficiency reasons the *columns* of this matrix defines the *rows* to be replaced

Change a slice of rows in the linear constraint matrix ``A`` with data in sparse triplet format. The requested rows are set to zero and then updated with:

```math
\\begin{array}{rl}
  \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1 \\\\
               & a_{\\mathtt{sub}[i],\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\mathcal{C}_q k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.
\\end{array}
```

"""
function putarowslice end
putarowslice(task:: MSKtask,first:: T1,last:: T2,ptrb:: Vector{T3},ptre:: Vector{T4},asub:: Vector{T5},aval:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putarowslice(task,convert(Int32,first),convert(Int32,last),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},asub),convert(Vector{Float64},aval))
function putarowslice(task:: MSKtask,first:: T1,last:: T2,At:: SparseMatrixCSC{Float64}) where {T1,T2}
  ptrb = At.colptr[1:size(At,2)]
  ptre = At.colptr[2:size(At,2)+1]
  asub = At.rowval
  aval = At.nzval
  putarowslice(task,first,last,ptrb,ptre,asub,aval)
end
function putarowslice(task_:: MSKtask,first_:: Int32,last_:: Int32,ptrb_:: Vector{Int64},ptre_:: Vector{Int64},asub_:: Vector{Int32},aval_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(ptrb_) < __tmp_var_0
    println("Array argument ptrb is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = ((last_) - (first_))
  if length(ptre_) < __tmp_var_1
    println("Array argument ptre is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putarowslice64(task_.task,first_-1,last_-1,ptrb_ .- Int32(1),ptre_ .- Int32(1),asub_ .- Int32(1),aval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putatruncatetol{T1}(task:: MSKtask,tolzero:: T1)
    putatruncatetol(task_:: MSKtask,tolzero_:: Float64)

* `task :: MSKtask`. An optimization task.
* `tolzero :: Float64`. Truncation tolerance.

Truncates (sets to zero) all elements in ``A``  that satisfy

```math
 |a_{i,j}| \\leq \\mathtt{tolzero}.
```

"""
function putatruncatetol end
putatruncatetol(task:: MSKtask,tolzero:: T1) where {T1} = putatruncatetol(task,convert(Float64,tolzero))
function putatruncatetol(task_:: MSKtask,tolzero_:: Float64)
  res = disable_sigint() do
    @MSK_putatruncatetol(task_.task,tolzero_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarablocktriplet{T1,T2,T3,T4,T5,T6}(task:: MSKtask,num:: T1,subi:: Vector{T2},subj:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valijkl:: Vector{T6})
    putbarablocktriplet(task_:: MSKtask,num_:: Int64,subi_:: Vector{Int32},subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valijkl_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subi :: Vector{Int32}`. Constraint index.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valijkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Inputs the ``\\bar A`` matrix in block triplet form.
"""
function putbarablocktriplet end
putbarablocktriplet(task:: MSKtask,num:: T1,subi:: Vector{T2},subj:: Vector{T3},subk:: Vector{T4},subl:: Vector{T5},valijkl:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putbarablocktriplet(task,convert(Int64,num),convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Int32},subk),convert(Vector{Int32},subl),convert(Vector{Float64},valijkl))
function putbarablocktriplet(task_:: MSKtask,num_:: Int64,subi_:: Vector{Int32},subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valijkl_:: Vector{Float64})
  __tmp_var_0 = (num_)
  if length(subi_) < __tmp_var_0
    println("Array argument subi is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = (num_)
  if length(subj_) < __tmp_var_1
    println("Array argument subj is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = (num_)
  if length(subk_) < __tmp_var_2
    println("Array argument subk is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = (num_)
  if length(subl_) < __tmp_var_3
    println("Array argument subl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_4 = (num_)
  if length(valijkl_) < __tmp_var_4
    println("Array argument valijkl is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putbarablocktriplet(task_.task,num_,subi_ .- Int32(1),subj_ .- Int32(1),subk_ .- Int32(1),subl_ .- Int32(1),valijkl_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbaraij{T1,T2,T3,T4}(task:: MSKtask,i:: T1,j:: T2,sub:: Vector{T3},weights:: Vector{T4})
    putbaraij(task_:: MSKtask,i_:: Int32,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index of barA.
* `j :: Int32`. Column index of barA.
* `sub :: Vector{Int64}`. Element indexes in matrix storage.
* `weights :: Vector{Float64}`. Weights in the weighted sum.

This function sets one element in the ``\\bar A`` matrix.

Each element in the ``\\bar A`` matrix is a weighted sum of
symmetric matrices from the symmetric matrix storage ``E``, so
``\\bar A_{ij}`` is a symmetric matrix. By default all elements in
``\\bar A`` are 0, so only non-zero elements need be added.
Setting the same element again will overwrite the earlier entry.

The symmetric matrices from ``E`` are defined separately
using the function `Mosek.appendsparsesymmat`.
"""
function putbaraij end
putbaraij(task:: MSKtask,i:: T1,j:: T2,sub:: Vector{T3},weights:: Vector{T4}) where {T1,T2,T3,T4} = putbaraij(task,convert(Int32,i),convert(Int32,j),convert(Vector{Int64},sub),convert(Vector{Float64},weights))
function putbaraij(task_:: MSKtask,i_:: Int32,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(weights_) ])
  res = disable_sigint() do
    @MSK_putbaraij(task_.task,i_-1,j_-1,num_,sub_ .- Int32(1),weights_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbaraijlist{T1,T2,T3,T4,T5,T6}(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},alphaptrb:: Vector{T3},alphaptre:: Vector{T4},matidx:: Vector{T5},weights:: Vector{T6})
    putbaraijlist{T1,T2}(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},A:: SparseMatrixCSC{Float64})
    putbaraijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},alphaptrb_:: Vector{Int64},alphaptre_:: Vector{Int64},matidx_:: Vector{Int64},weights_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Row index of barA.
* `subj :: Vector{Int32}`. Column index of barA.
* `alphaptrb :: Vector{Int64}`. Start entries for terms in the weighted sum.
* `alphaptre :: Vector{Int64}`. End entries for terms in the weighted sum.
* `matidx :: Vector{Int64}`. Element indexes in matrix storage.
* `weights :: Vector{Float64}`. Weights in the weighted sum.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

This function sets a list of elements in the ``\\bar A`` matrix.

Each element in the ``\\bar A`` matrix is a weighted sum of
symmetric matrices from the symmetric matrix storage ``E``, so
``\\bar A_{ij}`` is a symmetric matrix. By default all elements in
``\\bar A`` are 0, so only non-zero elements need be added.
Setting the same element again will overwrite the earlier entry.

The symmetric matrices from ``E`` are defined separately
using the function `Mosek.appendsparsesymmat`.
"""
function putbaraijlist end
putbaraijlist(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},alphaptrb:: Vector{T3},alphaptre:: Vector{T4},matidx:: Vector{T5},weights:: Vector{T6}) where {T1,T2,T3,T4,T5,T6} = putbaraijlist(task,convert(Vector{Int32},subi),convert(Vector{Int32},subj),convert(Vector{Int64},alphaptrb),convert(Vector{Int64},alphaptre),convert(Vector{Int64},matidx),convert(Vector{Float64},weights))
function putbaraijlist(task:: MSKtask,subi:: Vector{T1},subj:: Vector{T2},A:: SparseMatrixCSC{Float64}) where {T1,T2}
  alphaptrb = A.colptr[1:size(A,2)]
  alphaptre = A.colptr[2:size(A,2)+1]
  matidx = A.rowval
  weights = A.nzval
  putbaraijlist(task,subi,subj,alphaptrb,alphaptre,matidx,weights)
end
function putbaraijlist(task_:: MSKtask,subi_:: Vector{Int32},subj_:: Vector{Int32},alphaptrb_:: Vector{Int64},alphaptre_:: Vector{Int64},matidx_:: Vector{Int64},weights_:: Vector{Float64})
  num_ = minimum([ length(subi_),length(subj_),length(alphaptrb_),length(alphaptre_) ])
  res = disable_sigint() do
    @MSK_putbaraijlist(task_.task,num_-1,subi_ .- Int32(1),subj_ .- Int32(1),alphaptrb_,alphaptre_,matidx_ .- Int32(1),weights_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbararowlist{T1,T2,T3,T4,T5,T6,T7}(task:: MSKtask,subi:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},subj:: Vector{T4},nummat:: Vector{T5},matidx:: Vector{T6},weights:: Vector{T7})
    putbararowlist{T1,T6,T7}(task:: MSKtask,subi:: Vector{T1},A:: SparseMatrixCSC{Float64},matidx:: Vector{T6},weights:: Vector{T7})
    putbararowlist(task_:: MSKtask,subi_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},subj_:: Vector{Int32},nummat_:: Vector{Int64},matidx_:: Vector{Int64},weights_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `subi :: Vector{Int32}`. Row indexes of barA.
* `ptrb :: Vector{Int64}`. Start of rows in barA.
* `ptre :: Vector{Int64}`. End of rows in barA.
* `subj :: Vector{Int32}`. Column index of barA.
* `nummat :: Vector{Int64}`. Number of entries in weighted sum of matrixes.
* `matidx :: Vector{Int64}`. Matrix indexes for weighted sum of matrixes.
* `weights :: Vector{Float64}`. Weights for weighted sum of matrixes.
* `A :: SparseMatrixCSC{Float64}`. Sparse matrix defining the column values

This function replaces a list of rows in the ``\\bar A`` matrix.
"""
function putbararowlist end
putbararowlist(task:: MSKtask,subi:: Vector{T1},ptrb:: Vector{T2},ptre:: Vector{T3},subj:: Vector{T4},nummat:: Vector{T5},matidx:: Vector{T6},weights:: Vector{T7}) where {T1,T2,T3,T4,T5,T6,T7} = putbararowlist(task,convert(Vector{Int32},subi),convert(Vector{Int64},ptrb),convert(Vector{Int64},ptre),convert(Vector{Int32},subj),convert(Vector{Int64},nummat),convert(Vector{Int64},matidx),convert(Vector{Float64},weights))
function putbararowlist(task:: MSKtask,subi:: Vector{T1},A:: SparseMatrixCSC{Float64},matidx:: Vector{T6},weights:: Vector{T7}) where {T1,T6,T7}
  ptrb = A.colptr[1:size(A,2)]
  ptre = A.colptr[2:size(A,2)+1]
  subj = A.rowval
  nummat = A.nzval
  putbararowlist(task,subi,ptrb,ptre,subj,nummat,matidx,weights)
end
function putbararowlist(task_:: MSKtask,subi_:: Vector{Int32},ptrb_:: Vector{Int64},ptre_:: Vector{Int64},subj_:: Vector{Int32},nummat_:: Vector{Int64},matidx_:: Vector{Int64},weights_:: Vector{Float64})
  num_ = minimum([ length(subi_),length(ptrb_),length(ptre_) ])
  __tmp_var_0 = length((subj_))
  if length(nummat_) < __tmp_var_0
    println("Array argument nummat is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = sum((nummat_))
  if length(matidx_) < __tmp_var_1
    println("Array argument matidx is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = sum((nummat_))
  if length(weights_) < __tmp_var_2
    println("Array argument weights is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putbararowlist(task_.task,num_-1,subi_ .- Int32(1),ptrb_ .- Int32(1),ptre_ .- Int32(1),subj_ .- Int32(1),nummat_ .- Int32(1),matidx_ .- Int32(1),weights_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarcblocktriplet{T1,T2,T3,T4,T5}(task:: MSKtask,num:: T1,subj:: Vector{T2},subk:: Vector{T3},subl:: Vector{T4},valjkl:: Vector{T5})
    putbarcblocktriplet(task_:: MSKtask,num_:: Int64,subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valjkl_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `num :: Int64`. Number of elements in the block triplet form.
* `subj :: Vector{Int32}`. Symmetric matrix variable index.
* `subk :: Vector{Int32}`. Block row index.
* `subl :: Vector{Int32}`. Block column index.
* `valjkl :: Vector{Float64}`. The numerical value associated with each block triplet.

Inputs the ``\\bar C`` matrix in block triplet form.
"""
function putbarcblocktriplet end
putbarcblocktriplet(task:: MSKtask,num:: T1,subj:: Vector{T2},subk:: Vector{T3},subl:: Vector{T4},valjkl:: Vector{T5}) where {T1,T2,T3,T4,T5} = putbarcblocktriplet(task,convert(Int64,num),convert(Vector{Int32},subj),convert(Vector{Int32},subk),convert(Vector{Int32},subl),convert(Vector{Float64},valjkl))
function putbarcblocktriplet(task_:: MSKtask,num_:: Int64,subj_:: Vector{Int32},subk_:: Vector{Int32},subl_:: Vector{Int32},valjkl_:: Vector{Float64})
  __tmp_var_0 = (num_)
  if length(subj_) < __tmp_var_0
    println("Array argument subj is not long enough")
    throw(BoundsError())
  end
  __tmp_var_1 = (num_)
  if length(subk_) < __tmp_var_1
    println("Array argument subk is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = (num_)
  if length(subl_) < __tmp_var_2
    println("Array argument subl is not long enough")
    throw(BoundsError())
  end
  __tmp_var_3 = (num_)
  if length(valjkl_) < __tmp_var_3
    println("Array argument valjkl is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putbarcblocktriplet(task_.task,num_,subj_ .- Int32(1),subk_ .- Int32(1),subl_ .- Int32(1),valjkl_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarcj{T1,T2,T3}(task:: MSKtask,j:: T1,sub:: Vector{T2},weights:: Vector{T3})
    putbarcj(task_:: MSKtask,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the element in barc` that should be changed.
* `sub :: Vector{Int64}`. sub is list of indexes of those symmetric matrices appearing in sum.
* `weights :: Vector{Float64}`. The weights of the terms in the weighted sum.

This function sets one entry in the ``\\bar C`` vector.

Each element in the ``\\bar C`` vector is a weighted sum of
symmetric matrices from the symmetric matrix storage ``E``, so
``\\bar C_{j}`` is a symmetric matrix. By default all elements in
``\\bar C`` are 0, so only non-zero elements need be added.
Setting the same element again will overwrite the earlier entry.

The symmetric matrices from ``E`` are defined separately
using the function `Mosek.appendsparsesymmat`.
"""
function putbarcj end
putbarcj(task:: MSKtask,j:: T1,sub:: Vector{T2},weights:: Vector{T3}) where {T1,T2,T3} = putbarcj(task,convert(Int32,j),convert(Vector{Int64},sub),convert(Vector{Float64},weights))
function putbarcj(task_:: MSKtask,j_:: Int32,sub_:: Vector{Int64},weights_:: Vector{Float64})
  num_ = minimum([ length(sub_),length(weights_) ])
  res = disable_sigint() do
    @MSK_putbarcj(task_.task,j_-1,num_,sub_ .- Int32(1),weights_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarsj{T2,T3}(task:: MSKtask,whichsol:: Soltype,j:: T2,barsj:: Vector{T3})
    putbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barsj_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barsj :: Vector{Float64}`. Value of the j'th variable of barx.

Sets the dual solution for a semidefinite variable.
"""
function putbarsj end
putbarsj(task:: MSKtask,whichsol:: Soltype,j:: T2,barsj:: Vector{T3}) where {T2,T3} = putbarsj(task,whichsol,convert(Int32,j),convert(Vector{Float64},barsj))
function putbarsj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barsj_:: Vector{Float64})
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  if length(barsj_) < __tmp_var_0
    println("Array argument barsj is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putbarsj(task_.task,whichsol_.value,j_-1,barsj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarvarname{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
    putbarvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `name :: String`. The variable name.

Sets the name of a semidefinite variable.
"""
function putbarvarname end
putbarvarname(task:: MSKtask,j:: T1,name:: AbstractString) where {T1} = putbarvarname(task,convert(Int32,j),name)
function putbarvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putbarvarname(task_.task,j_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putbarxj{T2,T3}(task:: MSKtask,whichsol:: Soltype,j:: T2,barxj:: Vector{T3})
    putbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barxj_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `j :: Int32`. Index of the semidefinite variable.
* `barxj :: Vector{Float64}`. Value of the j'th variable of barx.

Sets the primal solution for a semidefinite variable.
"""
function putbarxj end
putbarxj(task:: MSKtask,whichsol:: Soltype,j:: T2,barxj:: Vector{T3}) where {T2,T3} = putbarxj(task,whichsol,convert(Int32,j),convert(Vector{Float64},barxj))
function putbarxj(task_:: MSKtask,whichsol_:: Soltype,j_:: Int32,barxj_:: Vector{Float64})
  __tmp_var_0 = getlenbarvarj(task_,(j_))
  if length(barxj_) < __tmp_var_0
    println("Array argument barxj is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putbarxj(task_.task,whichsol_.value,j_-1,barxj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcfix{T1}(task:: MSKtask,cfix:: T1)
    putcfix(task_:: MSKtask,cfix_:: Float64)

* `task :: MSKtask`. An optimization task.
* `cfix :: Float64`. Fixed term in the objective.

Replaces the fixed term in the objective by a new one.
"""
function putcfix end
putcfix(task:: MSKtask,cfix:: T1) where {T1} = putcfix(task,convert(Float64,cfix))
function putcfix(task_:: MSKtask,cfix_:: Float64)
  res = disable_sigint() do
    @MSK_putcfix(task_.task,cfix_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcj{T1,T2}(task:: MSKtask,j:: T1,cj:: T2)
    putcj(task_:: MSKtask,j_:: Int32,cj_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable whose objective coefficient should be changed.
* `cj :: Float64`. New coefficient value.

Modifies one coefficient in the linear objective vector ``c``, i.e.

```math
 c_{\\mathtt{j}} = \\mathtt{cj}.
```
If the absolute value exceeds `MSK_DPAR_DATA_TOL_C_HUGE`` an error is generated. If the absolute value exceeds `MSK_DPAR_DATA_TOL_CJ_LARGE``, a warning is generated, but the coefficient is inputted as specified.
"""
function putcj end
putcj(task:: MSKtask,j:: T1,cj:: T2) where {T1,T2} = putcj(task,convert(Int32,j),convert(Float64,cj))
function putcj(task_:: MSKtask,j_:: Int32,cj_:: Float64)
  res = disable_sigint() do
    @MSK_putcj(task_.task,j_-1,cj_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putclist{T1,T2}(task:: MSKtask,subj:: Vector{T1},val:: Vector{T2})
    putclist(task_:: MSKtask,subj_:: Vector{Int32},val_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. Indices of variables for which objective coefficients should be changed.
* `val :: Vector{Float64}`. New numerical values for the objective coefficients that should be modified.

Modifies the coefficients in the linear term ``c`` in the objective using the principle

```math
 c_{\\mathtt{subj[t]}} = \\mathtt{val[t]}, \\mathcal{C}_q t=1,\\ldots,+1{num}.
```
If a variable index is specified multiple times in `subj` only the last entry is used. Data checks are performed as in `Mosek.putcj`.
"""
function putclist end
putclist(task:: MSKtask,subj:: Vector{T1},val:: Vector{T2}) where {T1,T2} = putclist(task,convert(Vector{Int32},subj),convert(Vector{Float64},val))
function putclist(task_:: MSKtask,subj_:: Vector{Int32},val_:: Vector{Float64})
  num_ = minimum([ length(subj_),length(val_) ])
  res = disable_sigint() do
    @MSK_putclist(task_.task,num_,subj_ .- Int32(1),val_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconbound{T1,T3,T4}(task:: MSKtask,i:: T1,bkc:: Boundkey,blc:: T3,buc:: T4)
    putconbound(task_:: MSKtask,i_:: Int32,bkc_:: Boundkey,blc_:: Float64,buc_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `bkc :: Boundkey`. New bound key.
* `blc :: Float64`. New lower bound.
* `buc :: Float64`. New upper bound.

Changes the bounds for one constraint.

If the bound value specified is numerically larger than `MSK_DPAR_DATA_TOL_BOUND_INF`` it is considered infinite and the bound key is
changed accordingly. If a bound value is numerically larger than `MSK_DPAR_DATA_TOL_BOUND_WRN``, a warning will be displayed, but the bound is inputted as specified.
"""
function putconbound end
putconbound(task:: MSKtask,i:: T1,bkc:: Boundkey,blc:: T3,buc:: T4) where {T1,T3,T4} = putconbound(task,convert(Int32,i),bkc,convert(Float64,blc),convert(Float64,buc))
function putconbound(task_:: MSKtask,i_:: Int32,bkc_:: Boundkey,blc_:: Float64,buc_:: Float64)
  res = disable_sigint() do
    @MSK_putconbound(task_.task,i_-1,bkc_.value,blc_,buc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconboundlist{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bkc:: Vector{Boundkey},blc:: Vector{T3},buc:: Vector{T4})
    putconboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. List of constraint indexes.
* `bkc :: Vector{Int32}`. Bound keys for the constraints.
* `blc :: Vector{Float64}`. Lower bounds for the constraints.
* `buc :: Vector{Float64}`. Upper bounds for the constraints.

Changes the bounds for a list of constraints. If multiple bound changes are specified for a constraint, then only the last change takes effect. Data checks are performed as in `Mosek.putconbound`.
"""
function putconboundlist end
putconboundlist(task:: MSKtask,sub:: Vector{T1},bkc:: Vector{Boundkey},blc:: Vector{T3},buc:: Vector{T4}) where {T1,T3,T4} = putconboundlist(task,convert(Vector{Int32},sub),bkc,convert(Vector{Float64},blc),convert(Vector{Float64},buc))
function putconboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64})
  bkc_i32 = Int32[item.value for item in bkc_]
  num_ = minimum([ length(sub_),length(bkc_),length(blc_),length(buc_) ])
  res = disable_sigint() do
    @MSK_putconboundlist(task_.task,num_,sub_ .- Int32(1),bkc_,blc_,buc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconboundlistconst{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bkc:: Boundkey,blc:: T3,buc:: T4)
    putconboundlistconst(task_:: MSKtask,sub_:: Vector{Int32},bkc_:: Boundkey,blc_:: Float64,buc_:: Float64)

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. List of constraint indexes.
* `bkc :: Boundkey`. New bound key for all constraints in the list.
* `blc :: Float64`. New lower bound for all constraints in the list.
* `buc :: Float64`. New upper bound for all constraints in the list.

Changes the bounds for one or more constraints. Data checks are performed as in `Mosek.putconbound`.
"""
function putconboundlistconst end
putconboundlistconst(task:: MSKtask,sub:: Vector{T1},bkc:: Boundkey,blc:: T3,buc:: T4) where {T1,T3,T4} = putconboundlistconst(task,convert(Vector{Int32},sub),bkc,convert(Float64,blc),convert(Float64,buc))
function putconboundlistconst(task_:: MSKtask,sub_:: Vector{Int32},bkc_:: Boundkey,blc_:: Float64,buc_:: Float64)
  num_ = minimum([ length(sub_) ])
  res = disable_sigint() do
    @MSK_putconboundlistconst(task_.task,num_,sub_ .- Int32(1),bkc_.value,blc_,buc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconboundslice{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bkc:: Vector{Boundkey},blc:: Vector{T4},buc:: Vector{T5})
    putconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bkc :: Vector{Int32}`. Bound keys for the constraints.
* `blc :: Vector{Float64}`. Lower bounds for the constraints.
* `buc :: Vector{Float64}`. Upper bounds for the constraints.

Changes the bounds for a slice of the constraints. Data checks are performed as in `Mosek.putconbound`.
"""
function putconboundslice end
putconboundslice(task:: MSKtask,first:: T1,last:: T2,bkc:: Vector{Boundkey},blc:: Vector{T4},buc:: Vector{T5}) where {T1,T2,T4,T5} = putconboundslice(task,convert(Int32,first),convert(Int32,last),bkc,convert(Vector{Float64},blc),convert(Vector{Float64},buc))
function putconboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bkc_:: Vector{Boundkey},blc_:: Vector{Float64},buc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(bkc_) < __tmp_var_0
    println("Array argument bkc is not long enough")
    throw(BoundsError())
  end
  bkc_i32 = Int32[item.value for item in bkc_]
  __tmp_var_1 = ((last_) - (first_))
  if length(blc_) < __tmp_var_1
    println("Array argument blc is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = ((last_) - (first_))
  if length(buc_) < __tmp_var_2
    println("Array argument buc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putconboundslice(task_.task,first_-1,last_-1,bkc_,blc_,buc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconboundsliceconst{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bkc:: Boundkey,blc:: T4,buc:: T5)
    putconboundsliceconst(task_:: MSKtask,first_:: Int32,last_:: Int32,bkc_:: Boundkey,blc_:: Float64,buc_:: Float64)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bkc :: Boundkey`. New bound key for all constraints in the slice.
* `blc :: Float64`. New lower bound for all constraints in the slice.
* `buc :: Float64`. New upper bound for all constraints in the slice.

Changes the bounds for a slice of the constraints. Data checks are performed as in `Mosek.putconbound`.
"""
function putconboundsliceconst end
putconboundsliceconst(task:: MSKtask,first:: T1,last:: T2,bkc:: Boundkey,blc:: T4,buc:: T5) where {T1,T2,T4,T5} = putconboundsliceconst(task,convert(Int32,first),convert(Int32,last),bkc,convert(Float64,blc),convert(Float64,buc))
function putconboundsliceconst(task_:: MSKtask,first_:: Int32,last_:: Int32,bkc_:: Boundkey,blc_:: Float64,buc_:: Float64)
  res = disable_sigint() do
    @MSK_putconboundsliceconst(task_.task,first_-1,last_-1,bkc_.value,blc_,buc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcone{T1,T3,T4}(task:: MSKtask,k:: T1,ct:: Conetype,conepar:: T3,submem:: Vector{T4})
    putcone(task_:: MSKtask,k_:: Int32,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. Index of the cone.
* `ct :: Conetype`. Specifies the type of the cone.
* `conepar :: Float64`. For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
* `submem :: Vector{Int32}`. Variable subscripts of the members in the cone.

Deprecated in MOSEK 10
"""
function putcone end
putcone(task:: MSKtask,k:: T1,ct:: Conetype,conepar:: T3,submem:: Vector{T4}) where {T1,T3,T4} = putcone(task,convert(Int32,k),ct,convert(Float64,conepar),convert(Vector{Int32},submem))
function putcone(task_:: MSKtask,k_:: Int32,ct_:: Conetype,conepar_:: Float64,submem_:: Vector{Int32})
  nummem_ = minimum([ length(submem_) ])
  res = disable_sigint() do
    @MSK_putcone(task_.task,k_-1,ct_.value,conepar_,nummem_,submem_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconename{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
    putconename(task_:: MSKtask,j_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the cone.
* `name :: String`. The name of the cone.

Deprecated in MOSEK 10
"""
function putconename end
putconename(task:: MSKtask,j:: T1,name:: AbstractString) where {T1} = putconename(task,convert(Int32,j),name)
function putconename(task_:: MSKtask,j_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putconename(task_.task,j_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconname{T1}(task:: MSKtask,i:: T1,name:: AbstractString)
    putconname(task_:: MSKtask,i_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `name :: String`. The name of the constraint.

Sets the name of a constraint.
"""
function putconname end
putconname(task:: MSKtask,i:: T1,name:: AbstractString) where {T1} = putconname(task,convert(Int32,i),name)
function putconname(task_:: MSKtask,i_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putconname(task_.task,i_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putconsolutioni{T1,T4,T5,T6}(task:: MSKtask,i:: T1,whichsol:: Soltype,sk:: Stakey,x:: T4,sl:: T5,su:: T6)
    putconsolutioni(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the constraint.
* `whichsol :: Soltype`. Selects a solution.
* `sk :: Stakey`. Status key of the constraint.
* `x :: Float64`. Primal solution value of the constraint.
* `sl :: Float64`. Solution value of the dual variable associated with the lower bound.
* `su :: Float64`. Solution value of the dual variable associated with the upper bound.

Sets the primal and dual solution information for a single constraint.
"""
function putconsolutioni end
putconsolutioni(task:: MSKtask,i:: T1,whichsol:: Soltype,sk:: Stakey,x:: T4,sl:: T5,su:: T6) where {T1,T4,T5,T6} = putconsolutioni(task,convert(Int32,i),whichsol,sk,convert(Float64,x),convert(Float64,sl),convert(Float64,su))
function putconsolutioni(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64)
  res = disable_sigint() do
    @MSK_putconsolutioni(task_.task,i_-1,whichsol_.value,sk_.value,x_,sl_,su_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putcslice{T1,T2,T3}(task:: MSKtask,first:: T1,last:: T2,slice:: Vector{T3})
    putcslice(task_:: MSKtask,first_:: Int32,last_:: Int32,slice_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First element in the slice of c.
* `last :: Int32`. Last element plus 1 of the slice in c to be changed.
* `slice :: Vector{Float64}`. New numerical values for the objective coefficients that should be modified.

Modifies a slice in the linear term ``c`` in the objective using the principle

```math
 c_{\\mathtt{j}} = \\mathtt{slice[j-first]}, \\mathcal{C}_q j=first,..,+1{last}
```
Data checks are performed as in `Mosek.putcj`.
"""
function putcslice end
putcslice(task:: MSKtask,first:: T1,last:: T2,slice:: Vector{T3}) where {T1,T2,T3} = putcslice(task,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},slice))
function putcslice(task_:: MSKtask,first_:: Int32,last_:: Int32,slice_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(slice_) < __tmp_var_0
    println("Array argument slice is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putcslice(task_.task,first_-1,last_-1,slice_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putdjc{T1,T2,T3,T4,T5}(task:: MSKtask,djcidx:: T1,domidxlist:: Vector{T2},afeidxlist:: Vector{T3},b:: Vector{T4},termsizelist:: Vector{T5})
    putdjc(task_:: MSKtask,djcidx_:: Int64,domidxlist_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64},termsizelist_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of the disjunctive constraint.
* `domidxlist :: Vector{Int64}`. List of domain indexes.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions.
* `termsizelist :: Vector{Int64}`. List of term sizes.

Inputs a disjunctive constraint. The constraint has the form

```math
 T_1\\ \\mathrm{or}\\ T_2\\ \\mathrm{or}\\ \\cdots\\ \\mathrm{or}\\ T_{\\mathrm{numterms}}
```
For each ``i=1,\\ldots\\mathrm{numterms}`` the ``i``-th clause (term) ``T_i`` has the form *a sequence of affine expressions belongs to a product of domains*, where the number of domains is ``\\mathrm{termsizelist}[i]`` and the number of affine expressions is equal to the sum of dimensions of all domains appearing in ``T_i``.

All the domains and all the affine expressions appearing in the above description are arranged sequentially in the lists `domidxlist` and `afeidxlist`, respectively. In particular, the length of `domidxlist` must be equal to the sum of elements of `termsizelist`, and the length of `afeidxlist` must be equal to the sum of dimensions of all the domains appearing in `domidxlist`.

The elements of `domidxlist` are indexes of domains previously defined with one of the `append...domain` functions.

The elements of `afeidxlist` are indexes to the store of affine expressions, i.e. the ``k``-th affine expression appearing in the disjunctive constraint is going to be

```math
 F_{\\mathrm{afeidxlist}[k],:}x + g_{\\mathrm{afeidxlist}[k]}
```
If an optional vector `b` of the same length as `afeidxlist` is specified then the ``k``-th affine expression appearing in the disjunctive constraint will be taken as

```math
 F_{\\mathrm{afeidxlist}[k],:}x + g_{\\mathrm{afeidxlist}[k]} - b_k
```

"""
function putdjc end
putdjc(task:: MSKtask,djcidx:: T1,domidxlist:: Vector{T2},afeidxlist:: Vector{T3},b:: Vector{T4},termsizelist:: Vector{T5}) where {T1,T2,T3,T4,T5} = putdjc(task,convert(Int64,djcidx),convert(Vector{Int64},domidxlist),convert(Vector{Int64},afeidxlist),convert(Vector{Float64},b),convert(Vector{Int64},termsizelist))
function putdjc(task_:: MSKtask,djcidx_:: Int64,domidxlist_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64},termsizelist_:: Vector{Int64})
  numafeidx_ = minimum([ length(afeidxlist_) ])
  numdomidx_ = minimum([ length(domidxlist_) ])
  numterms_ = minimum([ length(termsizelist_) ])
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putdjc(task_.task,djcidx_-1,numdomidx_,domidxlist_ .- Int32(1),numafeidx_-1,afeidxlist_ .- Int32(1),b_,numterms_,termsizelist_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putdjcname{T1}(task:: MSKtask,djcidx:: T1,name:: AbstractString)
    putdjcname(task_:: MSKtask,djcidx_:: Int64,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `djcidx :: Int64`. Index of the disjunctive constraint.
* `name :: String`. The name of the disjunctive constraint.

Sets the name of a disjunctive constraint.
"""
function putdjcname end
putdjcname(task:: MSKtask,djcidx:: T1,name:: AbstractString) where {T1} = putdjcname(task,convert(Int64,djcidx),name)
function putdjcname(task_:: MSKtask,djcidx_:: Int64,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putdjcname(task_.task,djcidx_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putdjcslice{T1,T2,T3,T4,T5,T6,T7}(task:: MSKtask,idxfirst:: T1,idxlast:: T2,domidxlist:: Vector{T3},afeidxlist:: Vector{T4},b:: Vector{T5},termsizelist:: Vector{T6},termsindjc:: Vector{T7})
    putdjcslice(task_:: MSKtask,idxfirst_:: Int64,idxlast_:: Int64,domidxlist_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64},termsizelist_:: Vector{Int64},termsindjc_:: Vector{Int64})

* `task :: MSKtask`. An optimization task.
* `idxfirst :: Int64`. Index of the first disjunctive constraint in the slice.
* `idxlast :: Int64`. Index of the last disjunctive constraint in the slice plus 1.
* `domidxlist :: Vector{Int64}`. List of domain indexes.
* `afeidxlist :: Vector{Int64}`. List of affine expression indexes.
* `b :: Vector{Float64}`. The vector of constant terms added to affine expressions. Optional, may be NULL.
* `termsizelist :: Vector{Int64}`. List of term sizes.
* `termsindjc :: Vector{Int64}`. Number of terms in each of the disjunctive constraints in the slice.

Inputs a slice of disjunctive constraints.

The array `termsindjc` should have length ``\\mathrm{idxlast}-\\mathrm{idxfirst}`` and contain the number of terms in consecutive constraints forming the slice.

The rest of the input consists of concatenated descriptions of individual constraints, where each constraint is described as in `Mosek.putdjc`.
"""
function putdjcslice end
putdjcslice(task:: MSKtask,idxfirst:: T1,idxlast:: T2,domidxlist:: Vector{T3},afeidxlist:: Vector{T4},b:: Vector{T5},termsizelist:: Vector{T6},termsindjc:: Vector{T7}) where {T1,T2,T3,T4,T5,T6,T7} = putdjcslice(task,convert(Int64,idxfirst),convert(Int64,idxlast),convert(Vector{Int64},domidxlist),convert(Vector{Int64},afeidxlist),convert(Vector{Float64},b),convert(Vector{Int64},termsizelist),convert(Vector{Int64},termsindjc))
function putdjcslice(task_:: MSKtask,idxfirst_:: Int64,idxlast_:: Int64,domidxlist_:: Vector{Int64},afeidxlist_:: Vector{Int64},b_:: Vector{Float64},termsizelist_:: Vector{Int64},termsindjc_:: Vector{Int64})
  numafeidx_ = minimum([ length(afeidxlist_) ])
  numdomidx_ = minimum([ length(domidxlist_) ])
  numterms_ = minimum([ length(termsizelist_) ])
  __tmp_var_1 = ((idxlast_) - (idxfirst_))
  if length(termsindjc_) < __tmp_var_1
    println("Array argument termsindjc is not long enough")
    throw(BoundsError())
  end
  __tmp_var_0 = (numafeidx_)
  if length(b_) < __tmp_var_0
    println("Array argument b is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putdjcslice(task_.task,idxfirst_-1,idxlast_-1,numdomidx_,domidxlist_ .- Int32(1),numafeidx_,afeidxlist_ .- Int32(1),b_,numterms_,termsizelist_,termsindjc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putdomainname{T1}(task:: MSKtask,domidx:: T1,name:: AbstractString)
    putdomainname(task_:: MSKtask,domidx_:: Int64,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `domidx :: Int64`. Index of the domain.
* `name :: String`. The name of the domain.

Sets the name of a domain.
"""
function putdomainname end
putdomainname(task:: MSKtask,domidx:: T1,name:: AbstractString) where {T1} = putdomainname(task,convert(Int64,domidx),name)
function putdomainname(task_:: MSKtask,domidx_:: Int64,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putdomainname(task_.task,domidx_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putdouparam{T2}(task:: MSKtask,param:: Dparam,parvalue:: T2)
    putdouparam(task_:: MSKtask,param_:: Dparam,parvalue_:: Float64)

* `task :: MSKtask`. An optimization task.
* `param :: Dparam`. Which parameter.
* `parvalue :: Float64`. Parameter value.

Sets the value of a double parameter.
"""
function putdouparam end
putdouparam(task:: MSKtask,param:: Dparam,parvalue:: T2) where {T2} = putdouparam(task,param,convert(Float64,parvalue))
function putdouparam(task_:: MSKtask,param_:: Dparam,parvalue_:: Float64)
  res = disable_sigint() do
    @MSK_putdouparam(task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putintparam{T2}(task:: MSKtask,param:: Iparam,parvalue:: T2)
    putintparam(task_:: MSKtask,param_:: Iparam,parvalue_:: Int32)

* `task :: MSKtask`. An optimization task.
* `param :: Iparam`. Which parameter.
* `parvalue :: Int32`. Parameter value.

Sets the value of an integer parameter.

.. msk_only:: java

   Please notice that some parameters take values that are defined in Enum
   classes. This function accepts only integer values, so to use e.g. the value
   `MSK_ON`, is necessary to use the member `.value`. For example: ::

       task.putintparam(mosek.iparam.opf_write_problem, mosek.onoffkey.on.value)
"""
function putintparam end
putintparam(task:: MSKtask,param:: Iparam,parvalue:: T2) where {T2} = putintparam(task,param,convert(Int32,parvalue))
function putintparam(task_:: MSKtask,param_:: Iparam,parvalue_:: Int32)
  res = disable_sigint() do
    @MSK_putintparam(task_.task,param_.value,parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putlicensecode{T1}(env:: MSKenv,code:: Vector{T1})
    putlicensecode(env_:: MSKenv,code_:: Vector{Int32})

* `env :: MSKenv`. The MOSEK environment.
* `code :: Vector{Int32}`. A license key string.

Input a runtime license code.
"""
function putlicensecode end
putlicensecode(env:: MSKenv,code:: Vector{T1}) where {T1} = putlicensecode(env,convert(Vector{Int32},code))
function putlicensecode(env_:: MSKenv,code_:: Vector{Int32})
  __tmp_var_0 = MSK_LICENSE_BUFFER_LENGTH
  if length(code_) < __tmp_var_0
    println("Array argument code is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putlicensecode(env_.env,code_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensedebug{T1}(env:: MSKenv,licdebug:: T1)
    putlicensedebug(env_:: MSKenv,licdebug_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `licdebug :: Int32`. Enable output of license check-out debug information.

Enables debug information for the license system. If `licdebug` is non-zero, then MOSEK will print debug info regarding the license checkout.
"""
function putlicensedebug end
putlicensedebug(env:: MSKenv,licdebug:: T1) where {T1} = putlicensedebug(env,convert(Int32,licdebug))
function putlicensedebug(env_:: MSKenv,licdebug_:: Int32)
  res = disable_sigint() do
    @MSK_putlicensedebug(env_.env,licdebug_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensepath(env_:: MSKenv,licensepath_:: AbstractString)

* `env :: MSKenv`. The MOSEK environment.
* `licensepath :: String`. A path specifying where to search for the license.

Set the path to the license file.
"""
function putlicensepath end
function putlicensepath(env_:: MSKenv,licensepath_:: AbstractString)
  res = disable_sigint() do
    @MSK_putlicensepath(env_.env,string(licensepath_))
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putlicensewait{T1}(env:: MSKenv,licwait:: T1)
    putlicensewait(env_:: MSKenv,licwait_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `licwait :: Int32`. Enable waiting for a license.

Control whether MOSEK should wait for an available license if no license is available. If `licwait` is non-zero, then MOSEK will wait for `licwait-1` milliseconds between each check for an available license.
"""
function putlicensewait end
putlicensewait(env:: MSKenv,licwait:: T1) where {T1} = putlicensewait(env,convert(Int32,licwait))
function putlicensewait(env_:: MSKenv,licwait_:: Int32)
  res = disable_sigint() do
    @MSK_putlicensewait(env_.env,licwait_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    putmaxnumacc{T1}(task:: MSKtask,maxnumacc:: T1)
    putmaxnumacc(task_:: MSKtask,maxnumacc_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumacc :: Int64`. Number of preallocated affine conic constraints.

Sets the number of preallocated affine conic constraints in the optimization task. When this
number is reached MOSEK will automatically allocate more space.
It is never mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.
"""
function putmaxnumacc end
putmaxnumacc(task:: MSKtask,maxnumacc:: T1) where {T1} = putmaxnumacc(task,convert(Int64,maxnumacc))
function putmaxnumacc(task_:: MSKtask,maxnumacc_:: Int64)
  res = disable_sigint() do
    @MSK_putmaxnumacc(task_.task,maxnumacc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumafe{T1}(task:: MSKtask,maxnumafe:: T1)
    putmaxnumafe(task_:: MSKtask,maxnumafe_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumafe :: Int64`. Number of preallocated affine expressions.

Sets the number of preallocated affine expressions in the optimization task. When this
number is reached MOSEK will automatically allocate more space for affine expressions.
It is never mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.
"""
function putmaxnumafe end
putmaxnumafe(task:: MSKtask,maxnumafe:: T1) where {T1} = putmaxnumafe(task,convert(Int64,maxnumafe))
function putmaxnumafe(task_:: MSKtask,maxnumafe_:: Int64)
  res = disable_sigint() do
    @MSK_putmaxnumafe(task_.task,maxnumafe_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumanz{T1}(task:: MSKtask,maxnumanz:: T1)
    putmaxnumanz(task_:: MSKtask,maxnumanz_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumanz :: Int64`. New size of the storage reserved for storing the linear coefficient matrix.

Sets the number of preallocated non-zero entries in ``A``.

MOSEK stores only the non-zero elements in the linear coefficient matrix ``A`` and it
cannot predict how much storage is required to store ``A``. Using this
function it is possible to specify the number of non-zeros to preallocate for
storing ``A``.

If the number of non-zeros in the problem is known, it is a good idea to set
`maxnumanz` slightly larger than this number, otherwise a rough estimate can
be used. In general, if ``A`` is inputted in many small chunks, setting
this value may speed up the data input phase.

It is not mandatory to call this function, since MOSEK will reallocate
internal structures whenever it is necessary.

The function call has no effect if both `maxnumcon` and `maxnumvar` are zero.
"""
function putmaxnumanz end
putmaxnumanz(task:: MSKtask,maxnumanz:: T1) where {T1} = putmaxnumanz(task,convert(Int64,maxnumanz))
function putmaxnumanz(task_:: MSKtask,maxnumanz_:: Int64)
  res = disable_sigint() do
    @MSK_putmaxnumanz(task_.task,maxnumanz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumbarvar{T1}(task:: MSKtask,maxnumbarvar:: T1)
    putmaxnumbarvar(task_:: MSKtask,maxnumbarvar_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumbarvar :: Int32`. Number of preallocated symmetric matrix variables.

Sets the number of preallocated symmetric matrix variables in the optimization
task. When this number of variables is reached MOSEK will automatically
allocate more space for variables.

It is not mandatory to call this function. It only gives a
hint about the amount of data to preallocate for efficiency reasons.

Please note that `maxnumbarvar` must be larger than the current number of
symmetric matrix variables in the task.
"""
function putmaxnumbarvar end
putmaxnumbarvar(task:: MSKtask,maxnumbarvar:: T1) where {T1} = putmaxnumbarvar(task,convert(Int32,maxnumbarvar))
function putmaxnumbarvar(task_:: MSKtask,maxnumbarvar_:: Int32)
  res = disable_sigint() do
    @MSK_putmaxnumbarvar(task_.task,maxnumbarvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumcon{T1}(task:: MSKtask,maxnumcon:: T1)
    putmaxnumcon(task_:: MSKtask,maxnumcon_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. Number of preallocated constraints in the optimization task.

Sets the number of preallocated constraints in the optimization task. When this
number of constraints is reached MOSEK will automatically allocate more space
for constraints.

It is never mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.

Please note that `maxnumcon` must be larger than the current number of
constraints in the task.
"""
function putmaxnumcon end
putmaxnumcon(task:: MSKtask,maxnumcon:: T1) where {T1} = putmaxnumcon(task,convert(Int32,maxnumcon))
function putmaxnumcon(task_:: MSKtask,maxnumcon_:: Int32)
  res = disable_sigint() do
    @MSK_putmaxnumcon(task_.task,maxnumcon_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumcone{T1}(task:: MSKtask,maxnumcone:: T1)
    putmaxnumcone(task_:: MSKtask,maxnumcone_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumcone :: Int32`. Number of preallocated conic constraints in the optimization task.

Deprecated in MOSEK 10

Sets the number of preallocated conic constraints in the optimization task.
When this number of conic constraints is reached MOSEK will automatically
allocate more space for conic constraints.

It is not mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.

Please note that `maxnumcon` must be larger than the current number of conic
constraints in the task.
"""
function putmaxnumcone end
putmaxnumcone(task:: MSKtask,maxnumcone:: T1) where {T1} = putmaxnumcone(task,convert(Int32,maxnumcone))
function putmaxnumcone(task_:: MSKtask,maxnumcone_:: Int32)
  res = disable_sigint() do
    @MSK_putmaxnumcone(task_.task,maxnumcone_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumdjc{T1}(task:: MSKtask,maxnumdjc:: T1)
    putmaxnumdjc(task_:: MSKtask,maxnumdjc_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumdjc :: Int64`. Number of preallocated disjunctive constraints in the task.

Sets the number of preallocated disjunctive constraints in the optimization task. When this
number is reached MOSEK will automatically allocate more space.
It is never mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.
"""
function putmaxnumdjc end
putmaxnumdjc(task:: MSKtask,maxnumdjc:: T1) where {T1} = putmaxnumdjc(task,convert(Int64,maxnumdjc))
function putmaxnumdjc(task_:: MSKtask,maxnumdjc_:: Int64)
  res = disable_sigint() do
    @MSK_putmaxnumdjc(task_.task,maxnumdjc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumdomain{T1}(task:: MSKtask,maxnumdomain:: T1)
    putmaxnumdomain(task_:: MSKtask,maxnumdomain_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumdomain :: Int64`. Number of preallocated domains.

Sets the number of preallocated domains in the optimization task. When this
number is reached MOSEK will automatically allocate more space.
It is never mandatory to call this function, since MOSEK will reallocate any
internal structures whenever it is required.
"""
function putmaxnumdomain end
putmaxnumdomain(task:: MSKtask,maxnumdomain:: T1) where {T1} = putmaxnumdomain(task,convert(Int64,maxnumdomain))
function putmaxnumdomain(task_:: MSKtask,maxnumdomain_:: Int64)
  res = disable_sigint() do
    @MSK_putmaxnumdomain(task_.task,maxnumdomain_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumqnz{T1}(task:: MSKtask,maxnumqnz:: T1)
    putmaxnumqnz(task_:: MSKtask,maxnumqnz_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumqnz :: Int64`. Number of non-zero elements preallocated in quadratic coefficient matrices.

Sets the number of preallocated non-zero entries in quadratic terms.

MOSEK stores only the non-zero elements in ``Q``. Therefore, MOSEK
cannot predict how much storage is required to store ``Q``. Using this
function it is possible to specify the number non-zeros to preallocate for
storing ``Q`` (both objective and constraints).

It may be advantageous to reserve more non-zeros for ``Q`` than actually
needed since it may improve the internal efficiency of MOSEK, however, it is
never worthwhile to specify more than the double of the anticipated number of
non-zeros in ``Q``.

It is not mandatory to call this function, since MOSEK will reallocate
internal structures whenever it is necessary.
"""
function putmaxnumqnz end
putmaxnumqnz(task:: MSKtask,maxnumqnz:: T1) where {T1} = putmaxnumqnz(task,convert(Int64,maxnumqnz))
function putmaxnumqnz(task_:: MSKtask,maxnumqnz_:: Int64)
  res = disable_sigint() do
    @MSK_putmaxnumqnz(task_.task,maxnumqnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putmaxnumvar{T1}(task:: MSKtask,maxnumvar:: T1)
    putmaxnumvar(task_:: MSKtask,maxnumvar_:: Int32)

* `task :: MSKtask`. An optimization task.
* `maxnumvar :: Int32`. Number of preallocated variables in the optimization task.

Sets the number of preallocated variables in the optimization task. When this
number of variables is reached MOSEK will automatically allocate more space
for variables.

It is not mandatory to call this function. It only gives
a hint about the amount of data to preallocate for efficiency reasons.

Please note that `maxnumvar` must be larger than the current number of
variables in the task.
"""
function putmaxnumvar end
putmaxnumvar(task:: MSKtask,maxnumvar:: T1) where {T1} = putmaxnumvar(task,convert(Int32,maxnumvar))
function putmaxnumvar(task_:: MSKtask,maxnumvar_:: Int32)
  res = disable_sigint() do
    @MSK_putmaxnumvar(task_.task,maxnumvar_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putnadouparam{T2}(task:: MSKtask,paramname:: AbstractString,parvalue:: T2)
    putnadouparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Float64)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Float64`. Parameter value.

Sets the value of a named double parameter.
"""
function putnadouparam end
putnadouparam(task:: MSKtask,paramname:: AbstractString,parvalue:: T2) where {T2} = putnadouparam(task,paramname,convert(Float64,parvalue))
function putnadouparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Float64)
  res = disable_sigint() do
    @MSK_putnadouparam(task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putnaintparam{T2}(task:: MSKtask,paramname:: AbstractString,parvalue:: T2)
    putnaintparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Int32)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: Int32`. Parameter value.

Sets the value of a named integer parameter.
"""
function putnaintparam end
putnaintparam(task:: MSKtask,paramname:: AbstractString,parvalue:: T2) where {T2} = putnaintparam(task,paramname,convert(Int32,parvalue))
function putnaintparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: Int32)
  res = disable_sigint() do
    @MSK_putnaintparam(task_.task,string(paramname_),parvalue_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putnastrparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `paramname :: String`. Name of a parameter.
* `parvalue :: String`. Parameter value.

Sets the value of a named string parameter.
"""
function putnastrparam end
function putnastrparam(task_:: MSKtask,paramname_:: AbstractString,parvalue_:: AbstractString)
  res = disable_sigint() do
    @MSK_putnastrparam(task_.task,string(paramname_),string(parvalue_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putobjname(task_:: MSKtask,objname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `objname :: String`. Name of the objective.

Assigns a new name to the objective.
"""
function putobjname end
function putobjname(task_:: MSKtask,objname_:: AbstractString)
  res = disable_sigint() do
    @MSK_putobjname(task_.task,string(objname_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putobjsense(task_:: MSKtask,sense_:: Objsense)

* `task :: MSKtask`. An optimization task.
* `sense :: Objsense`. The objective sense of the task

Sets the objective sense of the task.
"""
function putobjsense end
function putobjsense(task_:: MSKtask,sense_:: Objsense)
  res = disable_sigint() do
    @MSK_putobjsense(task_.task,sense_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putoptserverhost(task_:: MSKtask,host_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `host :: String`. A URL specifying the optimization server to be used.

Specify an OptServer URL for remote calls. The URL should contain protocol, host and port in the form `http://server:port` or `https://server:port`. If the URL is set using this function, all subsequent calls to any MOSEK function that involves synchronous optimization will be sent to the specified OptServer instead of being executed locally. Passing NULL deactivates this redirection.
"""
function putoptserverhost end
function putoptserverhost(task_:: MSKtask,host_:: AbstractString)
  res = disable_sigint() do
    @MSK_putoptserverhost(task_.task,string(host_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putparam(task_:: MSKtask,parname_:: AbstractString,parvalue_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `parname :: String`. Parameter name.
* `parvalue :: String`. Parameter value.

Checks if `parname` is valid parameter name. If it is, the parameter is
assigned the value specified by `parvalue`.
"""
function putparam end
function putparam(task_:: MSKtask,parname_:: AbstractString,parvalue_:: AbstractString)
  res = disable_sigint() do
    @MSK_putparam(task_.task,string(parname_),string(parvalue_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqcon{T1,T2,T3,T4}(task:: MSKtask,qcsubk:: Vector{T1},qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4})
    putqcon(task_:: MSKtask,qcsubk_:: Vector{Int32},qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `qcsubk :: Vector{Int32}`. Constraint subscripts for quadratic coefficients.
* `qcsubi :: Vector{Int32}`. Row subscripts for quadratic constraint matrix.
* `qcsubj :: Vector{Int32}`. Column subscripts for quadratic constraint matrix.
* `qcval :: Vector{Float64}`. Quadratic constraint coefficient values.

Replace all quadratic entries in the constraints. The list of constraints has the form

```math
 l_k^c \\leq  \\frac{1}{2} \\sum_{i=0}^{+1{numvar}} \\sum_{j=0}^{+1{numvar}} q_{ij}^k x_i x_j + \\sum_{j=0}^{+1{numvar}} a_{kj} x_j \\leq u_k^c, ~\\  k=0,\\ldots,m-1.
```
This function sets all the quadratic terms to zero and then performs the update:

```math
 q_{\\mathtt{qcsubi[t]},\\mathtt{qcsubj[t]}}^{\\mathtt{qcsubk[t]}} = q_{\\mathtt{\\mathtt{qcsubj[t]},qcsubi[t]}}^{\\mathtt{qcsubk[t]}} = q_{\\mathtt{\\mathtt{qcsubj[t]},qcsubi[t]}}^{\\mathtt{qcsubk[t]}}  + \\mathtt{qcval[t]},
```
for ``t=1,\\ldots,+1{numqcnz}``.

Please note that:

* For large problems it is essential for the efficiency that the function `Mosek.putmaxnumqnz` is employed to pre-allocate space.
* Only the lower triangular parts should be specified because the ``Q`` matrices are symmetric. Specifying entries where ``i < j`` will result in an error.
* Only non-zero elements should be specified.
* The order in which the non-zero elements are specified is insignificant.
* Duplicate elements are added together as shown above. Hence, it is usually not recommended to specify the same entry multiple times.

For a code example see Section :ref:`doc.tutorial_qo`
"""
function putqcon end
putqcon(task:: MSKtask,qcsubk:: Vector{T1},qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4}) where {T1,T2,T3,T4} = putqcon(task,convert(Vector{Int32},qcsubk),convert(Vector{Int32},qcsubi),convert(Vector{Int32},qcsubj),convert(Vector{Float64},qcval))
function putqcon(task_:: MSKtask,qcsubk_:: Vector{Int32},qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})
  numqcnz_ = minimum([ length(qcsubi_),length(qcsubj_),length(qcval_) ])
  res = disable_sigint() do
    @MSK_putqcon(task_.task,numqcnz_,qcsubk_ .- Int32(1),qcsubi_ .- Int32(1),qcsubj_ .- Int32(1),qcval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqconk{T1,T2,T3,T4}(task:: MSKtask,k:: T1,qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4})
    putqconk{T1}(task:: MSKtask,k:: T1,Qk:: SparseMatrixCSC{Float64})
    putqconk(task_:: MSKtask,k_:: Int32,qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `k :: Int32`. The constraint in which the new quadratic elements are inserted.
* `qcsubi :: Vector{Int32}`. Row subscripts for quadratic constraint matrix.
* `qcsubj :: Vector{Int32}`. Column subscripts for quadratic constraint matrix.
* `qcval :: Vector{Float64}`. Quadratic constraint coefficient values.
* `Qk :: SparseMatrixCSC{Float64}`. The symmetric matrix 1/2 (Qk' + Qk) is used

Replaces all the quadratic entries in one constraint. This function performs the same operations as `Mosek.putqcon` but only with respect to constraint number `k` and it does not modify the other constraints. See the description of `Mosek.putqcon` for definitions and important remarks.
"""
function putqconk end
putqconk(task:: MSKtask,k:: T1,qcsubi:: Vector{T2},qcsubj:: Vector{T3},qcval:: Vector{T4}) where {T1,T2,T3,T4} = putqconk(task,convert(Int32,k),convert(Vector{Int32},qcsubi),convert(Vector{Int32},qcsubj),convert(Vector{Float64},qcval))
function putqconk(task:: MSKtask,k:: T1,Qk:: SparseMatrixCSC{Float64}) where {T1}
  qcsubi,qcsubj,qcval = tril(Qk)
  putqconk(task,k,qcsubi,qcsubj,qcval)
end
function putqconk(task_:: MSKtask,k_:: Int32,qcsubi_:: Vector{Int32},qcsubj_:: Vector{Int32},qcval_:: Vector{Float64})
  numqcnz_ = minimum([ length(qcsubi_),length(qcsubj_),length(qcval_) ])
  res = disable_sigint() do
    @MSK_putqconk(task_.task,k_-1,numqcnz_,qcsubi_ .- Int32(1),qcsubj_ .- Int32(1),qcval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqobj{T1,T2,T3}(task:: MSKtask,qosubi:: Vector{T1},qosubj:: Vector{T2},qoval:: Vector{T3})
    putqobj(task:: MSKtask,Qk:: SparseMatrixCSC{Float64})
    putqobj(task_:: MSKtask,qosubi_:: Vector{Int32},qosubj_:: Vector{Int32},qoval_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `qosubi :: Vector{Int32}`. Row subscripts for quadratic objective coefficients.
* `qosubj :: Vector{Int32}`. Column subscripts for quadratic objective coefficients.
* `qoval :: Vector{Float64}`. Quadratic objective coefficient values.
* `Qk :: SparseMatrixCSC{Float64}`. The symmetric matrix 1/2 (Qk' + Qk) is used

Replace all quadratic terms in the objective. If the objective has the form

```math
 \\frac{1}{2} \\sum_{i=0}^{+1{numvar}} \\sum_{j=0}^{+1{numvar}} q_{ij}^o x_i x_j + \\sum_{j=0}^{+1{numvar}} c_{j} x_j + c^f
```
then this function sets all the quadratic terms to zero and then performs the update:

```math
 q_{\\mathtt{qosubi[t]},\\mathtt{qosubj[t]}}^{o} = q_{\\mathtt{\\mathtt{qosubj[t]},qosubi[t]}}^{o} = q_{\\mathtt{\\mathtt{qosubj[t]},qosubi[t]}}^{o}  + \\mathtt{qoval[t]},
```
for ``t=1,\\ldots,+1{numqonz}``.

See the description of `Mosek.putqcon` for important remarks and example.
"""
function putqobj end
putqobj(task:: MSKtask,qosubi:: Vector{T1},qosubj:: Vector{T2},qoval:: Vector{T3}) where {T1,T2,T3} = putqobj(task,convert(Vector{Int32},qosubi),convert(Vector{Int32},qosubj),convert(Vector{Float64},qoval))
function putqobj(task:: MSKtask,Qk:: SparseMatrixCSC{Float64})
  qosubi,qosubj,qoval = tril(Qk)
  putqobj(task,qosubi,qosubj,qoval)
end
function putqobj(task_:: MSKtask,qosubi_:: Vector{Int32},qosubj_:: Vector{Int32},qoval_:: Vector{Float64})
  numqonz_ = minimum([ length(qosubi_),length(qosubj_),length(qoval_) ])
  res = disable_sigint() do
    @MSK_putqobj(task_.task,numqonz_,qosubi_ .- Int32(1),qosubj_ .- Int32(1),qoval_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putqobjij{T1,T2,T3}(task:: MSKtask,i:: T1,j:: T2,qoij:: T3)
    putqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32,qoij_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Row index for the coefficient to be replaced.
* `j :: Int32`. Column index for the coefficient to be replaced.
* `qoij :: Float64`. The new coefficient value.

Replaces one coefficient in the quadratic term in the objective. The function
performs the assignment

```math
 q_{ij}^o = q_{ji}^o = \\mathtt{qoij}.
```
Only the elements in the lower triangular part are accepted. Setting
``q_{ij}`` with ``j>i`` will cause an error.

Please note that replacing all quadratic elements one by one is more
computationally expensive than replacing them all at once. Use
`Mosek.putqobj` instead whenever possible.
"""
function putqobjij end
putqobjij(task:: MSKtask,i:: T1,j:: T2,qoij:: T3) where {T1,T2,T3} = putqobjij(task,convert(Int32,i),convert(Int32,j),convert(Float64,qoij))
function putqobjij(task_:: MSKtask,i_:: Int32,j_:: Int32,qoij_:: Float64)
  res = disable_sigint() do
    @MSK_putqobjij(task_.task,i_-1,j_-1,qoij_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskc(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Int32}`. Status keys for the constraints.

Sets the status keys for the constraints.
"""
function putskc end
function putskc(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey})
  __tmp_var_0 = getnumcon(task_)
  if length(skc_) < __tmp_var_0
    println("Array argument skc is not long enough")
    throw(BoundsError())
  end
  skc_i32 = Int32[item.value for item in skc_]
  res = disable_sigint() do
    @MSK_putskc(task_.task,whichsol_.value,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskcslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skc:: Vector{Stakey})
    putskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skc_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skc :: Vector{Int32}`. Status keys for the constraints.

Sets the status keys for a slice of the constraints.
"""
function putskcslice end
putskcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skc:: Vector{Stakey}) where {T2,T3} = putskcslice(task,whichsol,convert(Int32,first),convert(Int32,last),skc)
function putskcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skc_:: Vector{Stakey})
  __tmp_var_0 = ((last_) - (first_))
  if length(skc_) < __tmp_var_0
    println("Array argument skc is not long enough")
    throw(BoundsError())
  end
  skc_i32 = Int32[item.value for item in skc_]
  res = disable_sigint() do
    @MSK_putskcslice(task_.task,whichsol_.value,first_-1,last_-1,skc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskx(task_:: MSKtask,whichsol_:: Soltype,skx_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skx :: Vector{Int32}`. Status keys for the variables.

Sets the status keys for the scalar variables.
"""
function putskx end
function putskx(task_:: MSKtask,whichsol_:: Soltype,skx_:: Vector{Stakey})
  __tmp_var_0 = getnumvar(task_)
  if length(skx_) < __tmp_var_0
    println("Array argument skx is not long enough")
    throw(BoundsError())
  end
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @MSK_putskx(task_.task,whichsol_.value,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putskxslice{T2,T3}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skx:: Vector{Stakey})
    putskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skx_:: Vector{Stakey})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `skx :: Vector{Int32}`. Status keys for the variables.

Sets the status keys for a slice of the variables.
"""
function putskxslice end
putskxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,skx:: Vector{Stakey}) where {T2,T3} = putskxslice(task,whichsol,convert(Int32,first),convert(Int32,last),skx)
function putskxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,skx_:: Vector{Stakey})
  __tmp_var_0 = ((last_) - (first_))
  if length(skx_) < __tmp_var_0
    println("Array argument skx is not long enough")
    throw(BoundsError())
  end
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @MSK_putskxslice(task_.task,whichsol_.value,first_-1,last_-1,skx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslc{T2}(task:: MSKtask,whichsol:: Soltype,slc:: Vector{T2})
    putslc(task_:: MSKtask,whichsol_:: Soltype,slc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Sets the ``s_l^c`` vector for a solution.
"""
function putslc end
putslc(task:: MSKtask,whichsol:: Soltype,slc:: Vector{T2}) where {T2} = putslc(task,whichsol,convert(Vector{Float64},slc))
function putslc(task_:: MSKtask,whichsol_:: Soltype,slc_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(slc_) < __tmp_var_0
    println("Array argument slc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putslc(task_.task,whichsol_.value,slc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslcslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slc:: Vector{T4})
    putslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.

Sets a slice of the ``s_l^c`` vector for a solution.
"""
function putslcslice end
putslcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slc:: Vector{T4}) where {T2,T3,T4} = putslcslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},slc))
function putslcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(slc_) < __tmp_var_0
    println("Array argument slc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putslcslice(task_.task,whichsol_.value,first_-1,last_-1,slc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslx{T2}(task:: MSKtask,whichsol:: Soltype,slx:: Vector{T2})
    putslx(task_:: MSKtask,whichsol_:: Soltype,slx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Sets the ``s_l^x`` vector for a solution.
"""
function putslx end
putslx(task:: MSKtask,whichsol:: Soltype,slx:: Vector{T2}) where {T2} = putslx(task,whichsol,convert(Vector{Float64},slx))
function putslx(task_:: MSKtask,whichsol_:: Soltype,slx_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(slx_) < __tmp_var_0
    println("Array argument slx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putslx(task_.task,whichsol_.value,slx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putslxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slx:: Vector{T4})
    putslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.

Sets a slice of the ``s_l^x`` vector for a solution.
"""
function putslxslice end
putslxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,slx:: Vector{T4}) where {T2,T3,T4} = putslxslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},slx))
function putslxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,slx_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(slx_) < __tmp_var_0
    println("Array argument slx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putslxslice(task_.task,whichsol_.value,first_-1,last_-1,slx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsnx{T2}(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2})
    putsnx(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Sets the ``s_n^x`` vector for a solution.
"""
function putsnx end
putsnx(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2}) where {T2} = putsnx(task,whichsol,convert(Vector{Float64},sux))
function putsnx(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(sux_) < __tmp_var_0
    println("Array argument sux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putsnx(task_.task,whichsol_.value,sux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsnxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,snx:: Vector{T4})
    putsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,snx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Sets a slice of the ``s_n^x`` vector for a solution.
"""
function putsnxslice end
putsnxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,snx:: Vector{T4}) where {T2,T3,T4} = putsnxslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},snx))
function putsnxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,snx_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(snx_) < __tmp_var_0
    println("Array argument snx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putsnxslice(task_.task,whichsol_.value,first_-1,last_-1,snx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsolution{T5,T6,T7,T8,T9,T10,T11,T12}(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12})
    putsolution(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Int32}`. Status keys for the constraints.
* `skx :: Vector{Int32}`. Status keys for the variables.
* `skn :: Vector{Int32}`. Status keys for the conic constraints.
* `xc :: Vector{Float64}`. Primal constraint solution.
* `xx :: Vector{Float64}`. Primal variable solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.

Inserts a solution into the task.
"""
function putsolution end
putsolution(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12}) where {T5,T6,T7,T8,T9,T10,T11,T12} = putsolution(task,whichsol,skc,skx,skn,convert(Vector{Float64},xc),convert(Vector{Float64},xx),convert(Vector{Float64},y),convert(Vector{Float64},slc),convert(Vector{Float64},suc),convert(Vector{Float64},slx),convert(Vector{Float64},sux),convert(Vector{Float64},snx))
function putsolution(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64})
  skc_i32 = Int32[item.value for item in skc_]
  skn_i32 = Int32[item.value for item in skn_]
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @MSK_putsolution(task_.task,whichsol_.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsolutionnew{T5,T6,T7,T8,T9,T10,T11,T12,T13}(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12},doty:: Vector{T13})
    putsolutionnew(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64},doty_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `skc :: Vector{Int32}`. Status keys for the constraints.
* `skx :: Vector{Int32}`. Status keys for the variables.
* `skn :: Vector{Int32}`. Status keys for the conic constraints.
* `xc :: Vector{Float64}`. Primal constraint solution.
* `xx :: Vector{Float64}`. Primal variable solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.
* `slc :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the constraints.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.
* `slx :: Vector{Float64}`. Dual variables corresponding to the lower bounds on the variables.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.
* `snx :: Vector{Float64}`. Dual variables corresponding to the conic constraints on the variables.
* `doty :: Vector{Float64}`. Dual variables corresponding to affine conic constraints.

Inserts a solution into the task.
"""
function putsolutionnew end
putsolutionnew(task:: MSKtask,whichsol:: Soltype,skc:: Vector{Stakey},skx:: Vector{Stakey},skn:: Vector{Stakey},xc:: Vector{T5},xx:: Vector{T6},y:: Vector{T7},slc:: Vector{T8},suc:: Vector{T9},slx:: Vector{T10},sux:: Vector{T11},snx:: Vector{T12},doty:: Vector{T13}) where {T5,T6,T7,T8,T9,T10,T11,T12,T13} = putsolutionnew(task,whichsol,skc,skx,skn,convert(Vector{Float64},xc),convert(Vector{Float64},xx),convert(Vector{Float64},y),convert(Vector{Float64},slc),convert(Vector{Float64},suc),convert(Vector{Float64},slx),convert(Vector{Float64},sux),convert(Vector{Float64},snx),convert(Vector{Float64},doty))
function putsolutionnew(task_:: MSKtask,whichsol_:: Soltype,skc_:: Vector{Stakey},skx_:: Vector{Stakey},skn_:: Vector{Stakey},xc_:: Vector{Float64},xx_:: Vector{Float64},y_:: Vector{Float64},slc_:: Vector{Float64},suc_:: Vector{Float64},slx_:: Vector{Float64},sux_:: Vector{Float64},snx_:: Vector{Float64},doty_:: Vector{Float64})
  skc_i32 = Int32[item.value for item in skc_]
  skn_i32 = Int32[item.value for item in skn_]
  skx_i32 = Int32[item.value for item in skx_]
  res = disable_sigint() do
    @MSK_putsolutionnew(task_.task,whichsol_.value,skc_,skx_,skn_,xc_,xx_,y_,slc_,suc_,slx_,sux_,snx_,doty_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsolutionyi{T1,T3}(task:: MSKtask,i:: T1,whichsol:: Soltype,y:: T3)
    putsolutionyi(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,y_:: Float64)

* `task :: MSKtask`. An optimization task.
* `i :: Int32`. Index of the dual variable.
* `whichsol :: Soltype`. Selects a solution.
* `y :: Float64`. Solution value of the dual variable.

Inputs the dual variable of a solution.
"""
function putsolutionyi end
putsolutionyi(task:: MSKtask,i:: T1,whichsol:: Soltype,y:: T3) where {T1,T3} = putsolutionyi(task,convert(Int32,i),whichsol,convert(Float64,y))
function putsolutionyi(task_:: MSKtask,i_:: Int32,whichsol_:: Soltype,y_:: Float64)
  res = disable_sigint() do
    @MSK_putsolutionyi(task_.task,i_-1,whichsol_.value,y_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putstrparam(task_:: MSKtask,param_:: Sparam,parvalue_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `param :: Sparam`. Which parameter.
* `parvalue :: String`. Parameter value.

Sets the value of a string parameter.
"""
function putstrparam end
function putstrparam(task_:: MSKtask,param_:: Sparam,parvalue_:: AbstractString)
  res = disable_sigint() do
    @MSK_putstrparam(task_.task,param_.value,string(parvalue_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsuc{T2}(task:: MSKtask,whichsol:: Soltype,suc:: Vector{T2})
    putsuc(task_:: MSKtask,whichsol_:: Soltype,suc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Sets the ``s_u^c`` vector for a solution.
"""
function putsuc end
putsuc(task:: MSKtask,whichsol:: Soltype,suc:: Vector{T2}) where {T2} = putsuc(task,whichsol,convert(Vector{Float64},suc))
function putsuc(task_:: MSKtask,whichsol_:: Soltype,suc_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(suc_) < __tmp_var_0
    println("Array argument suc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putsuc(task_.task,whichsol_.value,suc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsucslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,suc:: Vector{T4})
    putsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,suc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `suc :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the constraints.

Sets a slice of the ``s_u^c`` vector for a solution.
"""
function putsucslice end
putsucslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,suc:: Vector{T4}) where {T2,T3,T4} = putsucslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},suc))
function putsucslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,suc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(suc_) < __tmp_var_0
    println("Array argument suc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putsucslice(task_.task,whichsol_.value,first_-1,last_-1,suc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsux{T2}(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2})
    putsux(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Sets the ``s_u^x`` vector for a solution.
"""
function putsux end
putsux(task:: MSKtask,whichsol:: Soltype,sux:: Vector{T2}) where {T2} = putsux(task,whichsol,convert(Vector{Float64},sux))
function putsux(task_:: MSKtask,whichsol_:: Soltype,sux_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(sux_) < __tmp_var_0
    println("Array argument sux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putsux(task_.task,whichsol_.value,sux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putsuxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,sux:: Vector{T4})
    putsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,sux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `sux :: Vector{Float64}`. Dual variables corresponding to the upper bounds on the variables.

Sets a slice of the ``s_u^x`` vector for a solution.
"""
function putsuxslice end
putsuxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,sux:: Vector{T4}) where {T2,T3,T4} = putsuxslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},sux))
function putsuxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,sux_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(sux_) < __tmp_var_0
    println("Array argument sux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putsuxslice(task_.task,whichsol_.value,first_-1,last_-1,sux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    puttaskname(task_:: MSKtask,taskname_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `taskname :: String`. Name assigned to the task.

Assigns a new name to the task.
"""
function puttaskname end
function puttaskname(task_:: MSKtask,taskname_:: AbstractString)
  res = disable_sigint() do
    @MSK_puttaskname(task_.task,string(taskname_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarbound{T1,T3,T4}(task:: MSKtask,j:: T1,bkx:: Boundkey,blx:: T3,bux:: T4)
    putvarbound(task_:: MSKtask,j_:: Int32,bkx_:: Boundkey,blx_:: Float64,bux_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `bkx :: Boundkey`. New bound key.
* `blx :: Float64`. New lower bound.
* `bux :: Float64`. New upper bound.

Changes the bounds for one variable.

If the bound value specified is numerically larger than
`MSK_DPAR_DATA_TOL_BOUND_INF`` it is considered infinite and the bound key is
changed accordingly. If a bound value is numerically larger than
`MSK_DPAR_DATA_TOL_BOUND_WRN``, a warning will be displayed, but the bound is
inputted as specified.
"""
function putvarbound end
putvarbound(task:: MSKtask,j:: T1,bkx:: Boundkey,blx:: T3,bux:: T4) where {T1,T3,T4} = putvarbound(task,convert(Int32,j),bkx,convert(Float64,blx),convert(Float64,bux))
function putvarbound(task_:: MSKtask,j_:: Int32,bkx_:: Boundkey,blx_:: Float64,bux_:: Float64)
  res = disable_sigint() do
    @MSK_putvarbound(task_.task,j_-1,bkx_.value,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarboundlist{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bkx:: Vector{Boundkey},blx:: Vector{T3},bux:: Vector{T4})
    putvarboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. List of variable indexes.
* `bkx :: Vector{Int32}`. Bound keys for the variables.
* `blx :: Vector{Float64}`. Lower bounds for the variables.
* `bux :: Vector{Float64}`. Upper bounds for the variables.

Changes the bounds for one or more variables. If multiple bound changes are specified for a variable, then only the last change takes effect. Data checks are performed as in `Mosek.putvarbound`.
"""
function putvarboundlist end
putvarboundlist(task:: MSKtask,sub:: Vector{T1},bkx:: Vector{Boundkey},blx:: Vector{T3},bux:: Vector{T4}) where {T1,T3,T4} = putvarboundlist(task,convert(Vector{Int32},sub),bkx,convert(Vector{Float64},blx),convert(Vector{Float64},bux))
function putvarboundlist(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})
  bkx_i32 = Int32[item.value for item in bkx_]
  num_ = minimum([ length(sub_),length(bkx_),length(blx_),length(bux_) ])
  res = disable_sigint() do
    @MSK_putvarboundlist(task_.task,num_,sub_ .- Int32(1),bkx_,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarboundlistconst{T1,T3,T4}(task:: MSKtask,sub:: Vector{T1},bkx:: Boundkey,blx:: T3,bux:: T4)
    putvarboundlistconst(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Boundkey,blx_:: Float64,bux_:: Float64)

* `task :: MSKtask`. An optimization task.
* `sub :: Vector{Int32}`. List of variable indexes.
* `bkx :: Boundkey`. New bound key for all variables in the list.
* `blx :: Float64`. New lower bound for all variables in the list.
* `bux :: Float64`. New upper bound for all variables in the list.

Changes the bounds for one or more variables. Data checks are performed as in `Mosek.putvarbound`.
"""
function putvarboundlistconst end
putvarboundlistconst(task:: MSKtask,sub:: Vector{T1},bkx:: Boundkey,blx:: T3,bux:: T4) where {T1,T3,T4} = putvarboundlistconst(task,convert(Vector{Int32},sub),bkx,convert(Float64,blx),convert(Float64,bux))
function putvarboundlistconst(task_:: MSKtask,sub_:: Vector{Int32},bkx_:: Boundkey,blx_:: Float64,bux_:: Float64)
  num_ = minimum([ length(sub_) ])
  res = disable_sigint() do
    @MSK_putvarboundlistconst(task_.task,num_,sub_ .- Int32(1),bkx_.value,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarboundslice{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bkx:: Vector{Boundkey},blx:: Vector{T4},bux:: Vector{T5})
    putvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bkx :: Vector{Int32}`. Bound keys for the variables.
* `blx :: Vector{Float64}`. Lower bounds for the variables.
* `bux :: Vector{Float64}`. Upper bounds for the variables.

Changes the bounds for a slice of the variables. Data checks are performed as in `Mosek.putvarbound`.
"""
function putvarboundslice end
putvarboundslice(task:: MSKtask,first:: T1,last:: T2,bkx:: Vector{Boundkey},blx:: Vector{T4},bux:: Vector{T5}) where {T1,T2,T4,T5} = putvarboundslice(task,convert(Int32,first),convert(Int32,last),bkx,convert(Vector{Float64},blx),convert(Vector{Float64},bux))
function putvarboundslice(task_:: MSKtask,first_:: Int32,last_:: Int32,bkx_:: Vector{Boundkey},blx_:: Vector{Float64},bux_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(bkx_) < __tmp_var_0
    println("Array argument bkx is not long enough")
    throw(BoundsError())
  end
  bkx_i32 = Int32[item.value for item in bkx_]
  __tmp_var_1 = ((last_) - (first_))
  if length(blx_) < __tmp_var_1
    println("Array argument blx is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = ((last_) - (first_))
  if length(bux_) < __tmp_var_2
    println("Array argument bux is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putvarboundslice(task_.task,first_-1,last_-1,bkx_,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarboundsliceconst{T1,T2,T4,T5}(task:: MSKtask,first:: T1,last:: T2,bkx:: Boundkey,blx:: T4,bux:: T5)
    putvarboundsliceconst(task_:: MSKtask,first_:: Int32,last_:: Int32,bkx_:: Boundkey,blx_:: Float64,bux_:: Float64)

* `task :: MSKtask`. An optimization task.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `bkx :: Boundkey`. New bound key for all variables in the slice.
* `blx :: Float64`. New lower bound for all variables in the slice.
* `bux :: Float64`. New upper bound for all variables in the slice.

Changes the bounds for a slice of the variables. Data checks are performed as in `Mosek.putvarbound`.
"""
function putvarboundsliceconst end
putvarboundsliceconst(task:: MSKtask,first:: T1,last:: T2,bkx:: Boundkey,blx:: T4,bux:: T5) where {T1,T2,T4,T5} = putvarboundsliceconst(task,convert(Int32,first),convert(Int32,last),bkx,convert(Float64,blx),convert(Float64,bux))
function putvarboundsliceconst(task_:: MSKtask,first_:: Int32,last_:: Int32,bkx_:: Boundkey,blx_:: Float64,bux_:: Float64)
  res = disable_sigint() do
    @MSK_putvarboundsliceconst(task_.task,first_-1,last_-1,bkx_.value,blx_,bux_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarname{T1}(task:: MSKtask,j:: T1,name:: AbstractString)
    putvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `name :: String`. The variable name.

Sets the name of a variable.
"""
function putvarname end
putvarname(task:: MSKtask,j:: T1,name:: AbstractString) where {T1} = putvarname(task,convert(Int32,j),name)
function putvarname(task_:: MSKtask,j_:: Int32,name_:: AbstractString)
  res = disable_sigint() do
    @MSK_putvarname(task_.task,j_-1,string(name_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvarsolutionj{T1,T4,T5,T6,T7}(task:: MSKtask,j:: T1,whichsol:: Soltype,sk:: Stakey,x:: T4,sl:: T5,su:: T6,sn:: T7)
    putvarsolutionj(task_:: MSKtask,j_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64,sn_:: Float64)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `whichsol :: Soltype`. Selects a solution.
* `sk :: Stakey`. Status key of the variable.
* `x :: Float64`. Primal solution value of the variable.
* `sl :: Float64`. Solution value of the dual variable associated with the lower bound.
* `su :: Float64`. Solution value of the dual variable associated with the upper bound.
* `sn :: Float64`. Solution value of the dual variable associated with the conic constraint.

Sets the primal and dual solution information for a single variable.
"""
function putvarsolutionj end
putvarsolutionj(task:: MSKtask,j:: T1,whichsol:: Soltype,sk:: Stakey,x:: T4,sl:: T5,su:: T6,sn:: T7) where {T1,T4,T5,T6,T7} = putvarsolutionj(task,convert(Int32,j),whichsol,sk,convert(Float64,x),convert(Float64,sl),convert(Float64,su),convert(Float64,sn))
function putvarsolutionj(task_:: MSKtask,j_:: Int32,whichsol_:: Soltype,sk_:: Stakey,x_:: Float64,sl_:: Float64,su_:: Float64,sn_:: Float64)
  res = disable_sigint() do
    @MSK_putvarsolutionj(task_.task,j_-1,whichsol_.value,sk_.value,x_,sl_,su_,sn_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvartype{T1}(task:: MSKtask,j:: T1,vartype:: Variabletype)
    putvartype(task_:: MSKtask,j_:: Int32,vartype_:: Variabletype)

* `task :: MSKtask`. An optimization task.
* `j :: Int32`. Index of the variable.
* `vartype :: Variabletype`. The new variable type.

Sets the variable type of one variable.
"""
function putvartype end
putvartype(task:: MSKtask,j:: T1,vartype:: Variabletype) where {T1} = putvartype(task,convert(Int32,j),vartype)
function putvartype(task_:: MSKtask,j_:: Int32,vartype_:: Variabletype)
  res = disable_sigint() do
    @MSK_putvartype(task_.task,j_-1,vartype_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putvartypelist{T1}(task:: MSKtask,subj:: Vector{T1},vartype:: Vector{Variabletype})
    putvartypelist(task_:: MSKtask,subj_:: Vector{Int32},vartype_:: Vector{Variabletype})

* `task :: MSKtask`. An optimization task.
* `subj :: Vector{Int32}`. A list of variable indexes for which the variable type should be changed.
* `vartype :: Vector{Int32}`. A list of variable types.

Sets the variable type for one or more variables. If the same index is specified multiple times in `subj` only the last entry
takes effect.
"""
function putvartypelist end
putvartypelist(task:: MSKtask,subj:: Vector{T1},vartype:: Vector{Variabletype}) where {T1} = putvartypelist(task,convert(Vector{Int32},subj),vartype)
function putvartypelist(task_:: MSKtask,subj_:: Vector{Int32},vartype_:: Vector{Variabletype})
  vartype_i32 = Int32[item.value for item in vartype_]
  num_ = minimum([ length(subj_),length(vartype_) ])
  res = disable_sigint() do
    @MSK_putvartypelist(task_.task,num_,subj_ .- Int32(1),vartype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    xc = putxc(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xc :: Vector{Float64}`. Primal constraint solution.

Sets the ``x^c`` vector for a solution.
"""
function putxc end
function putxc(task_:: MSKtask,whichsol_:: Soltype)
  __tmp_var_0 = getnumcon(task_)
  __tmp_var_1 = zeros(Float64,__tmp_var_0)
  xc_ = __tmp_var_1
  res = disable_sigint() do
    @MSK_putxc(task_.task,whichsol_.value,__tmp_var_1)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_1)
end

"""
    putxcslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xc:: Vector{T4})
    putxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xc_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xc :: Vector{Float64}`. Primal constraint solution.

Sets a slice of the ``x^c`` vector for a solution.
"""
function putxcslice end
putxcslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xc:: Vector{T4}) where {T2,T3,T4} = putxcslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},xc))
function putxcslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xc_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(xc_) < __tmp_var_0
    println("Array argument xc is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putxcslice(task_.task,whichsol_.value,first_-1,last_-1,xc_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putxx{T2}(task:: MSKtask,whichsol:: Soltype,xx:: Vector{T2})
    putxx(task_:: MSKtask,whichsol_:: Soltype,xx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `xx :: Vector{Float64}`. Primal variable solution.

Sets the ``x^x`` vector for a solution.
"""
function putxx end
putxx(task:: MSKtask,whichsol:: Soltype,xx:: Vector{T2}) where {T2} = putxx(task,whichsol,convert(Vector{Float64},xx))
function putxx(task_:: MSKtask,whichsol_:: Soltype,xx_:: Vector{Float64})
  __tmp_var_0 = getnumvar(task_)
  if length(xx_) < __tmp_var_0
    println("Array argument xx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putxx(task_.task,whichsol_.value,xx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putxxslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xx:: Vector{T4})
    putxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xx_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `xx :: Vector{Float64}`. Primal variable solution.

Sets a slice of the ``x^x`` vector for a solution.
"""
function putxxslice end
putxxslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,xx:: Vector{T4}) where {T2,T3,T4} = putxxslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},xx))
function putxxslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,xx_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(xx_) < __tmp_var_0
    println("Array argument xx is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putxxslice(task_.task,whichsol_.value,first_-1,last_-1,xx_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    puty{T2}(task:: MSKtask,whichsol:: Soltype,y:: Vector{T2})
    puty(task_:: MSKtask,whichsol_:: Soltype,y_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Sets the ``y`` vector for a solution.
"""
function puty end
puty(task:: MSKtask,whichsol:: Soltype,y:: Vector{T2}) where {T2} = puty(task,whichsol,convert(Vector{Float64},y))
function puty(task_:: MSKtask,whichsol_:: Soltype,y_:: Vector{Float64})
  __tmp_var_0 = getnumcon(task_)
  if length(y_) < __tmp_var_0
    println("Array argument y is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_puty(task_.task,whichsol_.value,y_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    putyslice{T2,T3,T4}(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,y:: Vector{T4})
    putyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,y_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `first :: Int32`. First index in the sequence.
* `last :: Int32`. Last index plus 1 in the sequence.
* `y :: Vector{Float64}`. Vector of dual variables corresponding to the constraints.

Sets a slice of the ``y`` vector for a solution.
"""
function putyslice end
putyslice(task:: MSKtask,whichsol:: Soltype,first:: T2,last:: T3,y:: Vector{T4}) where {T2,T3,T4} = putyslice(task,whichsol,convert(Int32,first),convert(Int32,last),convert(Vector{Float64},y))
function putyslice(task_:: MSKtask,whichsol_:: Soltype,first_:: Int32,last_:: Int32,y_:: Vector{Float64})
  __tmp_var_0 = ((last_) - (first_))
  if length(y_) < __tmp_var_0
    println("Array argument y is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_putyslice(task_.task,whichsol_.value,first_-1,last_-1,y_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readdata(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Reads an optimization problem and associated data from a file.
"""
function readdata end
function readdata(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_readdataautoformat(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readdataformat(task_:: MSKtask,filename_:: AbstractString,format_:: Dataformat,compress_:: Compresstype)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.
* `format :: Dataformat`. File data format.
* `compress :: Compresstype`. File compression type.

Reads an optimization problem and associated data from a file.
"""
function readdataformat end
function readdataformat(task_:: MSKtask,filename_:: AbstractString,format_:: Dataformat,compress_:: Compresstype)
  res = disable_sigint() do
    @MSK_readdataformat(task_.task,string(filename_),format_.value,compress_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readjsonstring(task_:: MSKtask,data_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `data :: String`. Problem data in text format.

Load task data from a JSON string, replacing any data that already exists in the task
object. All problem data, parameters and other settings are resorted, but if the string contains solutions, the
solution status after loading a file is set to unknown, even if it is optimal
or otherwise well-defined.
"""
function readjsonstring end
function readjsonstring(task_:: MSKtask,data_:: AbstractString)
  res = disable_sigint() do
    @MSK_readjsonstring(task_.task,string(data_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readlpstring(task_:: MSKtask,data_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `data :: String`. Problem data in text format.

Load task data from a string in LP format, replacing any data that already exists in the task
object.
"""
function readlpstring end
function readlpstring(task_:: MSKtask,data_:: AbstractString)
  res = disable_sigint() do
    @MSK_readlpstring(task_.task,string(data_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readopfstring(task_:: MSKtask,data_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `data :: String`. Problem data in text format.

Load task data from a string in OPF format, replacing any data that already exists in the task
object.
"""
function readopfstring end
function readopfstring(task_:: MSKtask,data_:: AbstractString)
  res = disable_sigint() do
    @MSK_readopfstring(task_.task,string(data_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readparamfile(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Reads MOSEK parameters from a file. Data is read from the file `filename` if it is a nonempty string. Otherwise data is read from the file specified by :msk:sparam:`param_read_file_name`.
"""
function readparamfile end
function readparamfile(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_readparamfile(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readptfstring(task_:: MSKtask,data_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `data :: String`. Problem data in text format.

Load task data from a PTF string, replacing any data that already exists in the task
object. All problem data, parameters and other settings are resorted, but if the string contains solutions, the
solution status after loading a file is set to unknown, even if it is optimal
or otherwise well-defined.
"""
function readptfstring end
function readptfstring(task_:: MSKtask,data_:: AbstractString)
  res = disable_sigint() do
    @MSK_readptfstring(task_.task,string(data_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readsolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `filename :: String`. A valid file name.

Reads a solution file and inserts it as a specified solution in the task. Data is read from the file `filename` if it is a nonempty string. Otherwise data is read from one of the files specified by :msk:sparam:`bas_sol_file_name`, :msk:sparam:`itr_sol_file_name` or :msk:sparam:`int_sol_file_name` depending on which solution is chosen.
"""
function readsolution end
function readsolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_readsolution(task_.task,whichsol_.value,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readsummary(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Prints a short summary of last file that was read.
"""
function readsummary end
function readsummary(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @MSK_readsummary(task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    readtask(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Load task data from a file, replacing any data that already exists in the task
object. All problem data, parameters and other settings are resorted, but if the file contains solutions, the
solution status after loading a file is set to unknown, even if it was optimal
or otherwise well-defined when the file was dumped.

See section :ref:`doc.shared.taskformat` for a description of the Task format.
"""
function readtask end
function readtask(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_readtask(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removebarvars{T1}(task:: MSKtask,subset:: Vector{T1})
    removebarvars(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of symmetric matrices which should be removed.

The function removes a subset of the symmetric matrices
from the optimization task. This implies that the remaining
symmetric matrices are renumbered.
"""
function removebarvars end
removebarvars(task:: MSKtask,subset:: Vector{T1}) where {T1} = removebarvars(task,convert(Vector{Int32},subset))
function removebarvars(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @MSK_removebarvars(task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removecones{T1}(task:: MSKtask,subset:: Vector{T1})
    removecones(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of cones which should be removed.

Deprecated in MOSEK 10

Removes a number of conic constraints from the problem. This implies that the remaining conic constraints are renumbered.
In general, it is much more efficient to remove a cone with a high index than a low index.
"""
function removecones end
removecones(task:: MSKtask,subset:: Vector{T1}) where {T1} = removecones(task,convert(Vector{Int32},subset))
function removecones(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @MSK_removecones(task_.task,num_,subset_ .- Int32(1))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removecons{T1}(task:: MSKtask,subset:: Vector{T1})
    removecons(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of constraints which should be removed.

The function removes a subset of the constraints
from the optimization task. This implies that the remaining
constraints are renumbered.
"""
function removecons end
removecons(task:: MSKtask,subset:: Vector{T1}) where {T1} = removecons(task,convert(Vector{Int32},subset))
function removecons(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @MSK_removecons(task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    removevars{T1}(task:: MSKtask,subset:: Vector{T1})
    removevars(task_:: MSKtask,subset_:: Vector{Int32})

* `task :: MSKtask`. An optimization task.
* `subset :: Vector{Int32}`. Indexes of variables which should be removed.

The function removes a subset of the variables
from the optimization task. This implies that the remaining
variables are renumbered.
"""
function removevars end
removevars(task:: MSKtask,subset:: Vector{T1}) where {T1} = removevars(task,convert(Vector{Int32},subset))
function removevars(task_:: MSKtask,subset_:: Vector{Int32})
  num_ = minimum([ length(subset_) ])
  res = disable_sigint() do
    @MSK_removevars(task_.task,num_,subset_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    resizetask{T1,T2,T3,T4,T5}(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,maxnumcone:: T3,maxnumanz:: T4,maxnumqnz:: T5)
    resizetask(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,maxnumcone_:: Int32,maxnumanz_:: Int64,maxnumqnz_:: Int64)

* `task :: MSKtask`. An optimization task.
* `maxnumcon :: Int32`. New maximum number of constraints.
* `maxnumvar :: Int32`. New maximum number of variables.
* `maxnumcone :: Int32`. New maximum number of cones.
* `maxnumanz :: Int64`. New maximum number of linear non-zero elements.
* `maxnumqnz :: Int64`. New maximum number of quadratic non-zeros elements.

Sets the amount of preallocated space assigned for each type of data in an
optimization task.

It is never mandatory to call this function, since it only gives
a hint about the amount of data to preallocate for efficiency reasons.

Please note that the procedure is **destructive** in the sense that all
existing data stored in the task is destroyed.
"""
function resizetask end
resizetask(task:: MSKtask,maxnumcon:: T1,maxnumvar:: T2,maxnumcone:: T3,maxnumanz:: T4,maxnumqnz:: T5) where {T1,T2,T3,T4,T5} = resizetask(task,convert(Int32,maxnumcon),convert(Int32,maxnumvar),convert(Int32,maxnumcone),convert(Int64,maxnumanz),convert(Int64,maxnumqnz))
function resizetask(task_:: MSKtask,maxnumcon_:: Int32,maxnumvar_:: Int32,maxnumcone_:: Int32,maxnumanz_:: Int64,maxnumqnz_:: Int64)
  res = disable_sigint() do
    @MSK_resizetask(task_.task,maxnumcon_,maxnumvar_,maxnumcone_,maxnumanz_,maxnumqnz_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    sensitivityreport(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Reads a sensitivity format file from a location given by
:msk:sparam:`sensitivity_file_name` and writes the result to the stream
`whichstream`. If :msk:sparam:`sensitivity_res_file_name` is set to a non-empty
string, then the sensitivity report is also written to a file of this name.
"""
function sensitivityreport end
function sensitivityreport(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @MSK_sensitivityreport(task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    setdefaults(task_:: MSKtask)

* `task :: MSKtask`. An optimization task.

Resets all the parameters to their default values.
"""
function setdefaults end
function setdefaults(task_:: MSKtask)
  res = disable_sigint() do
    @MSK_setdefaults(task_.task)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    setupthreads{T1}(env:: MSKenv,numthreads:: T1)
    setupthreads(env_:: MSKenv,numthreads_:: Int32)

* `env :: MSKenv`. The MOSEK environment.
* `numthreads :: Int32`. Number of threads.

Preallocates a thread pool for the interior-point and conic optimizers in the current process. This function should only be called once per process, before first optimization. Future settings of the parameter `MSK_IPAR_NUM_THREADS`` will be irrelevant for the conic optimizer.
"""
function setupthreads end
setupthreads(env:: MSKenv,numthreads:: T1) where {T1} = setupthreads(env,convert(Int32,numthreads))
function setupthreads(env_:: MSKenv,numthreads_:: Int32)
  res = disable_sigint() do
    @MSK_setupthreads(env_.env,numthreads_)
  end
  if res != MSK_RES_OK.value
    throw(MosekError(res,""))
  end
end

"""
    isdef = solutiondef(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `isdef :: Bool`. Is non-zero if the requested solution is defined.

Checks whether a solution is defined.
"""
function solutiondef end
function solutiondef(task_:: MSKtask,whichsol_:: Soltype)
  isdef_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_solutiondef(task_.task,whichsol_.value,isdef_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (convert(Bool,isdef_.x))
end

"""
    solutionsummary(task_:: MSKtask,whichstream_:: Streamtype)

* `task :: MSKtask`. An optimization task.
* `whichstream :: Streamtype`. Index of the stream.

Prints a short summary of the current solutions.
"""
function solutionsummary end
function solutionsummary(task_:: MSKtask,whichstream_:: Streamtype)
  res = disable_sigint() do
    @MSK_solutionsummary(task_.task,whichstream_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    numnz = solvewithbasis{T1,T2,T3,T4}(task:: MSKtask,transp:: T1,numnz:: T2,sub:: Vector{T3},val:: Vector{T4})
    numnz = solvewithbasis(task_:: MSKtask,transp_:: Int32,numnz_:: Int32,sub_:: Vector{Int32},val_:: Vector{Float64})

* `task :: MSKtask`. An optimization task.
* `transp :: Int32`. Controls which problem formulation is solved.
* `numnz :: Int32`. Input (number of non-zeros in right-hand side) and output (number of non-zeros in solution vector).
* `sub :: Vector{Int32}`. Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).
* `val :: Vector{Float64}`. Input (right-hand side values) and output (solution vector values).

If a basic solution is available, then exactly ``numcon``
basis variables are defined.  These ``numcon`` basis
variables are denoted the basis.  Associated with the basis is a basis
matrix denoted ``B``.  This function solves either the linear
equation system

```math
:label: ais-eq-Bxb

B \\bar X = b
```
or the system

```math
:label: ais-eq-Btxb

B^T \\bar X = b
```
for the unknowns ``\\bar X``, with ``b`` being a user-defined  vector.
In order to make sense of the solution ``\\bar X`` it is important
to know the ordering of the variables in the basis because the
ordering specifies how ``B`` is constructed. When calling
`Mosek.initbasissolve` an ordering of the basis variables is
obtained, which can be used to deduce how MOSEK has constructed
``B``. Indeed if the ``k``-th basis variable is variable
``x_j`` it implies that


```math
 B_{i,k} = A_{i,j}, ~i=1,\\ldots,+1{numcon}.
```
Otherwise if the ``k``-th basis variable is variable ``x_j^c`` it implies that

```math
B_{i,k} = \\left\\{ \\begin{array}{ll}
                        -1, & i = j, \\\\
                        0 , & i \\neq j. \\\\
                    \\end{array}
            \\right.
```
The function `Mosek.initbasissolve` must be called before a call to this function.
Please note that this function exploits the
sparsity in the vector ``b`` to speed up the computations.
"""
function solvewithbasis end
solvewithbasis(task:: MSKtask,transp:: T1,numnz:: T2,sub:: Vector{T3},val:: Vector{T4}) where {T1,T2,T3,T4} = solvewithbasis(task,convert(Int32,transp),convert(Int32,numnz),convert(Vector{Int32},sub),convert(Vector{Float64},val))
function solvewithbasis(task_:: MSKtask,transp_:: Int32,numnz_:: Int32,sub_:: Vector{Int32},val_:: Vector{Float64})
  __tmp_var_0 = Ref{Int32}(numnz_)
  __tmp_var_1 = getnumcon(task_)
  if length(sub_) < __tmp_var_1
    println("Array argument sub is not long enough")
    throw(BoundsError())
  end
  __tmp_var_2 = getnumcon(task_)
  if length(val_) < __tmp_var_2
    println("Array argument val is not long enough")
    throw(BoundsError())
  end
  res = disable_sigint() do
    @MSK_solvewithbasis(task_.task,transp_,__tmp_var_0,sub_ .- Int32(1),val_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (__tmp_var_0.x)
end

"""
    conetype = strtoconetype(task_:: MSKtask,str_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `str :: String`. String corresponding to the cone type code.
* `conetype :: Conetype`. The cone type corresponding to str.

Deprecated in MOSEK 10

Obtains cone type code corresponding to a cone type string.
"""
function strtoconetype end
function strtoconetype(task_:: MSKtask,str_:: AbstractString)
  conetype_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_strtoconetype(task_.task,string(str_),conetype_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Conetype(conetype_.x))
end

"""
    sk = strtosk(task_:: MSKtask,str_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `str :: String`. A status key abbreviation string.
* `sk :: Stakey`. Status key corresponding to the string.

Obtains the status key corresponding to an abbreviation string.
"""
function strtosk end
function strtosk(task_:: MSKtask,str_:: AbstractString)
  sk_ = Ref(Int32(1))
  res = disable_sigint() do
    @MSK_strtosk(task_.task,string(str_),sk_)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
  (Stakey(sk_.x))
end

"""
    updatesolutioninfo(task_:: MSKtask,whichsol_:: Soltype)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.

Update the information items related to the solution.
"""
function updatesolutioninfo end
function updatesolutioninfo(task_:: MSKtask,whichsol_:: Soltype)
  res = disable_sigint() do
    @MSK_updatesolutioninfo(task_.task,whichsol_.value)
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writedata(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Writes problem data associated with the optimization task to a file in one of
the supported formats. See Section :ref:`doc.shared.file_formats` for the complete list.

The data file format is determined by the file name extension. To write
in compressed format append the extension `.gz`.  E.g to write a gzip
compressed MPS file use the extension `mps.gz`.

Please note that MPS, LP and OPF files require all variables to have unique
names. If a task contains no names, it is possible to write the file with
automatically generated anonymous names by setting the
`MSK_IPAR_WRITE_GENERIC_NAMES`` parameter to `MSK_ON`.

Data is written to the file `filename`
if it is a nonempty string. Otherwise data is written
to the file specified by :msk:sparam:`data_file_name`.
"""
function writedata end
function writedata(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_writedata(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writejsonsol(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Saves the current solutions and solver information items in a JSON file.
"""
function writejsonsol end
function writejsonsol(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_writejsonsol(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writeparamfile(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Writes all the parameters to a parameter file.
"""
function writeparamfile end
function writeparamfile(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_writeparamfile(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writesolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `whichsol :: Soltype`. Selects a solution.
* `filename :: String`. A valid file name.

Saves the current basic, interior-point, or integer solution to a file.
"""
function writesolution end
function writesolution(task_:: MSKtask,whichsol_:: Soltype,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_writesolution(task_.task,whichsol_.value,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end

"""
    writetask(task_:: MSKtask,filename_:: AbstractString)

* `task :: MSKtask`. An optimization task.
* `filename :: String`. A valid file name.

Write a binary dump of the task data. This format saves all problem data, coefficients and parameter settings. See section :ref:`doc.shared.taskformat` for a description of the Task format.
"""
function writetask end
function writetask(task_:: MSKtask,filename_:: AbstractString)
  res = disable_sigint() do
    @MSK_writetask(task_.task,string(filename_))
  end
  if res != MSK_RES_OK.value
    msg = getlasterror(task_)
    throw(MosekError(res,msg))
  end
end
